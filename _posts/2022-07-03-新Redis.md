---
Layout: post
desc: 新 Redis
title:  新 Redis
tag:  study
---

## 新 Redis

### <1> 什么是 Redis

#### 1.1 Redis简介

Redis 是现在最受欢迎的 NoSQL 数据库之一，Redis 是一个包含多种数据库结构，支持网络、基于内存、可选持久性的 键值对 （Key - Value）存储数据库



从广义上来讲，Redis 可以称为数据库



> Redis 也符合“按照数据结构来组织、存储和管理数据的仓库”的定义，可以说是一种数据库

NoSQL是各种资料中常见的词，它是“Not Only SQL”的缩写，泛指非关系型数据库。



我们常用的MySQL、SqlServer 都是关系型数据库，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但随着互联网的高速发展，传统的关系型数据库在应对超大规模、超大流量以及高并发的时候力不从心，这就需要使用到像 Redis 这样的 NoSQL 数据库。



下面是 Redis 的 Logo：

![redis2](/Users/dongyanzu/Desktop/redis2.png)

这个Logo很像一个积木盒子，里面放了各种各样形状的玩具。这也预示着 Redis 的作用：存放任意内容。



#### 1.2 Redis 使用场景

Redis 被称为数据库，但不一定跟 MySQL 冲突，系统不是只能使用二者之一。



Redis 的 常见 的、核心的使用场景是：作为数据缓存（cache）。因为其数据读取速度快，能够大大地 提高运行效率，所以 Redis 在大多数情况下被称作“缓存”。



> Redis 的“缓存”叫法更明确，“数据库”叫法比较专业
>
> > 大家看资料的时候有概念，能理解就好了，不用纠结叫法

缓存，顾名思义，就是把数据存放在缓冲区，当查找数据时，首先会在缓存中进行查找，如果存在，就获取；否则就访问数据库。频繁的从数据中读取数据，减少访问数据库的次数，可以提高运行效率。

![d4-1-2-1](/Users/dongyanzu/Desktop/d4-1-2-1.png)

读写缓存内容值Value，都是通过 Key 来完成的。用Key进行查询的方式非常简单，不像关系型数据库可以写各种查询语句用各种调解进行查询。

> 下面的章节会详细讲。当前可以参考 Java Map 理解 Key - Value 结构

所以，Redis 缓存与 MySQL 等数据库并不冲突，而是有益的补充。

> 有时候你会看到某些资料称"Redis"为“缓存数据库”，也不要觉得奇怪。

Redis速度快的第一个直观原因是，数据存储在计算机的内存中，基于内存当然读写速度快，但内存空间有限，所以数据不宜永久保存。

> 计算机重启后数据消失。

当然，Redis也可以做到数据永久保存（保存在磁盘上），但这是可选项。主要应用场景还是作为缓存。



#### 1.3 Redis 优点

数据读取速度快是 Redis 的优点，但为们还需要了解一下其它的优点：



##### 1. 支持多种数据类型

Redis 支持 Set、ZSet、List、Hash、String 这五种数据类型，操作非常方便。



这五种类型详细的使用方法在后面的章节的实战项目中逐步学习，稍安勿躁。



要首先 特别强调的是 ：Redis 是 ANSIC 语言编写的，并不是 Java 语言。在后面的学习过程中，不能把 Java 对象 和 Redis 的数据类型画上等号，只能参照 Java 的概念辅助理解。例如 hash，可以参照 java 的Map 理解其基本结构，但切勿等同。



##### 2.持久化存储

把数据从内存保存在磁盘上从而保证计算机掉电不丢失，叫做持久化存储。

> 持久化是一个比较宽泛的概念，数据以任何形式（各种文件甚至存入MySQL）保存，只要做到不丢失都叫持久化。

![store](/Users/dongyanzu/Desktop/store.jpeg)

作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。Redis使用RDB和AOF做数据的持久化存储。主从数据同时生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。

- rdb：rdb在指定的时间间隔内将内存中的数据集快照写入磁盘
- aof：aof以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

##### 3.性能很好

由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。

经过有些公司的观测，项目使用 Redis ，访问频率是 80w/s 是线上运行仍然一切ok。





##### **缺点：**

说了优点，大家在面试的时候，可能还会被问到缺点。



##### 内存容量问题



由于 Redis 是内存数据库，短时间内大量增加数据，可能导致内存不够用。



Redis 本身有数据过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。



##### 持久化存储的性能损耗问题



如果进行完整持久化，就需要生成rdb文件并传输保存，会占用主机的CPU，并消耗网络带宽。虽然Redis2.8版本以后，已经有只保存部分变化过的数据的功能，但是还是有可能有完整持久化的。比如，新上线的从库。



##### 重启速度可能慢

将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis不能提供服务。



##### 1.4 安装Redis

##### 1. 安装Docker

`Docker`是近年来非常流行的虚拟化技术，主要用Docker来安装Redis，自由化程度较高、非常简便。



使用命令行终端登录服务器后，依次输入命令执行：

```shell
sudo yum -y update
sudo yum -y install epel-release
sudo yum -y install docker-io
```

> 如果出现错误提示：“未找到匹配的参数：docke-io“或”错误：没有任何匹配：docker-io“，则尝试输入命令：
>
> `sudo yum-y` install docker

如果不使用Docker，安装Redis的步骤是非常繁琐的；而使用Docker技术，仅仅几个简单的步骤就能快速安装Redis，自动化程度较高，非常简便。

##### 注意

- 平台已经安装了Docker，不需要重复安装
- 推荐在自己购买的 云服务器 上安装Docker；当然，云服务器如果已经安装过 Docker ，就不用重复安装了。

##### 2.安装Redis并启动

```shell
sudo docker pull redis:latest
sudo docker images
sudo docker run  --name redis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass "Hello122342"
```

**6379** 是 Redis 服务的端口号。



**Hello122342** 是 Redis 服务器密码，非常重要，一定要改为自己密码。

> 在自己购买的 云服务器 上安装Redis，别忘了在安全组管理中，开放端口号。

##### 验证是否启动成功

```
sudo docker ps
```

<img src="/Users/dongyanzu/Library/Application Support/typora-user-images/Screen Shot 2022-04-18 at 4.38.24 PM.png" alt="Screen Shot 2022-04-18 at 4.38.24 PM" style="zoom:150%;" />

另一个是MongoDB，很熟悉。



### <2>实战-高并发用户注册

#### 2.1 Cookie 与 Session 回顾

在《Spring Web全栈》课程中已经讲述了 Cookie 与 Session 的联系和区别，这里再稍微回顾一下。



Cookie可以在浏览器（或者说客户端）中保存数据，重要的使用场景就是判断用户是否登录，以判别用户身份。出现Cookie技术，主要是因为 http 是无状态协议。



##### 无状态

无状态指的是，浏览器发出的每次请求都是独立的，相互完全没有关联的。

比如我们使用浏览器打开的淘宝网站，再点击进入详细页查看某个商品，我们还可以不断的刷新商品详情页面，这些操作都是一个个独立的Http请求。

http协议设计成无状态，就比较简单，适应性更强。

##### 实现有状态的Web

在实际使用场景中，web应用是需要有状态的：必须先登录才能下单购物；同一个页面，会因是否登录而不同（有状态）。这样的网络世界才是多姿多彩的。那么怎么实现有状态的web呢？



大约有两种思路：

1. 升级http协议，变成有状态的设计
2. http协议不变，使用其它技术辅助

显然，目前流行的是第二种方案，以Session、Cookie等状态机制作为辅助，实现有状态的web。

> 升级http协议难度大、不灵活

我们在《Java网络编程》中学过的各种headers，实际上都是作为辅助机制，在客户端和服务端通讯过程中传递状态。



##### Cookie 与 Session 的区别

由于 Cookie 是存在客户端，用户都是可以看到的，而且可以任意修改，这样就很不安全。于是Session就诞生了，Session存储于服务端，Session是共享的，可以让两个页面都获取到。



存放位置的不同，是主要区别，其它的还有一些次要的区别：Cookie有大小限制，Session无限制（取决于服务端的硬件）。



##### Session需要解决的问题

Session 放在应用服务器的内存中，带来的问题是，服务器一旦出问题比如重启，所有的Session都会丢失，所有用户都需要登录，这就导致用户体验非常差。



另外，中大型网站往往是分布式架构，有很多服务器，Session放在一台服务器中，那么请求分发到其它服务器的时候，就读不到登录状态了，同样用户体验非常差，



> 前面Spring课程讲了Session，但是基于本地服务器的。

怎么解决问题呢？于是Redis作为缓存登场。将Session缓存到Redis里，多台服务器可以共享Session，并且Redis相对稳定，不会像应用服务器一样，需求多经常发布重启。

![redissession](/Users/dongyanzu/Desktop/redissession.svg)

> 这种不同计算机承担不同职责，多台计算机共同形成一个完整系统，就叫分布式系统。



#### 2.2 SpringBoot集成Redis

在《深入SSM框架》课程中已经完成了用户注册和登录，本章课程的主要内容就是引入Redis，优化系统和升级Session存储，在此动手实践的过程中，学习Redis相关的技术知识。



首先看一下SpringBoot项目如何集成：



##### 1. 引入依赖

pom.xml增加依赖项：

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

这个步骤大家都比较熟悉了。

SpringBoot 的机制是的集成过程比较简单。

##### 2. 配置

`application.properties`中增加Redis相关的配置：

```java
# Redis服务器地址
spring.redis.host=192.168.0.1
# Redis 服务器端口号
spring.redis.port=6379
# Redis 服务器密码 （请换成自己机器密码）
spring.redis.password=
```

`192.168.0.1`是在平台上启动的Redis服务的IP地址，是固定的，

> 如果在自己购买的云服务器上安装Redis，那么就要改成云服务器的公网IP地址。
>
> > 再次提醒：要在安全组设置中，打开6379端口哦

#### 2.3 注册性能优化

小明在某项目中负责用户注册登录模块的开发，项目发布上线后，出现一个很奇怪的问题：每天晚上八点服务器就会挂掉。

小明很头疼，求助公司技术专家，经过仔细分析发现，每天晚上有人恶意攻击，平凡注册。

![bidui](/Users/dongyanzu/Desktop/bidui.svg)

恶意注册时，相当于服务器在短时间内收到了大量的用户注册，导致数据库处理变慢，又反过来影响了应用请求的速度，形成恶性循环。此类并发较高的情况下很容易导致系统宕机。

> 应用处理请求过慢，会导致请求大量积压堵塞，大量堵塞的请求消耗大量内存，最终导致服务器崩溃。

##### 那能不能优化呢？

公司技术专家建议小明研究Redis。小明发现，Redis作为支持高并发的缓存系统，能有效减少对mysql数据库的访问。是和几觉此类问题。

![redisregistered](/Users/dongyanzu/Desktop/redisregistered.svg)

> 数据读写优化是系统优化的一个很重要的方面

##### 分析

在注册过程中，有两个操作访问了数据库：

1. 判断是否重名，需要先查询
2. 保存用户数据

第二个操作保存用户数据，这个很难优化，这是必须的操作。



那么优化重点就是第一个操作：我们可以把用户数据缓存在Redis里，每次校验先从Redis里查询用户数据。这样就可以有效减少对数据库的访问。

> 当然用户数据更新时，也需要实时更新Redis数据

##### *步骤：*

##### 1. 注入 RedisTemplate 实例



RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate 进行多种操作。

```java
@Component
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDAO userDAO;

    @Autowired
    private RedisTemplate redisTemplate;
}
```

因为在上一章已经引入了 Redis 依赖包，并且已经配置好 Redis 服务器地址，所以系统就会自动注入实例。使用起来很方便。

> 有点类似于MongoDB的所有操作都是执行`MongoTemplate`提供的方法。

##### 2. 用户模型实现序列化接口

要实现把用户数据缓存在 Redis 里的功能，用户模型必须实现序列化接口。

```java
import java.io.Serializable;

public class UserDO implements Serializable {

}
```

用户模型实例在网络上传输，必须能够序列化。对象序列化必须实现`Serializable`接口。这是 Java 的规范和机制。



Java 系统提供的 `Serializable`接口中没有定义任何方法，相当于一个空接口：

![d4-2-3-1](/Users/dongyanzu/Desktop/d4-2-3-1.png)

那么类实现了`Serializable`接口，不必再多些方法实现代码，意义主要是 **标识** 此对象能够被序列化。

##### 3. 优化重名判断逻辑

修改UserServiceImpl.register()代码，优先从Redis查询此用户名有没有对应的用户对象，如果没有再从数据库查询一次。



这样遇到大量重复注册攻击的时候，可以有效减轻数据库的压力。

```java
UserDO userDO = (UserDO)redisTemplate.opsForValue().get(userName);

if (userDO == null) {
    userDO = userDAO.findByUserName(userName);
}

if (userDO!=null){
    result.setCode("602");
    result.setMessage("用户名已经存在");
    return result;
}
```

要读写缓存 Value , 就要调用`redistemplate.opsForValue()`，然后再调用`get()`方法根据参数Key取得缓存值。这里以用户名作为缓存 Key

`redisTemplate.opsForValue()`相当于固定用法了，后面会学习更多操作Value的方法。

> 记得 Redis 使用一个 Key - Value （简称 K-V）系统。

##### 4. 用户实例放入缓存

UserServiceImpl.register()方法结尾，调用DAO方法向数据库增加一条数据后，把新用户实例存入Redis：

```java
userDAO.add(userDO1);

result.setSuccess(true);
User user = userDO1.toModel();
result.setData(user);

// 新用户注册成功后，存入缓存
redisTemplate.opsForValue().set(userName, userDO1);
```

向Redis存数据，同样需要调用`redisTemplate.opsForValue()`，再调用`set()`方法：

- 第一个参数是 Key
- 第二个参数是 Value

本示例以用户名作为缓存Key，以用户实例作为Value

> 存数据的Key和Value，对前面读数据的Key和Value是要对应起来的。不能以用户名作为Key存数据，却以昵称作为Key读数据。

由于新用户注册成功以后，对象存入缓存，那么重复注册时，就不会读数据库了，只会从缓存查询一次数据。



我们已经会读写缓存了，其它操作也比较简单：

##### 修改缓存

基于 Key - Value 的 Redis 无法修改 Value 对象的某一个属性值，所以修改就是重新存入值：

```java
redisTemplate.opsForValue().set(userName , userDO);
```

新值会覆盖旧值

##### 删除缓存

删除缓存其实是按照 Key 删除数据：

```java
redisTemplate.delete(userName);
```

注意不同点：

删除操作不再是删除Value，而是通过删除Key来删除整条 K-V 数据，所以没有调用`opsForValue()`方法，直接调用`delete()`方法。



##### 任务

`UserController`中也有调用DAO进行数据操作：

- `getAll()`分页查询方法，暂时无法使用Redis进行分页查询，暂时不优化。
- `save()`可以优化，在保存数据库后，再存入Redis
- `batchAdd()`暂时没有批量存入Redis的方法，可以在`for`循环中依次存入
- `update()`重新存入Redis即可
- `delete()`代码会稍微复杂一点，要先查出来用户对象实例，才能获取到用户名，再调用缓存删除的方法
- `findByUserName()`就比较简单了，先根据用户名参数查询缓存，查不到再查数据库
- `search()`无法进行条件查询，暂时不优化
- `findByIds`Redis中以用户名作为Key，跟此方法的条件不匹配，暂时不优化。

把可以优化的方法，都引入Redis实现



#### 2.4 用户 Session

前面的Spring课程中，我们已经做过了Session，不过当时Session是存储在本地的。也就是Spring项目启动后的内存中，项目重启后，Session数据就没有了。



现在我们来学习如何引入Redis，作为Session数据的缓存，以解决分布式系统的共享Session问题。



##### 1. 引入依赖

修改pom文件，先删除旧的依赖项：

```xml
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session-core</artifactId>
</dependency>
```

然后添加相关的依赖：

```xml
<!-- spring session 支持 -->
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session-data-redis</artifactId>
</dependency>
<dependency>
  <groupId>org.redisson</groupId>
  <artifactId>redisson-spring-boot-starter</artifactId>
  <version>3.13.0</version>
</dependency>
```

-  `spring-session-data-redis`是核心依赖库，会自动完成Session同步到Redis等操作
- `redisson-spring-boot-starter`是需要用到的Redis客户端，提供很多分布式相关操作服务，操作Session数据的过程中，与核心依赖库搭配使用。

> 上一节引入的`spring-boot-starter-data-redis`仍然需要保留

##### 2.修改Session配置类

先回顾一下在《Spring Web 全栈》课程中学习的如何使用Spring封装实现的Session：

```java
@Configuration
@EnableSpringHttpSession
public class SpringHttpSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        ... ...
        ... ...
    }

    @Bean
    public MapSessionRepository sessionRepository() {
        return new MapSessionRepository(new ConcurrentHashMap<>());
    }
}
```

核心是使用了`@EnableSpringHttpSession`注解



##### 数据仓库

系统未提供默认的存储Session数据的仓库，所以需要在`sessionRepository()`方法中`new`一个仓库对象（Session存储于本地服务器），数据存储与线程安全的、支持高效并发的`ConcurrentHashMap`。

> ConcurrentHashMap是java.util.concurrent包的重要成员，有兴趣可以找资料研究一下

注意，此方法上加了`@Bean`，方法也当作Spring组件。



##### 定制 Session Cookie

`cookieSerializer()`的作用是定制Cookie中的Session信息内容如何写，这里就不细讲了，不是本节的重点。

##### 两个修改步骤

我们要使用Redis存储Session的方案，核心就是删除`@EnableSpringHttpSession`注解，改为使用`@EnableRedisHttpSession`注解。



然后，删除`sessionRepository()`方法，不再需要创建仓库了，Redis就是仓库，系统已经封装好了。

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.session.web.http.CookieSerializer;
import org.springframework.session.web.http.DefaultCookieSerializer;

@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 300)
public class SpringHttpSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        ... ...
        ... ...
    }
}
```

> `cookieSerializer()`保持不变，仍然可以定制Cookie中的Session信息内容如何写。

在使用`@EnableRedisHttpSession`时，可以通过`maxInactiveIntervalInseconds`注解参数设置Session数据的过期失效时间，单位是秒。本示例仅为学习阶段的演示，设置短一些时间。



如果不设置，系统默认是过期时间是1800秒（30秒）。

> 由于Redis空间有限，所以必须根据实际情况设置一个相对合理的过期时间，既要提升Redis利用率，又要防止空间撑爆。

#### 2.5 缓存穿透

小明负责的用户注册模块已经用Redis优化了，但是发现数据库仍然偶尔宕机，多发于晚间。



经过与运维等部门的协同排查，发现这是恶意攻击行为。有人用了工具软件，大量、密集、持续发登录请求，但都是输入错误的、不存在的账号。

> 我们在网络编程课程中学习的爬虫，其实就是一种工具软件，大家不要大量、密集、持续的运行爬虫程序。

因为都是错误或不存在的账号，所以Redis里不会存入缓存数据。于是，程序实际上还是会每次都查询数据库，导致数据库压力仍然持续过大。读写速度越来越慢，甚至宕机。这属于 系统漏洞。

![d4-2-5-1](/Users/dongyanzu/Desktop/d4-2-5-1.png)

系统看起来使用了Redis，但实际上这种被错误数据攻击的情况下，Redis失去了缓存的意义，称之为 缓存穿透。



主要原因 是 只考虑到了数据正确时的情况，没有考虑到错误数据带来的风险。



##### 解决漏洞



第一次从数据库查询不到数据时，仍然把这个空结果进行缓存。不过，要设置过期时间，注意过期时间不要太长，推荐不超过五分钟。

> 数据库查询结果为空，可能有两种情况：数据真的不存在，或者数据库本身的确有故障，但是这里先不管，所以过期时间不宜太长。

```java
import java.util.concurrent.TimeUnit;
```

```java
// 只 new 实例但不设置任何属性，相当于一个空对象
userDO = new UserDO();
redisTemplate.opsForValue().set(userName, userDO, 5, TimeUnit.MINUTES);
```

当用户第二次访问的时候，无论账户是否正确，Redis中都缓存了数据，避免再次查询数据库了。而缓存中的错误账号数据，由于没有属性值，则验证失败，实际不会执行登录。



##### 攻击的后继处理



当然，解决 缓存穿透 问题并不意味着彻底解决攻击，持续攻击也有可能造成Redis撑满。



遇到攻击，还是要多部门配合，比如运维、安全等团队一起排查，迅速找到攻击源头，从网络设备等层面阻止、切断攻击才能彻底解决。而解决 缓存穿透 问题只是在一段时间内尽量保证数据库不宕机，减轻损失。



##### Redis 小结

本章学习的操作

```java
redisTemplate.opsForValue().get();
```

和



```java
redisTemplate.opsForValue().set();
```

对Redis来说，都是操作String 类型的数据。也是最常用的数据。

##### 任务：

参考数据处理及校验的流程图：

![d4-2-5-2](/Users/dongyanzu/Desktop/d4-2-5-2.png)

解决登录服务的缓存穿透隐患。



#### 2.6 乱码问题

大家学完前面几节课，并且做完习题后，也许会想怎么样才能查看Redis里存储的数据？

##### 可视化软件推荐

这就需要用到可视化客户端工具，这样的工具很多, [redis可视化和客户端](https://www.redis.com.cn/clients.html) （包括使用与Windows和Mac），自己找一款软件下载，然后自己用用就可以了，实在不行就自己找教程。几乎都是要设置好Redis的IP、端口号、密码等信息，大同小异。

>软件的使用就不细讲了，需要大家自学

##### 问题

用这些软件查看Redis中的数据，会发现时一堆乱码：



##### 原因

前面讲过，Redis是独立软件，并不是Java语言开发的，所以Java程序存入Redis数据时，会把数据序列化。



而Java默认的序列化方式，是把内容编成字节码，计算机能识别，人就识别不了，所以看起来像乱麻。



##### 解决办法

大家项目里，需要添加一个config类（自己任意取名字）

> 大家仔细想想config类怎么写

类中注入`RedisTemplate`实例：

```java
@Autowired
private RedisTemplate redisTemplate;
```

然后通过方法重置序列化方法（reset serializer）

```java
@Bean
public RedisTemplate redisTemplateInit() {
  //设置序列化Key的工具
  redisTemplate.setKeySerializer(new StringRedisSerializer());
  //设置序列化Value的工具
  redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
  // 设置 hash 的 key
  redisTemplate.setHashKeySerializer(new GenericJackson2JsonRedisSerializer());
  // 设置 hash 的 value
  redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
  redisTemplate.afterPropertiesSet();
  return redisTemplate;
}
```

Redis 数据的 **Key** 用字符串（`StringRedisSerializer`)的序列化/反序列化方式，**Value**用JSON（`GenerucJackson2JsonRedisSerializer`）的序列化/反序列化方式。

第一章讲过，hash是一种Redis的数据类型，`setHashKeySerializer()`和`setHashValueSerializer()`就是支持hash的，目前不懂不要紧，暂时不用纠结，后面的章节会降到这种数据类型的。



再次存入新数据后，用可视化软件看，就不是乱码了。



注意：添加了config类后，Redis以前存入的旧数据是不兼容的，所以旧数据干脆废弃掉，换成新的Key。

> 但Session数据仍然是乱码，就不用管了，Session是系统自动处理的，不要认为干预。

### <3> 实战商品类目系统

#### 3.1 什么是类目

淘宝用户通过点击淘宝的商品分类栏浏览商品的过程。这些分类栏中展示的内容，通常叫做类目。通过类目浏览商品，是电商平台中用户的常规操作之一。所以，电商平台通常都会包括类目系统。



大家可以仔细看一下其它的电商平台，了解一下类目系统。



可以发现，类目的显著特点是，有着明确的层级关系，范围从大到小，从粗到细，越来越精确。



#### 3.2 类目设计

那么在Java中我们该如何实现类目系统呢？

实际上前面学过的所有课程，一致都在教两个核心步骤：

1. 模型设计
2. 服务设计

另外，有两个常见的延伸步骤：

1. 技术选型。包括各种相关技术选择。常见的是框架选型和存储方案选型。

- 框架选型：基本不用选了就是Spring Boot。
- 存储方案选型：从Mongodb 和 MySQL 选择其一，再研究是否需要搭配Redis缓存。

> 每个企业的特点不一样：有的企业会自己研发框架，几乎不用选型；有的企业比较复杂，要根据具体项目做选型

2. 完成 web 层，包括完成control 和 页面。

> 企业中的项目如果是前后端分离，那么完成API

实际上，前面一直按这些步骤完成项目，大家在练习过程中需要及时总结归纳。



##### 模型设计

模型设计方法，主要源自于充分理解具体的需求，而对业务需求深刻理解、具备扎实的技术功底，是优秀设计的两大要素。



当前的学习阶段，主要任务是，理解每个课程每章每节的模型，并且总结，思考和吸收。当遇到新模型需要设计时，主要的思路和方法就是寻找可以借鉴的模型，再加上自己对需求的理解，就可以完成设计了。当大家经验丰富以后，自然而然就能独立设计了。

> 模仿时快速、有效、重要的方法，前提是经过总结、思考，吸收知识，增长经验

在使用了电商网站的类目相关功能后，可以设计出一以下类目模型：

![d2-2-1](/Users/dongyanzu/Desktop/d2-2-1.svg)

实际上这个设计没那么复杂，id、gmt Created和gmtModified是通用的设计，名称和描述两个属性也是比较常见了。为了表示类目间的上下层级关系，设计了parentCategoryId 和 sub CategoryList 两个属性：

- 用subCategoryList表示 子类目 数据，其类型是List，因为可能存在多个 子类目；
- 为了查询方便我们在模型上也加了父类目id，这样只要根据一个类目id，即可以查询其所有 子类目 信息。

> 由于 父类目 已经包含了下属 子类目 ，所以为了不出现双向关联，只标识出 父类目 id就可以了，不能关联 父类目 模型。

##### 服务设计

从上面的操作视频来看，我们其实只需要实现添加类目、查询所有类目信息、查询单个类目功能就可满足于上面的需求。具体功能描述如下表所示：

|     功能名称     |                           功能描述                           |
| :--------------: | :----------------------------------------------------------: |
|     添加类目     |                    完成单个类目信息的录入                    |
|   查询单个类目   |     根据类目主键查询类目详细信息以及它所对应的子类目信息     |
| 查询所有类目信息 | 查询出所有的类目信息以及它的所有子类目信息（现在 子类目 层级约定为一层级） |

服务命名一般遵从规范：接口命名为 CategpryService，实现类命名为 CategoryServiceImpl。

#### 3.3 技术选型

像淘宝这些大型网站，平台上每天都可能有上亿人进行访问，这种极大的访问量，之前的接口它是否能承受住冲击呢？很可能就会出现下图所示的情况：

![d2-2-4-1](/Users/dongyanzu/Desktop/d2-2-4-1.svg)

##### 问题分析

如果按照普通的实现类目的方式，每访问一次类目就需要调用一次数据库。甚至，需要查询此类目下面的子类目信息，但是，子类目又包含很多下级子类目。



那么数据库压力实在太大了，相当于访问一次网站，就查询很多次数数据库。数据库压力是网站访问量的N倍。这就很有可能导致数据库宕机，用户体验感极差。

##### 技术选择

上面问题表明类目系统对性能要求颇高，而为们已经知道Redis在性能方面是具备优势的，所以在开发之前的设计阶段，就可以考虑引入Redis，作为类目数据的缓存，减轻数据库压力。



虽然类目具备上下级的关系，但是只是关联关系，就存储来说，每条类目都是一条独立的记录。多条类目组成一组类目数据。这个场景很适合Redis的数据结构：list，中文名称：列表。



#### 3.4 插入类目数据

在完成需求分析、模型设计和技术选型后，进入开发阶段。为们来进一步学习具体如何操作类目的缓存数据。



##### List概念

-> Redis List (列表) 是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

-> 一个列表最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）。

> 容量足够大，绝大部分场景都可以用。

##### 字符串

字符串是Redis的最基础的数据类型，Redis的数据Key就是字符串。



这就意味着，从结构上来说，不像Java一样，列表中还能嵌套列表。即使想把Java的List对象存入Redis，那实际上也是序列化字符串后存入。

##### 头元素和尾元素

![d4-3-4-1](/Users/dongyanzu/Desktop/d4-3-4-1.jpeg)

注意 Redis List 是有序的。

- 头元素指的是列表左端第一个元素。
- 尾元素指的是列表右端第一个元素。



例如：列表List包含三个元素 x，y，z 这时 x是头元素，而z则是尾元素。

> 规则就是左端是头，右端是尾。

##### 添加List 数据

从头部添加元素，使用`leftPush()`方法：

```java
// 第一个对象，演示代码省略 set 各属性值
Category category = new Category();
redisTemplate.opsForList().leftPush("categoryList", category);

// 第二个对象，演示代码省略 set 各属性值
category = new Category();
redisTemplate.opsForList().leftPush("categoryList", category);
```

从尾部添加元素，使用`rightPush()`方法：


```java
// 第一个对象，演示代码省略 set 各属性值
Category category = new Category();
redisTemplate.opsForList().rightPush("categoryList", category);

// 第二个对象，演示代码省略 set 各属性值
category = new Category();
redisTemplate.opsForList().rightPush("categoryList", category);
```

`leftPush()`和`rightPush()`方法第一个参数都是Key，第二个参数是数据对象。注意：整个列表都是Value，列表中的数据元素不能称为Value



Java系统会先把对象进行序列化，然后存入Redis。Redis会把相同Key的数据组知道一个数据结构List中。

> 提醒：Category类需要实现`java.io.Serializable`接口，标识为可序列化对象。

##### 探究规则：



**从头部添加的规则**

列表List包含三个元素x，y，z，如果使用`leftPush()`方法，应该按照怎样的顺序存入呢？

![d4-3-4-2](/Users/dongyanzu/Desktop/d4-3-4-2.jpeg)

答案是：先存入z，再存入y，最后存入x。也就是说，从头部添加元素时，原有的元素会被新元素往尾部挤。



**从尾部添加的顺序**

那么，如果使用`rightPush()`方法，应该按照怎样的顺序存入呢？

![d4-3-4-3](/Users/dongyanzu/Desktop/d4-3-4-3.jpeg)

答案是：先存入x，再存入y，最后存入z。也就是说，从尾部添加元素时，原有的元素会被新元素往头部挤。



##### 返回值

无论`leftPush()`还是`rightPush()`，其实都是有返回值的，返回值类型是`Long`.

返回的含义是，执行完数据添加操作以后，列表的长度。

前面的例子，由于重点关注添加的顺序的讲解，就没有关注返回值了。有需要可以定义变量得到列表长度。

```java
Long listLength = redisTemplate.opsForList().leftPush("categoryList", category);
```

#### 3.5 查询类目数据

上节课学习的插入顺序机制很重要，理解了插入顺序机制，才能对查询有比较好的理解，

##### 查询列表长度

```java
Long size = redisTemplate.opsForList().size("categoryList");
```

`sieze()`方法返回列表的数据量太小，参数是数据Key，返回值是Long类型的数字，前面的课程讲了，列表能容纳非常多的数据，所以Integer就不适用了。

##### 根据索引查询

```java
Category category = (Category)redisTemplate.opsForList().index("categoryList", index);
```

`index()`方法用于根据索引查询数据，第一个参数是数据Key，第二个参数是索引。



索引从头部开始计算，第一个元素的索引是0。



由于从左或从右插入数据时，元素的位置会发生变化，所以用索引查询数据的时候就需要特别小心，否则可能与预期不一致。

##### 范围查询

有时候不知道某个元素的具体位置，那么能不能遍历Redis列表，找出需要的元素呢？

```java
Long size = redisTemplate.opsForList().size("categoryList");
for (long i = 0; i < size; i++) {
    Category category = (Category)redisTemplate.opsForList().index("categoryList", i);
}
```

这当然是不行的，操作Redis属于远程操作，都要经过网络连接和传输，频繁的远程调用肯定是效率低下、不可取的。

> 学习阶段由于数据量少，可能感觉不出来。企业中大数据，大流量情况下就有明显的差别。

**Redis**提供了范围查询的语法，可以解决这个问题。

```java
List<Category> categoryDatas = redisTemplate.opsForList().range("categoryList", 0, 1);
```

**range()**方法用于根据索引查询一批数据：

- 第一个参数是数据Key
- 第二个参数是起始索引（包含）
- 第三个参数是结束索引（包含）

> - `range("categoryList", 0 , 0)`表示只查询第一条数据
> - `range("categoryList",0,1)`就表示查询第一和第二条数据了。

特别的，如果想查询整个列表的所有数据，第三个参数填-1:`range("categoryList",0,1)`。

> 参数用负数也是成立的：-1表示倒数第一个元素，-2表示倒数第二个元素。

由于Redis插入数据时会改变元素的索引，导致根据索引查询单个数据的方法并不常用。

#### 3.6 修改类目数据

修改Redis数据，就不像关系数据库那样，可以只修改几个字段。修改Redis列表数据库，就是把数据对象重新放入列表中。



##### 基本语法

````java
//演示代码省略set各属性值
Category category = new Category();
redis.Template.opsForList().set("categoryList",0,category)
````

调用`set`方法即可完成修改，必须根据索引重新放入数据，所以第二个参数是索引，第三个参数是新的对象。

> 第一个参数是Key，这是很多方法通用的。

##### 如何知道索引

最直观的，根据插入的顺序，可以推算出元素的索引。



但是，很多情况下，插入操作、查询操作、修改操作不是连续的，修改的时候很难知道插入的顺序，这时候可以用范围查询的方法，把数据都查出来。



由于Redis列表有序的，所以查询返回结果的 Java List 中的索引，就是实际存储中索引。

```java
// 查询所有的数据
List<Category> categoryDatas = redisTemplate.opsForList().range("categoryList", 0, -1);
long index = 0;
for (Category cat : categoryDatas) {
    if (StringUtils.equals(cat.getId(), "gcl_001")) {
        break;
    }
    index++;
}
```

查到索引后，就可以修改了。



##### 设置时间值：小知识点

对象存入Redis的时候会被序列化，但是时间类型的序列化，要额外处理。因为前面的作业中，时间值都是null，所以没有出现序列化的问题，如果设置了时间值，就会发现出错。

主要是由于在config类中配置的序列化工具类`GenericJackson2JsonRedisSerializer`不支持LocalDateTime，所以，在模型的时间属性上，需要加两个注解：

引入包：

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
```

书写注解

```java
public class Category implements Serializable {

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime gmtCreated;

}
```

`@JsonSerialize`注解用于指定 序列化 的工具类，推荐`LocalDateTimeSerializer`；

`@JsonDeserialize`注解用于指定 反序列化 的工具类，推荐`LocalDateTimeSerializer`；

> LocalDate 有对应的 LocalDate Serializer 和 LocalDateDeserializer ；LocalTime 有对应的LocalTimeSerializer和LocalTime Deserializer

`@JsonFormat`前面已经学过了，指定时间格式。



#### 3.7 删除类目数据

往Redis列表中插入数据时候，可以从头部和尾部插入数据，那么删除数据的时候，也可以从头部和尾部开始删除。

但是要注意的是，不能按照索引位置删除数据。

这也是一开始强调头部和尾部两个概念的原因，不是任意删除数据的。

##### 语法

从头部删除数据

```java
Category cat = (Category)redisTemplate.opsForList().leftPop("categoryList");
```

![img](https://style.youkeda.com/img/ham/course/d2/d4-3-7-1.jpeg?x-oss-process=image/resize,w_1600/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_ne,x_10,y_10)

从尾部删除数据：

```java
Category cat = (Category)redisTemplate.opsForList().rightPop("categoryList");
```

![img](https://style.youkeda.com/img/ham/course/d2/d4-3-7-2.jpeg?x-oss-process=image/resize,w_1600/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_ne,x_10,y_10)

> 永远只能删除第一个或最后一个数据，不能从中间位置删除

从字面意思理解，添加数据的方法`leftPush()`的push表示推入数据，那么`leftPop()`的pop表示拉出（或者说弹出）数据。

两个方法的返回值，都是当前从列表被删除的数据，如果程序不需要关注被删除的数据，代码也可以这样简单写:

```java
redisTemplate.opsForList().leftPop("categoryList");
```

 ### <4>实战-高并发商品抢购

#### 4.1 项目背景

大家在逛各种电商平台时，可能遇到过抢购某商品的场景：

![xiyiji](/Users/dongyanzu/Desktop/xiyiji.svg)

抢购跟普通购买其实很类似，都是产生订单，俗称下单。不同的是，抢购的商品库存时有限的，商品没那么多，卖完了就没有了。

大家是不是马上就可以想到，既然库存有限，又有很多人抢，这个场景肯定涉及到高并发的问题，重担就是防止 库存数量 错乱。

> 库存数量错乱导致的现象就是超卖，比如库存10，两人同一时刻都下单购买一件商品，不注意并发问题，就导致库存变为9，但产生两个顶单。

大家在《Java并发编程》中已经学习过了如何处理类似的问题，但那是基于单机的，在企业级分布式环境中，就不太适用了。

正好Redis具备解决问题的能力，本章来学习如何使用Redis解决分布式场景下的高并发问题。

#### 4.2 商品模型设计

经常上网购物的同学，基本上都可以设计出商品模型：

![product3](/Users/dongyanzu/Desktop/product3.svg)

> 有着自己的购物体验，设计这些模型应该不难。

实际工作中，商品模型肯定会复杂很多，本课程的学习阶段不需要那么复杂。

商品价格一般是带小数点的，所以类型用Double；库存数量用int就够了，企业中可能用long。



#### 4.3 项目初始化

##### 创建数据库

建议在自己购买的云服务器上安装MySQL数据库软件，并启动。

> 参考《MySQL》，使用docker启动即可

然后新建一个数据库，数据库名字可以自定义，以trade为例：

```SQL
CREATE DATABASE trade;
```

##### 创建商品表

根据模型，设计对应的表结构。除了图片，其它都是必填。

主键id 设置为 自增长的数字。

```sql
CREATE TABLE `product` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `gmt_created` DATETIME NOT NULL COMMENT '创建时间',
  `gmt_modified` DATETIME NOT NULL COMMENT '修改时间',
  `price` DOUBLE NOT NULL DEFAULT 0.00 COMMENT '商品参考价格',
  `name` VARCHAR(32) NOT NULL COMMENT '商品名称',
  `stock` INTEGER NOT NULL DEFAULT 0 COMMENT '库存',
  `url` VARCHAR(300) COMMENT '商品图片URL',
  PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

##### 默认商品数据

执行下列 SQL，插入一下初始化商品数据。

```sql
INSERT INTO product (price, `name`, stock, gmt_created, gmt_modified)
VALUES (1000.0, '洗衣机', 3, now(), now())
```

##### 4.5 Redis 事务

上节主要是为了验证抢购过程中产生的问题：最初“洗衣机”只有三台，但是抢购成功的请求会多于3个，而且数据库中的库存值可能变为负数。



原因就是高并发场景下，数据的读写没有做到控制，速度较快的线程的库存值修改被之前已经通过校验库存的步骤，而本线程修改数据库数量时，又不知道库存值已经被其它线程修改了，而且不是最新值减1的。

> 线程执行先后顺序和快慢，都是由操作系统、CPU自动决定的，开发者无法预测。

知道了原因，就可以考虑使用Redis事务来控制下单过程，防止超卖、库存数据错乱。

##### 什么是事务

事务（Transaction），是指将一个业务逻辑作为一个整体一起执行。事务其实就是打包一组操作（或者命令）作为一个整体，在事务处理时将顺序执行这些操作，并返回结果，如果其中任何一个环节出错，所有的操作将被取消。

Redis的事务可以保证只有在执行完事务的所有命令后，才会继续处理此客户端的其它命令。

也就是说，只有一个用户可以操作事务中的数据。

##### Redis 事务基本概念

redis事务四大指令：MULTI、EXEC、DISCARD、WATCH

- WATCH用于客户端并发情况下，为事务提供一个锁（CAS，Check And Set）可以用watch命令来监控一个或多个变量如果在执行事务之前，整个监控项被修改了，那么整个事务就会终止执行。
- MULTI开启一个事务；
- EXEC执行一个事务；
- DISCARD取消一个事务；

接下来学习事务代码的具体写法：

##### 事务基础框架代码

```java
try {
    redisTemplate.execute(new SessionCallback<List<Object>>() {
        @Override
        public List<Object> execute(RedisOperations operations) throws DataAccessException {

        }
    });
} catch (Exception e) {
    LOG.error("redisTemplate.execute() error. ", e);
}
```

`redisTemplate.execute();`是执行事务的方法，推荐 写在 try...catch异常抓取的语句中，这样执行过程中有任何问题，都打印出日志，方便排查问题。

这个写法基本上就是固定了都。具体的事务就写在方法参数`SessionCallback`接口的`execute()`方法体内部。

> `new SessionCallback(){}`这个写法就是匿名类，每个项目在execute()方法中实现具体的业务逻辑。

方法参数`RedisOperations`提供了前面讲过的四大指令操作。

##### 监听对象

在开启事务前，先选择一个要监听的对象，即Redis中的某个Key：

```java
redisTemplate.execute(new SessionCallback<List<Object>>() {
    @Override
    public List<Object> execute(RedisOperations operations) throws DataAccessException {
        //监听商品的ID
        operations.watch(id);
    }
});
```

> 为了演示简便，省略try...catch

`operations.watch()`方法传入待监视的Redis数据Key。

注意：这个Key必须在Redis中存在，否则会抛出异常。



##### Redis 事务三阶段

Redis 中的事务从开始到结束要经历3个阶段

![guocheng](/Users/dongyanzu/Desktop/guocheng.svg)

##### 1. 开启事务

```java
redisTemplate.execute(new SessionCallback<List<Object>>() {
    @Override
    public List<Object> execute(RedisOperations operations) throws DataAccessException {
        //监听商品的ID
        operations.watch(id);

        //开启事务
        operations.multi();
    }
});
```

`operations.multi()`开启事务时不需要参数。

> 仅演示Redis操作，非完整的代码

##### 2.命令入列

所谓命令入列，就是指读写Redis数据的业务逻辑。在开启事务后，就可以写具体业务逻辑的代码了。

```java
redisTemplate.execute(new SessionCallback<List<Object>>() {
    @Override
    public List<Object> execute(RedisOperations operations) throws DataAccessException {
        //监听商品的ID
        operations.watch(id);

        //开启事务
        operations.multi();

        // 插入一条订单数据。
        // 缓存库的存减 1
        operations.opsForValue().set(idKey, (stock - 1));
        // 数据库的库存减 1
        productDAO.reduceStock(id, 1);
    }
});
```

在`execute()`方法中，Redis的操作不再使用`redisTemplate.opsForValue()`，而是使用`operations.opsForValue()`，这样系统才知道时同一个事务中的操作。

##### 3.执行事务

在完成业务逻辑后，就可以执行事务了：

```java
redisTemplate.execute(new SessionCallback<List<Object>>() {
    @Override
    public List<Object> execute(RedisOperations operations) throws DataAccessException {
        //监听商品的ID
        operations.watch(id);

        //开启事务
        operations.multi();

        // 插入一条订单数据。
        // 缓存库的存减 1
        // 数据库的库存减 1

        // 执行事务
        List exec = operations.exec();
    }
});
```

> 仅演示Redis操作，非完整的代码。

`operations.exec()`用于执行事务，返回值时List列表，存放了每个事务执行结果的标记。事务开启后执行的每个操作，如果成功则放入true值作为标记，操作失败则不放入结果标记。

> 有几个操作就有几个结果标记，因为本演示案例，Redis只有设置库存的操作，所以只有一个标记。

因为事务是要么每个操作都成功，要么都失败，所以一般来说可以简单处理，不用判断operations.exec()方法返回值列表中的每个元素是否都为true，只要判断返回值列表长度大于0则比啊是执行成功。

##### 4.取消事务

在`execute(RedisOperations.operations)`方法抛异常时，会自动取消事务。本案例不必写取消事务的代码。



如果有的项目需求，需要手动取消事务的话，代码也非常简单，只需要用:

```java
operations.discard();
```

即可取消事务。

当然，取消事务和执行事务是互斥的，要注意 `exec()`和`discard()`代码的逻辑顺序。



#### 4.6 抢购事务的问题

上一节，在商品抢购过程中采用了Redis事务，以此把证Redis中的库存数据不会错乱，不会残生超卖。



但是程序运行以后，会发现有两个严重的问题：



1. 10个线程抢购模拟10人抢购，只有1人抢购成功，Redis的库存值为2；9人都抢购不成功。但是理想情况应该是3人抢购成功。
2. 数据中的库存值，与Redis中不一致。数据库的存储值很可能为负数。

##### 问题 1 的原因

事务不是独占的，10个线程由于速度够快，在同一时间都开启了事务进行抢购，事务中的操作都互不干扰。



Redis 中的库存初始值是 3，而各个线程最终只有一个可以成功的修改库存值为2.于是，其它线程在最后执行修改数据时，不是基于新值进行修改（或者笼统的说数据状态已经改变了），那么修改不成功。



##### 问题 2 的原因

Redis 的事务，只能影响Redis的操作

`execute(RedisOperations operations)`方法抛异常时，可以使所有 Redis 的操作取消，但影响不到数据库。因为他们是不同的软件。

##### 解决方案

看起来，事务并不能很好的解决抢购问题。为们可以考虑使用分布式锁。

> 并不是说Redis事务没用，而是事务更适合保证多条操作原子性的场景。



#### 4.7 分布式锁

##### 什么是分布式？

![servier](/Users/dongyanzu/Desktop/servier.svg)

分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统被称为“服务”



##### 什么是分布式锁

对于锁大家肯定不会陌生，在Java中`synchronized`关键字在我们的代码中是常见的，这些都是 本地锁，只能解决一台服务器并发问题。



但是随着业务量不断增大，单机系统不满足那么大的访问量，需要编程集群或者分布式结构，因此我们无法保证某个数据的改变是同一台服务器操作的。我们需要的是一个能锁所有服务器的锁，这就是本节所说的分布式锁。



##### Redis 客户端

要使用Redis分布式锁，就需要用到 **Reddissin**客户端，它提供的功能远远超出了一个Redis客户端的范畴，在可以使用基本的Redis功能的同时，也能使用它提供的一些高级服务：

- 远程调用
- 分布式锁
- 分布式对象、容器



##### 集成

那么如何在Spring Boot 中集合 Redisson 呢？首先需要在pom文件中引入下面的依赖：

```xml
<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.13.0</version>
    </dependency>
</dependencies>
```

> Spring-boot-starter-data-redis 仍然保留

别忘记 application.properties*中配置 Redis 的IP、端口、密码。

##### Redis 分布式锁实现

先注入 redisson Client实例：

```java
import org.redisson.api.RedissonClient;
```

```java
@Autowired
private RedissonClient redissonClient;
```

要实现Redis分布式锁其实大致需要散步：

##### 1. 取得锁

```java
RLock rLock = redissonClient.getLock("CUSTOM_NAME");
```

用 `redissonClient.getLock()` 得到一个 Redis 锁对象，方法参数是 *字符串* 类型的自定义锁名称，不一定要用数据 Key ，一般推荐用容易理解的、业务相关的名称。

> CUSTOM_NAME 只是代码举例哦

为了减少冲突、明确含义、易于理解和维护，不要以简单的数字 id 值作为 Redis 中的数据 Key，推荐的格式是：

```txt
productId-1-stock
```

这样就知道 Redis 缓存中这个 Key 的作用和含义。同样，锁的名称也不要太简单，推荐的格式是：

```txt
productId-1-lock
```

这样也比较明确、容易理解。

当然，这种命名格式并不是强制规定，只是经验之谈，大家可以按照自己的喜好指定格式。

##### 2. 上锁

```java
rLock.lock();
```

并发情况下，每个线程都会竞争锁：

- 竞争成功（获取锁）的线程会继续运行
- 竞争失败的线程会被禁用，并且重新获取锁之前，该线程将一直处于休眠状态。

简单说，抢不到锁的进程会持续等待，所以使用锁要特别小心。



##### 3. 解锁

```java
rLock.unlock();
```

有上锁就必须解锁，否则会导致线程持续等待而产生死锁，系统也就卡死了。

所以，推荐把业务操作放在 *try...catch...finally* 中：

```java
try {
  rLock.lock();
  // 抢购业务逻辑
} catch (Exception e) {
    LOG.error("some error. ", e);
} finally {
    rLock.unlock();
}
```

`finally{}` 代码块无论业务逻辑是否产生异常，一定会执行，这样保证正确与否都能解锁。

> `catch(){}`代码块在产生异常才执行，这是一场的基础知识了。

#### 4.8 过期处理

在很多时候服务器经常会用到Redis作为缓存，有很多数据都是临时缓存一下，可能用过之后很久都不会再用到了。

例如，短信验证码缓存在Redis中，每个用户在登录用完验证码就不会再用了。

但是这些数据放在Redis里就会一直占用存储空间，而Redis的存储空间是非常正规的，这就造成极大的浪费。

Redis可以定期清理这些没用的数据吗？答案是肯定的，可以自动清理数据。

##### 设置过期时间

例如，将验证码缓存到Redis里：

```java
redisTemplate.opsForValue().set("code", "78987");
```

但是想要在 1000 毫秒之后过期：

```java
redisTemplate.opsForValue().set("code","78987",1000,MILLSECONDS);
```

常见的时间单位包括：

- TimeUnit.MILLSECONDS ：毫秒
- TImeUnit.SECONDS ：秒
- TImeUnit.MINUTES ：分钟
- TImeUnit.HOURS ：小时
- TImeUnit.DAYS ：天

我们在第二章讲缓存穿透问题的时候，已经提到了设置过期时间。

##### 设置Redis List的过期时间

列表结构的操作方法：

```java
redisTemplate.opsForList().leftPush()
```

是无法设置过期时间的，这时可以用：

```java
redisTemplate.expire("category", 60, TimeUnit.MINUTES);
```

设置过期时间，第一个参数是数据 Key，第二个和第三个参数组合确定具体的时间。

其实 `redisTemplate.expire()`是一个通用方法，可以为任何数据类型设置过期时间。

##### 删除策略

还有一个问题，如果一个键已经过期了，那么他什么时候会被清理掉呢，不然会占用存储空间。



Redis 服务器清理过期数据有多种策略：

##### 1. 惰性删除

每次查询或写键时，都会检查取得的键是否过期。如果过期就删除该键，否则就返回该键。

这样做对CPU最友好。只有在操作的时候进行过期检查，删除的目标仅限于当前需要处理的键，不会在删除其它无关本次操作的过期键上花费任何CPU时间。

但是对内存不友好，键过期了，但因为一致没有被访问到，所以一直占着存储空间。

##### 2.定期删除

每隔一段时间，程序就对数据库进行检查，删除里面的过期键。至于要删除多少过期键，以及检查多少数据库，则由算法决定。

##### 3. 定期删除

在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

这样的做法对于内存时最好的，可以及时释放存储空间，但是对于cpu却不好，在过期键比较多的情况下，删除过期键会占用相当一部分CPU时间。

这样对服务期的性能会有影响

> 在企业中，采用什么样的策略，需要经验丰富的架构师确定。

#### 4.9 分布式ID

##### 分布式ID背景

ID 是数据的唯一标识，常见的做法是用数据库的AUTO_INCREMENT(主键自增)机制，自动生成ID。



##### 解决的问题

随着业务的发展，数据量会越开越大，一张表、一个库可能无法容纳太多数据的时候，就需要对数据进行分表，甚至分库。分表后每个表的数据会按自己的节奏来自增，这样会造成ID冲突，这时就需要一个单独的机制来负责生成唯一ID。

> 分表、分库的目的都是让每张表不过大，数据能够均衡分布，提升读写效率。

##### 应用场景

下图中是一次交易的交易号：

![order](/Users/dongyanzu/Desktop/order.png)

通过上图为们可以看出交易号的生成和时间有关系，订单号前八位是订单产生的日期，后面几位是订单序号。

这样的ID带有日期特征，很容易

> 其它例如身份证号、商品批号、都跟日期有关。

##### 订单号

线上购买产品都会生成一个订单号，现在我们根据当天时间及订单生成的序号来生成一个唯一的ID（如ID为"202006011"前八位是2020年6月1号生成的，后面的序号表示是第一个订单）。

Redis有个特点是，所有命令操作都是单线程的，不像Java这么复杂由多线程的概念。虽然是单线程，但是速度够快。基于这个特点，Redis提供了自增原子命令，能保证生成ID是唯一有序的。

下面实例演示Redis如何生成分布式ID。

引入关键类：

```java
import org.redisson.api.RAtomicLong;
import org.redisson.api.RedissonClient;
```

过程代码：

```java
//格式化格式为年月日
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
//获取当前时间
String now = LocalDate.now().format(dateTimeFormatter);
//通过redis的自增获取序号
RAtomicLong atomicLong = redissonClient.getAtomicLong(now);
atomicLong.expire(1, TimeUnit.DAYS);
long number = atomicLong.incrementAndGet();
//拼装订单号
String orderId = now + "" + number;
```

第一章就讲过了，Redis是一个Key-Value存储结构，那么通过Redis获取一个自增ID，也需要一个Key。

实例代码中，格式化当前日期的作用也是如此，用yyyyMMdd格式的日期作为Key，获取自增ID值。

> 当然，这时因为本案例的业务特点，订单号跟日期有关决定的，其它场景下可以根据需要自定义Key。

先获取一个自增的实例对象：

```java
RAtomicLong atomicLong = redissonClient.getAtomicLong(now);
```

再取得实际自增值：

```java
long number = atomicLong.incrementAndGet();
```

方法返回值类型是长整型数字 `long`

> 第一次调用，返回值是1。incrementAndget()每调用一次则加1

这个方法名在《Java并发编程》中讲过的通过Java系统取得原子自增值的方法名也是incrementAndGet()

这个跟日期相关的业务场景，设置为1天过期是比较合理的，第二天重新从1开始。

> 其它业务场景，根据实际情况考虑过期时间。

### <5> 实战玩家排行榜

#### 5.1 吃鸡游戏背景

![ranks](/Users/dongyanzu/Desktop/ranks.jpg)

本章将一步一步完成排行榜的开发

> 没玩过吃鸡游戏也不要紧，仔细观察图片，尝试了解图中的内容。

##### 用户积分

我们首次进入游戏时，当然会注册用户。注册、登录模块在前面已经做过多次了，已经比较熟悉了。

当注册完，点开个人资料，会看到下面画面：

![initpic](/Users/dongyanzu/Desktop/initpic.png)

吃鸡游戏的特点是，没有打游戏就已经有初始的积分了，因此在用户注册时，系统需要初始化个人战绩信息，设置好默认战绩数据。

> 本章简单处理，不考虑单排、双拼、四排、以及人称不同的积分，统统视为同一种积分。

#### 5.2 战绩模型设计

从上节我们可以看到，个人战绩是对战的统计数据，根据页面上看到数据，可以归纳出下列模型：

![PersonalRecord](/Users/dongyanzu/Desktop/PersonalRecord.svg)

> 大多数属性都来自具体的需求

“淘汰/被淘汰”除法不一定能除尽，所以设计成double

个人战绩模型，既关联了User对象，又关联了userId，是有些冗余的，但还可以接受。比如：在展示战绩的页面，需要关联User实例；但在修改积分需要用到模型时，User实例可以为null，实际不需要User实例，只需要设置好userId即可。 

> 模型可以使用多种读写场景，所以可以有一些冗余的属性
>
> > 冗余属性的设计，主要根据经验和习惯，并没有强制规定。

##### 属性变量的类型

在以前的设计中，数字型的属性，其类型往往被设计成小写的int、long、double，但是这里用了大些的Integer、Long、Double其实是等价的，也没有特别的原因，主要是根据习惯进行选择。

> 不同的公司，习惯可能不同。

只有一点要特别注意，Integer、Long、Double类型的属性都是对象，值可以为null，而int、long、double是基本类型，值不会为null，Java系统会自动把基本类型的值设置成0.所以使用大写的包装类，就要小心是否因为null引起空指针异常（NullPointer Exception）

> int是基本类型不是对象，Integer是与之对等的对象，都表示整数。这时Java基础知识。

#### 5.3 对局模型设计

个人战绩是从哪来的呢？那当然是根据每局比赛的结果进行统计而来。

当游戏结束时会有下面的结算页面（对局只考虑自己的战绩，不需要关心队友数据）

![MatchData](/Users/dongyanzu/Desktop/MatchData.svg)

结算画面中，是否胜利。名次、淘汰数都显示了出来。

所以，每局比赛结果相当于明细，个人战绩是统计汇总数据。

根据图中的各项数据，可以归纳出下列模型：

![matchfield](/Users/dongyanzu/Desktop/matchfield.svg)

#### 5.4 缓存个人战绩

本节的初始化代码中，在原来注册/登录系统基础上，增加了个人战绩的模型和服务，但并不完整，需要完善代码。

![PersonalRecordService](/Users/dongyanzu/Desktop/PersonalRecordService.svg)

##### 任务

主要有两个目标：

1. 完成个人战绩数据缓存

> 暂时不考虑使用数据库，重点是Redis

2. 解决乱码问题

##### 任务一：检查个人战绩模型

检查`PersonalRecord`的代码，看看有没有需要完善的办法

##### 任务二：个人战绩服务

实战`PersonalRecordServiceImpl`：

`save()`方法的功能是：保存个人战绩实例至Redis中，缓存在以`integralRank`为Key的Zset结构中，以个人战绩积分作为排序分数。

`initDefaultData()`方法的功能是：根据参数userId创建个人战绩实例，设置默认积分1200，其余属性值0，缓存在Redis。

##### 任务三：注册时设置默认战绩

前面讲过，每位用户都有默认战绩，那么可以在用户注册成功后，生成个人战绩数据记录。

修改`UserAPI`的`reg()`方法，注册成功后，调用`PersonalRecord`接口的`initDefaultData()`缓存默认个人战绩。

##### 任务四：初始化数据

系统提供了`PersonalRecordControl`用于在系统启动的时候初始化一批数据，会调用`PersonalRecordService.save()`存入缓存。

> 初始化数据知识为了后面的自测查询功能使用

`@PostConstruct`注解可以让`init()`方法在完成依赖注入后自动运行，从而自动执行初始化数据的任务。但是，此前提是`RedisTemplateConfig`先运行，否则系统以默认JDK的序列化方式存储数据，导致使用软件查询Redis数据时，会看到乱码。

> 对于Redis不存在乱码，知识影响人阅读数据。

因为`PersonalRecordControl`与`RedisTemplateConfig`没有直接关联，所以`init()`方法运行时，`RedisTemplateConfig`并不一定已经运行完毕。

为了解决这个问题，可以让`PersonalRecordControl`依赖`RedisTemplateConfig`；并且`RedisTemplateConfig`中也增加一个`init()`方法，以重置序列化方式。

这样从系统层面保证不同Bean的初始化顺序。

思考这块内容，修改 **PersonalRecordControl**类，解决乱码问题。



#### 5.5 查询个人战绩排行榜

存储的数据的重要作用就是为了展示，所以Zset也会提供查询功能。

##### 主要提供两种查询方式：

1. 根据排序值（score）升序查询

```Java
//0和-1代表查询该键的所有值默认是按升序排序
Set tv = redisTemplate.opsForZSet().rangeWithScores("TV", 0, -1)
```

2. 根据排序值（score）降序查询

```java
//reverseRangeWithScores是根据score降序排序
Set tv = redisTemplate.opsForZSet().reverseRangeWithScores("TV", 0, -1);
```

升序与降序查询的方法名不同，`rangeWithScores()`是升序查询，`reverseRangeWithScores()`是降序查询。参数和返回值的用法都是一样的。

- 第一个参数是Key

> 通用的

- 第二个参数是起始索引（包含），从0开始计
- 第三个参数是结束索引（包含）

> 特别的，第三个参数值-1查询所有的数据记录。比较常用。

实际上两个方法都是取得某个范围的数据：start<=index<=end

如果想取得前2条数据：

前两条数据的起始索引是0，那么结束索引是（2-1），即查询索引为0、1的两条数据，对于不习惯从0开始计数的同学来说，下列写法可能更容易理解一些：

```java
//0代表数据的第0条数据，2-1代表查询至索引为 1 的数据，即 2 条数据
redisTemplate.opsForZSet().rangeWithScores("TV", 0, 2-1);
```

##### 返回值Set

Set是Java中使用频率一般的集合，不如List，Map用的多，其特点是不允许出现重复元素，不强调顺序。所以，即使是null，也只能存放一个，不能存放多个null元素。

跟List一样，Set也是接口，都继承于`Collection`接口。

最常用的实现类是HashSet，是无序的。所以，很多资料上直接说Set是无序的。

> 有兴趣的同学可以自学。网上资料很多，推荐[Java中的Set总结](https://www.jianshu.com/p/d6cff3517688)

而本节讲的查询是有序的，所以返回值类型实际上不是HashSet，而是LinkedHashSet，是有序的。

Java强调的是“面向接口编程”的思想，那么：对于程序代码来说，返回值不用管具体实现类，而是Set接口；对于程序员来说，需要知道返回值是有序的。

> 可以自己研究原理和数据结构，网上资料很多，推荐[Java集合Set之LinkedHashSet详解](https://blog.csdn.net/zhaojie181711/article/details/80510129/)

##### 遍历返回值Set集合

引入新包：

```java
import org.springframework.data.redis.core.ZSetOperations.TypedTuple;
import java.util.Set;
```

查询及遍历：

```java
Set<TypedTuple<PersonalRecord>> datas = redisTemplate.opsForZSet().rangeWithScores("integralRank", 0, -1);

// 遍历
datas.forEach(data -> {
    // 存入的对象
    PersonalRecord pr = data.getValue();
    // 对应的分数
    Double score = data.getScore();
    System.out.println(pr.getId() + " - " + score);
});
```

查询返回Set集合的元素类型是`TypedTuple`，用于整合查询结果对象（通过`add()`方法放入ZSet对象）及其对应的分数，封装在一起，便于读取。

> TypedTuple 是 ZSetOperations接口中定义的内部接口

于是，通过`getValue()`可以取得放入`ZSet`的元素对象，通过`getScore()`可以取得元素的分数。

#### 5.6 缓存排行榜的用户数据

在前面小节中，用户数据缓存在Redis中，是跟其它作用域的数据混合在一起存放的，着就意味着可能引起冲突。

俗话说“不怕一万，就怕万一”。

用户缓存是以“用户名”作为Key的，万一有用户以“integraRank”作为用户名，那么就跟个人战绩的数据集合冲突了。

可以用Redis的Hash数据结构解决这个问题。

##### 什么是Hash

Redis Hash 是一个字符串类型的field（字段）和value（值）的映射表，Hash特别适合用于存储对象。

![hash](/Users/dongyanzu/Desktop/hash.jpeg)

简单的说，Redis的整个Value就是键值对映射结构，通过Key和field取得所需的值。

> 可以简单理解为，Redis的Key-Value键值对模式不变，但value也是一个键值对。

##### 新增和修改

把所有的用户数据都存储在“IntegralRankUser”为Key的缓存中，以用户名作为field，那么无论用户名是什么，都不会跟其它领域的数据冲突了。

`redisTemplate.opsForHash().put("integralRankUser",userDO.getName(),userDO);`

`put()`方法第一个参数是Key；第二个参数是field；第三个参数就是具体的值了。

> 相当于把Redis缓存数据做个归类。

##### 修改

可以根据Key和field精确查询：

```java
UserDO userDO = (UserDO)redisTemplate.opsForHash().get("integralRankUser",userName)
```

也可以根据Key和一批field批量查询

````java
List<String> userNames = new ArrayList<>();
userNames.add(userName);
List<UserDO> users = redisTemplate.opsForHash().multiGet("integralRankUser", userNames);
````

##### 删除

根据Key和field进行删除：

```java
redisTemplate.opsForHash().delete("integralRankUser", userName);
```

由于 `delete()`方法支持变长参数，所以想删除多个field时，只需要传入多个field即可：

```java
redisTemplate.opsForHash().delete("integralRankUser", userName, "zhangsan", "lisi");
```

##### 小知识点：变长参数

从 Java5 开始支持变长参数机制，允许在调用方法时传入不确定数量的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现。

> 语法糖是计算机编程领域场景的术语，表示其实并没有提供全新的功能机制，实现功能与原功能一致，但让代码书写简单、简洁流畅、通俗易懂

Redis 中定义`delete()`方法的源码时：

```java
Long delete(H key, Object... hashKeys)
```

在方法的参数类型后面加三个点（`...`）就表示变长参数，调用时可以传入一个或多个值，而变量`hashKeys`的类型实际上就是数组，可以用`hashKeys.length`获取输入参数的个数。



#### 5.7 Set 

前面的章节已经讲过了比较常用的ZSet、List、Hash、String这几种数据类型，还有一种不常用的Set。

##### Set 特点

注意，这里所说的Set，是Redis的数据类型，不要跟前面章节讲过的Java集合混淆了。（虽然他们都是同一个英文单词，也有一些相同特性）

ZSet 用中文描述是“无序集合”，其特点是：

1. 集合中的元素是无序的
2. 集合中的元素不能重复，是唯一的。

![set](/Users/dongyanzu/Desktop/set.png)

与ZSet相比，由于缺少了 分数，所以无法排序。

##### 新增数据操作

可以调用`add()`方法批量增加数据。

```java
redisTemplate.opsForSet().add("ranks", personalRecord1, personalRecord2);
```

既然是操作 Set，那么方法自然是`opsForSet()`，注意规律，每种数据类型都有自己的操作方法。

##### 删除数据操作

使用`remove()`方法删除一个数据元素。

```java
redisTemplate.opsForSet().remove("ranks", personalRecord);
```

`remove()`方法第一个参数是Key；第二个参数是待删除的数据对象，删除与添加是对应的，添加的是自定义对象，删除的时候也要传入相同的自定义对象。

> 千万不要理解为，添加的是personalRecord实例对象，然后用personalRecordId删除，不能跟MySQL混淆，

##### 修改数据操作

不存在修改这个说法，或者说，修改等同于：先删除旧数据，再键入新数据。

##### 基本查询

查询方法不是常见的getXX而是`members()`：

```java
Set<PersonalRecord> datas = redisTemplate.opsForSet().members("ranks");
```

通过 Key 查询集合中的所有数据元素。返回值的泛型，就是新增数据的类型，往 Set 缓存里放了什么数据，拿出来就是什么数据。

##### 多集合操作

使用 Set 一般来说并不是用于数据对象的缓存，因为无序，实际上操作很不方便，不能像列表一样精确查询。

使用 Set 多用于集合间的操作。所以，推荐 Set 存储简单的数据，比如 Java 的字符串或数字，而不要在 Set 中存入复杂的 Java 自定义对象。

比如只存入个人战绩的 id 值而不是整个对象。

多集合的操作主要有：

##### 求并集

给定两个集合A，B，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集。大家应该学习过并集的概念。

`union()`方法用于求多个集合的并集：

```java
List<String> keys = new ArrayList<>();
keys.add("ranks1");
keys.add("ranks2");
keys.add("ranks3");
Set<Long> unionDatas = redisTemplate.opsForSet().union(keys);
```

##### 求交集

集合论中，设A，B是两个集合，由所有属于集合A且属于集合B的元素所组成的集合，叫做集合A与集合B的交集

`intersect()`方法用于求多个集合的交集：

```java
List<String> keys = new ArrayList<>();
keys.add("ranks1");
keys.add("ranks2");
keys.add("ranks3");
Set<Long> interDatas = redisTemplate.opsForSet().intersect(keys);
```

`intersect)`方法返回给定所有给定集合的交集。

不存在的集合key被视为空集，当给定集合当中有一个空集时，结果也为空间（根据集合运算定律）。

##### 求差集

设A，B是两个集合，以属于A而不属于B的元素为元素的集合成为A与B的差集

`difference()`方法用于求一个集合与其它集合的差集：

```java
List<String> otherkeys = new ArrayList<>();
otherkeys.add("ranks2");
otherkeys.add("ranks3");
Set<Long> diffDatas = redisTemplate.opsForSet().difference("ranks1", otherkeys);
```

`difference()`方法返回第一个集合与其它集合之间的差异，也可以认为说第一个集合中独有的元素。不存在的集合key将视为空集。

> Set不常用，可以自己写程序实验一下。

### <6> 常见面试题

#### 6.1 Redis为什么这么快

##### 几点原因

1. 完全基于内存，绝大部份请求是存粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O（1）；
2. 数据结构简单，对数据操作也简单，Redis中单数据结构是专门进行设计的；

- String
- List
- ZSet
- Hash
- Set

3. 采用单线程，有点包括：避免了不必要的上下文切换和竞争条件，也不存在 多线程切换 消耗CPU资源；不用去考虑各种 锁 的问题，不存在加锁释放锁的操作，因为可能出现死锁而导致的性能消耗：
4. 使用多路I/O复用模型，非阻塞IO：

> 问题：
>
> > 一个服务器进程和一个客户端进行通信，服务端需要阻塞以等待客户端发送数据，那么多个客户与服务器通信时，其它客户端就要持续阻塞（排队）等待处理，并发场景时效率低。

> 解决：
>
> > 由多个客户端连接时，监听每个连接，当其中有一个发来消息时就从阻塞中返回，然后就读取收到的消息，然后又循环回阻塞；这样就不会因为阻塞在其中一个上而不能处理另一个客户的消息。

![mux](/Users/dongyanzu/Desktop/mux.jpeg)

需要明确的时：I/O多路复用是操作系统支持的，不是Redis独立的功能。

5. 使用底层模型不同，他们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

##### 推荐资料

网上资料有很多，推荐两篇：

1. [为什么说Redis是单线程的以及Redis为什么这么快！](https://blog.csdn.net/xlgen157387/article/details/79470556)

2. [各种概念及IO多路复用](https://blog.csdn.net/qq_36883141/article/details/92801134)

#### 6.2 常见数据结构

##### 1.String

字符串是基本的数据类型。

![d4-5-1-1](/Users/dongyanzu/Desktop/d4-5-1-1.jpeg)

Key也是字符串

##### 2.List

- 字符串列表
- 按照插入顺序排序

![d4-5-1-2](/Users/dongyanzu/Desktop/d4-5-1-2.jpeg)

适合于聚合同一类数据

##### 3.Zset

- 字符串集合
- 不允许重复
- 按score（double浮点数）排序

![zset](/Users/dongyanzu/Desktop/zset.png)

适合于排行榜之类的根据指定数值排序的数据

##### Hash

字符串的field（字段）和value（值）的映射表

![hash (1)](/Users/dongyanzu/Desktop/hash (1).jpeg)

同一类数据中，需要根据一个关键字查询的场景。

##### 5. Set

![set (1)](/Users/dongyanzu/Desktop/set (1).png)

适合多集合运算。

####  6.3 缓存穿透、雪崩与击穿

在我们日常的开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦设计大数据量大需求，比如一些商品抢购的情节，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘 读/写 速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的 读/写 操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务器宕机的严重生产问题。

为了克服上述的问题，项目通常会引入NoSQL技术，这时一种基于内存的数据库，并且提供一定的持久化功能。

redis技术就是NoSQL技术中的一种，但是引入redis又可能出现缓存穿透，缓存击穿，缓存雪崩的问题。

##### 缓存穿透

Key对应的数据在数据员并不存在，每次针对此Key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。

比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击kennel压垮数据库。

##### 缓存穿透的解决方案

1. 简单解决发：缓存空对象结果，但注意超时时间不能过长

2. 系统解决发：采用布隆过滤器，将所有可能存在的数据都缓存，那么一个一定不存在的数据会被拦截。

> 布隆过滤器的资料可以查查

##### 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如DB）带来很大压力。

雪崩前段缓存政策从Redis获取，示意图如下：

![xuebeng1](/Users/dongyanzu/Desktop/xuebeng1.png)

缓存失效瞬间示意图如下：

![xuebeng2](/Users/dongyanzu/Desktop/xuebeng2.png)

##### 缓存雪崩的解决方案

1. 简单解决法：缓存失效时间分散开，比如我们可以在原有的失效时间举出上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复利用率就会降低，就很难引发集体失效的事件。
2. 严谨解决法：用加锁或者队列的方法来保证不会有带昂的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。

> 但锁和队列对设计者技术要求很高，需避免降低效率、死锁等问题。

##### 缓存击穿

Key对应的数据存在，但在Redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求kennel会瞬间把后端DB压垮。

雪崩强调的是大量的数据缓存过期出现的问题，而击穿侧重于描述少量Key（热点数据）过期时遇到大量并发请求时出现的问题。

##### 缓存击穿的解决方案

使用锁机制，在缓存失效的时候（判断拿出来的值为空），不是立即去时数据库查询，而是先加锁，在所中查询数据库并会设缓存。目的就是防止大并发请求在短时间内请求数据库。

#### 6.4 Key过大要如何处理

Redis使用过程中经常有各种大Key的情况，比如：

1. 单个Key存储的value很大
2. hash、set、zset、list中存储过多的数据（万级或以上）

由于Redis时单线程运行的，如果一次操作的数据了很大会对整个Redis的响应时间造成负面影响。

有效的解决办法，是拆分。

##### 单个key存储的value很大

可能是一个大对象，或者Java 的大List、Map等容器对象直接存入Redis了。

如果是对象，可以把每个属性作为一个file存入hash结构等缓存中，而不是整个对象序列化成字符串存入Redis，这样读诶对象，相当于操作Redis的field，可以有效缓解操作大Value带来的性能损耗。

> 关于Hash，渡过批量查询file

如果是Java的大容器对象，所以不要直接缓存大容器对象，而是使用对应的Redis结构，避免每次查询完整的数据。

##### hash、set、zset、list中存储过多的元素

也是拆分，把大容器拆分多个小容器。

以Hash为例，大Hash拆分成多个小Hash，每个小Hash称为桶。

固定一个桶的数量，比如10000.每个小桶的Key带一个数字后缀。

每次存取的时候，先在Java程序中计算field的hash值，模除10000，确定了该field落在哪个key上。

> set，zset，list也可以类似上述做法

如果一台Redis不够，可以考虑对Redis扩容。

我们使用的是单机Redis，实际上多台Redis可以组成缓存集群。

那么可以在Java程序设计field的hash值，再根据Redis机器的数量模除，算出field存在哪台Redis的哪个Key中。

