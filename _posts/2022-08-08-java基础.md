---
Layout: post

title: java基础

desc: java基础
tag: study


---



## Java基础

### <1> 变量和类型

#### 1.1 变量

操作变量是所有编程语言的重要功能之一。变量用于存储一些内容，在计算机中**变量**等同于一个有命名的存储地址。比如说我们之前输入的 `Hello World` 这样的字符串，它是有自己的存储地址的，但是我们并不能复用这个地址，因为没有存储名称计算机也无法寻找到这个地址。

> 这个稍微会涉及到计算机组成原理了，不了解也没有关系，以后会慢慢理解这个概念的。

从前面的苦涩描述里，换成需要大家了解的信息是：

- 变量是解决内容复用的
- 变量是有名称的

由于 Java 是一个**面向对象**的语言,Java 把一切内容（字符串、数字、布尔、日期、时间）都用对象来表示，所以在 Java 的世界中`变量内容就是对象`。我们在后面还会介绍对象，这里只是提一下概念。

> 在Java中，每个变量都有一个类型（type)，在声明变量时，变量的类型位于变量名之前。

为了存储数据，所以需要先创建变量。如果我们想存储字符串，则可以声明一个新的字符串变量：

```java
String say;
```

这个语句官方的称呼是**声明（declaration）**。该语句声明了一个名为 say，类型为 String 的变量。每个变量都需要一个类型来决定可以存储什么类型的数值。比如，int 类型可以存储整数，String 类型可以存储字符串。注意一下，这里的类型有的时候首字母是大写，也有的时候是小写的，我们只需要在编写的时候仔细确认一下不要用错了就好，不用试图寻找某种规律哦。

> 再次强调一下，Java 代码的每一行都是使用 `";"` 结束的

我们在看一下如何创建一个整数类型的变量

```java
int age;
```

其中 age 为变量名，也可以是其他名称，不过一般我们都是希望有含义的，比如我想创建一个姓名的变量，那么使用 name 会更好。

```java
String name;
```

> 好的命名是一个非常优秀的编程素养，如果觉得自己英文不OK，你可以使用**有道词典**进行翻译，切记尽可能用英文单词命名变量哦 另外，这个变量名的首字母一般是小写的，遵循小驼峰命名法。

##### 变量初始化

声明一个变量之后，必须用赋值语句对变量进行显示初始化，**千万不要使用未初始化的变量**。例如，Java编译器认为下面的语句序列时错误的：

```java
int vacationDays;
System.out.println(vacationDays); //ERROR--variable not initialized
```

要想对一个已经声明过的变量进行赋值，就需要将变量名放在等号（=）左侧，相应取值的Java表达式放在等号的右侧<1>；页可以将变量的声明和初始化放在同一行中<2>：

```java
// 1
int vacationDays;
vacationDays = 12;

// 2
int vacationDays = 12;
```

> 在Java中，可以将声明放在代码中的任何地方。例如下面是合法的:
>
> ```java
> double salary = 65000.0;
> System.out.println(salary);
> int vacationDays = 12; //OK to declare a variable here
> ```
>
> 在Java中，变量的声明尽可能地接近变量第一次使用的地方，这是一种良好的程序编写风格。

##### 关键字

特别说明一下，虽然变量名可以任意设定，但是 Java 保留了一些名称，这些名称是不允许我们来声明的，这就是关键字。一般来说在编辑器中关键字也会高亮显示的，比如在我们这里会显示出红色字体。

常见的关键字有：

- public
- class
- void
- int

这里有个概念就好，基本上你根据文字颜色就可以区分出来的。如果写错了，控制台也会有错误提示的。

##### 补充：常量

> 在Java中利用关键字final指示常量。例如：
>
> ```java
> final double CM_PER_INRICH = 2.54; //double为双精度浮点数的声明
> ```
>
> 关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能再更改了。习惯上，变量名使用全大写。在Java中，经常希望某个常量可以在一个类中的多个方法中使用，通常这些常量称为类常量。下面是使用类常量的示例：
>
> ````java
> public static final double CM_PER_INRICH = 2.54;
> ````
>
> 类常量的定义位于main方法的外部。因此，在同一个类的其他方法中也可以使用这个常量。而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。

#### 1.2 赋值

声明了变量之后，我们就可以往这个变量里存储数据啦。在编程语言中，存储数据的行为叫做：**赋值**

现在让我们来掌握赋值语句，看看 Java 中如何完成赋值的。

```java
String say = "Hello";
```

如上面的代码，赋值语句就是在变量名后面加上 `= 数据`，如果数据是字符类型，还需要使用 `""` 包围住字符串，如上面的 `"Hello"`

##### 重复赋值

除了上面的赋值方式外，我们还可以对变量重新赋值。

```java
String say = "Hello";
say = "Hello u" // 现在字符串变量say的内容就变为了 Hello u
```

#### 1.3 数据类型

通过前面的学习，其实我们接触了两个数据类型：字符串、整数、浮点数

> 实际上在所有的编程语言里，基本上都包含三种基础数据类型，这个也很容易记住那就是：
>
> - 字符串
> - 数字
> - 布尔

Java是一种强类型语言：这就意味着必须为每一个变量声明一种类型。

在Java中一共有 **8** 种基本类型(primitive type)，其中有4种整形、2种浮点型、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值的boolean类型。

##### 字符串

字符串我们在前面已经运用过多次了，基本上任意的字符、文本之类的内容都可以用字符串来表示，在 Java 中字符串类型就是 `String`,它的值需要使用`" "`包围。

我们在后面还会继续学习字符串的高级用法。

##### 数字

数字类型稍微多一些知识点，因为数字有几个类型

- 小整数
- 大整数
- 浮点数

Java 关于这三种数字有多个类型去匹配，我们这里暂时只记住三个就可以，以后我们再来深入学习，分别是

- 小整数 int
- 大整数 long
- 浮点数 double

小整数和大整数的区别在于存储的数据大小不一样，我们一般接触的数字都是小整数，所以用大部分时候 int 就可以了。

int 和 long 的区别是(这里先有个概念即可)

###### int

最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）

最大值：Integer.MAX_VALUE= 2147483647 （2的31次方-1）

###### long

最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）

最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）

注意 long 类型赋值的时候要在数字最后面跟上一个小写的 `l`(注意是字母 L 不要看错),比如

```java
long num = 78900000123l;
```

###### 整型

| 类型  | 存储需求 |                  取值范围                  |
| :---: | :------: | :----------------------------------------: |
|  int  |  4字节   |   -2147483648～2147483647 (正好超过20亿)   |
| short |  2字节   |               -32768～32767                |
| long  |  8字节   | -9223732036854775808～-9223732036854775807 |
| byte  |  1字节   |                 -128～127                  |

> 在Java中，整型的范围与运行Java代码的机器无关。
>
> 在Java中，所有的数值类型所占的字节数量与平台无关。

###### 浮点类型

float 类型数值有一个后缀F或f（如3.14F），没有后缀F的浮点数值(3.14) 默认为double类型，当然也可以在浮点数值后面添加后缀D或d。

|  类型  | 存储需求 |                   取值范围                   |
| :----: | :------: | :------------------------------------------: |
|  Flat  |  4字节   |  大约 +- 3.40282347E+38F(有效位数为6～7位)   |
| double |  8字节   | 大约 +- 1.79769313486231770F(有效位数为15位) |



##### char 类型

char 类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char 值描述，并外一些Unicode 字符则需要两个char 值。

char类型的字面量值要用单引号括起来 如：'A' 位65所对应的字符常量，它与"A" 不同，"A"是包含一个字符'A'的字符串。

char 类型的值可以为十六进制值，其范围从\u0000 到 \Uffff 例如：\u2122 表示注册符号（TM），\u03C0表示希腊字母π。

> 转义序列:
>
> | 转义序列 |  名称   | Unicode值 |
> | :------: | :-----: | :-------: |
> |    \b    | 退格tab |  \u0008   |
> |    \t    |  制表   |  \u0009   |
> |    \n    |  换行   |  \u000a   |
> |    \r    |  回车   |  \u000d   |
> |  \\\\"   | 双引号  |  \u0022   |
> |   \\'    | 单引号  |  \u0027   |
> |   \\\    | 反斜杠  |  \u005c   |

###### Unicode 类型和 char类型

要想弄清char类型，就必须了解Unicode编码机制。Unicode打破了传统字符编码机制的限制。在Unicode出现之前，已经有许多种不同的标准：美国的ASCII、西欧语言中的ISO 8859-1、俄罗斯的KOI-8、中国的GB 18030和BIG-5等。这样就产生了下面两个问题：一个是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；二是采用大字符集的语言其编码长度有可能不同。例如，有些常用的字符采用单字节编码，而另一些字符则需要两个或更多个字节。
设计Unicode编码的目的就是要解决这些问题。

> 从Java SE 5.0 开始：
>
> 码点（code point）是指与一个编码表中的某个字符对应的代码值。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041就是拉丁字母A的码点。Unicode的码点可以分成17个代码级别（code plane）。第一个代码级别称为基本的多语言级别（basic multilingual plane），码点从U+0000到U+FFFF，其中包括经典的Unicode代码；其余的16个级别码点从U+10000到U+10FFFF，其中包括一些辅助字符
>
> UTF-16编码采用不同长度的编码表示所有Unicode码点。

在Java中，char类型描述了UTF-16编码中的一个代码单元。
我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。

##### 布尔

比如说

```java
// 是否允许
boolean isAllow = true;
```

#### 1.4 运算符

##### 基础运算符

学习了变量的赋值和基础类型之后，现在我们可以玩一点有意思的内容了，大家都知道计算机最早被设计的原因是因为人肉的数学计算太慢了。看一小段历史

> 世界上第一台电子计算机是个庞然大物：重 30 余吨，占地约 170 平方米，肚子里装有 18000 只电子管。它是 1946 年 2 月 14 日，在美国宾夕法尼亚大学诞生的。 在第二次世界大战中，敌对双方都使用了飞机和火炮，猛烈轰炸对方军事目标。要想打得准，必须精确计算并绘制出"射击图表"。经查表确定炮口的角度，才能使射出去的炮弹正中飞行目标。但是，每一个数都要做几千次的四则运算才能得出来，十几个人用手摇机械计算机算几个月，才能完成一份"图表"。针对这种情况，人们开始研究把电子管作为"电子开关"来提高计算机的运算速度。许多科学家都参加了实验和研究，终于制成了世界上第一台电子计算机，起名为"埃尼阿克"。

所以呢，学习编程首要解决的是用计算机做数学运算，从最基本的加减乘除开始，在编程语言中加减乘除这些数学符号称为：**运算符**

- 加法运算符 +
- 减法运算符 -
- 乘法运算符 *
- 除法运算符 /
- 取模运算符 %

我们可以同时使用`变量+数字`来完成计算表达式，比如

```java
// 1小时= 60 分钟，1分钟 = 60s，那么1小时= ？秒
int second = 1*60*60;

System.out.println(second);
```

我们还可以把上面的代码再修改一下,改成用变量的方式来完成计算

```java
int unit = 60;
int hour = 1;
int second = hour*unit*unit;

System.out.println(second);
```

现在我们再看一个计算平均分的例子

```java
int total = 0;

int u1 = 80;
total=total+u1;

int u2 = 90;
total=total+u2;

int u3 = 50;
total=total+u3;

int u4 = 65;
total=total+u4;

int average = total/4;

System.out.println(average);
```

关于 Java 计算还有一个比较隐晦的逻辑，大家可以猜一下下面代码的结果是？

```java
int now = 59;
System.out.println(now/60);
```

你会发现结果居然是 0，而不是 0.9833333333333333，为什么呢？

> Java 执行的是整除除法，也就是说当两个操作数都是整数时，结果也会自动变成整数（直接去掉了小数点的值）

所以如果想计算百分比这种需求的话

```java
int now = 59;
System.out.println(100*now/60);
```

如果我们想计算浮点类型的话，那就需要使用 `double`

```java
double now = 59;
double result = now/60;
System.out.println(result);
```

OK,基本上我们可以做一个小结论了，Java 的数学计算和我们从小学的数据基本一致，这点我们就不再仔细介绍啦。

额外想介绍一下，除了数字类型数据可以进行加减乘除，字符串也可以利用 `+`

> 字符串使用 `+` 可以让多个字符串链接在一起，如果字符串+数字也会变成字符串

```java
public static void main(String[] args) {

  String name = "章问";
  System.out.println("姓名:"+name+" 年龄:"+18);

}
```

##### 结合赋值和运算符

```java
x += 4;
//等价于
x = x+4;
```

##### 自增自减运算符

在代码中，加一建议是数值变量最常见的操作。分为前缀后缀两种形式：

```java
int m = 7;
int n = 7;
int a = 2* ++m; //now a is 16 , m is 8;
int b = 2* m++; //now b is 14 , n is 8;
```

##### 关系和boolean运算符

要检测相等性，可以使用两个等号==。例如`3=7; //result false `,另外可以使用 `!=` 检测不相等 `3 != 7; //result true `

> Java中 &&（与）|| (或) !(非) , &&和|| 按照短路方式来求值，即第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。
>
> Java 也支持三目运算: `condition ? expression1 : expression2;` 如果条件condition为true ， 则为第一个表达式的值，否则为第二个。

##### 位运算

处理整型类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。

&(and) |(or) ^(xor) ~(not) 

\>>和\<<运算符将为模式左移或右移。需要建立为模式来完成掩码时，这两个运算符会很方便.

\>>>会用0填充高位，这与\>>不同，它用符号位填充高位。不存在\<<<。

##### 括号与运算符级别：

同一级别的运算符按照从左到右到次序进行计算：

###### 运算优先级：

结合型：从左往右

|        运算符        |
| :------------------: |
|  [].() （方法调用）  |
|         \*/%         |
|          +-          |
|     << \>> \>>>      |
| < <= > >= instanceof |
|        == !=         |
|        & ^ \|        |
|          &&          |
|         \|\|         |

结合性：从右往左

|                  运算符                  |
| :--------------------------------------: |
|       ! ~ == -- + - ()（强转） new       |
|                    ?:                    |
| = += -= \*= /= %= &= \|= ^= <<= >>= >>>= |



### <2> 无返回值的方法

#### 2.1 数学函数

Java 在数学上面的能力非常强大，有很多内置的数学函数，函数在 Java 当中也称为方法（method），我们暂时不需要了解所有的数学函数。但是有一个数学函数是我们应该知道的，而且非常实用。那就是**随机数**

调用数学方法和之前我们学习的 println 方法类似的，待会我们会继续说到，现在我们回到随机数上来

```java
// 得到一个随机数
double value = Math.random();
System.out.println(value);
```

如上代码，Math 是 Java 提供的类用于提供数学计算的，random 就是方法

Math.random() 方法用于返回一个随机数，随机数范围为 0.0 =< Math.random < 1.0。

这是我们第二次接触方法了（第一次是 System.out.println() ）

```java
0.40068331197074114

0.21177156791789276
```

每次运行都可能看见类似这样长度的随机值把，你会发现这个值是一个浮点类型的数据，并且最大<1.0，最小>=0

做一个有意思的小例子，如果我们想得到 0-9 之间的随机数字可以怎么做呢？借助 random 方法我们是可以得到随机的，但是这个方法执行的结果是一个 double 类型的数据（浮点数）

这个时候我们就需要了解一下浮点数如何转化为整数，理论上数字类型都可以转化，只是会丢失掉精度（自动去掉小数点了）。

Java 当中类型转化的语法如下

```java
int nValue = (int) value;
```

我们如果想要得到 0-9 之间的随机数，那还需要乘以 10

```java
// (value*10) 用小括号包围是因为先乘10得到结果在转化为整数
// 要不然得不到结果，这个就是数学的优先级
int nValue = (int) (value*10);
```

如上，这种`（类型）`强制类型转换的用法就是 Java 中的类型转化语法，记住它，以后我们还会经常运用到.

#### 2.2 自定义方法

我们在之前的代码例子中都是在运行 Java 的方法， println()、random() 这些都是由 Java 提供的方法,当然我们也可以自己添加新的方法。

实际上我们是有过创建方法的，我们在前面一直使用的 main 方法就是我们自己定义的，虽然 main 方法有特殊的含义（它是程序执行的入口,如果要执行代码就必须要有 main 方法），但是它的语法是和其他方法一样的

```java
// 固定的方法格式，main方法用于启动程序
public static void main(String[] args){

}
```

总结一下方法的语法就是

```java
// public（公共的） static（静态） void（空类型）
public static void 方法名称(方法参数){
  代码块
}
```

这里除了 main 和 Java 的关键字之外，方法名称可以任意的英文单词。

##### 驼峰式命名

Java 世界里命名规范遵守“驼峰式”,为了形象的描述它，大家可以先看下图

![OIP-C.jpeg](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/OIP-C.jpeg?raw=true)

骆驼有个非常明显的特点就是它的驼峰，由于它的这种非常明显的特性，编程语言模仿了这个驼峰特性，具体是什么？那就是把每个具体单词的首字母变成大写，这样大写的字母就像驼峰一样。

比如说:**用户名称**如果用英文单词来表示的话就是`UserName`，大家注意看一下，这个大写的 U 和 N 是不是像驼峰一样？这样的例子可以很多，比如说**我的文档**:MyDocument、**密码**:Password

##### 小驼峰

方法名遵守的是**小驼峰**，和驼峰的区别就是第一个单词是小写的，所以上面的例子就可以变成如下：

```java
// 密码
public static void password(){
  //代码块
}
// 我的文档
public static void myDocument(){
  //代码块
}
```

> 注意一下，这里我们只是先完成方法的定义，并没有调用方法哦，所以 password、myDocument 方法并没有被执行

这些都是遵守小驼峰式命名规范的，这点很重要，要不然你的 Java 代码看起来太丑了。

OK，说了这么多，我们先从最简单的方法开始来学习，main 方法比较复杂一点，因为它有参数，我们先从无参数方法开始学习。

比如说看下面的代码

```java
// newLine 是方法名称，这个是我们自己随便定义的
public static void newLine(){
  System.out.println("");
}
```

这段代码就是我们创建的一个自定义方法，这个方法名称就是 **newLine** ，紧跟着方法名的空小括号表明此方法不需要参数（注意小括号不能省掉哦，这个是代码规范）

> 注意一下，这里我们只是先完成方法 newLine 的定义，并没有调用方法哦

#### 2.3 自定义方法调用

当方法被创建成功后我们就可以去执行这个方法，一般在编程语言里我们把这个行为称为：方法调用

这个 newLine 方法如何被调用呢，其实也很简单

```java
public class Custom {

  public static void main(String[] args){

      System.out.println("测试");
      // 这里执行一下 newLine 这个自定义方法的调用
      newLine();
      System.out.println("结束");
  }

  public static void newLine(){
    System.out.println("");
  }

}
```

我们来运行一下看看，注意看一下代码编写的顺序，一定是先定义方法，再调用方法

> 补充说明一下，自定义的方法都是在 class 类当中的，方法的顺序无所谓，放在 main 方法前面或者后面都可以，但是方法内是不能这样新建方法的，初学者经常会混淆格式，仔细检查 {} 是否正确的设定就ok了

我们刚才的例子里调用了一次自定义的方法，实际上方法可以被任意的调用多次。newLine 方法里也可以调用其他方法，比如：

```java
public class Custom {

  public static void main(String[] args){
    System.out.println("测试");
    newLine();
    newLine();
    System.out.println("结束");
  }

  public static void newLine(){
    System.out.println("");
    // 调用下面的 format 方法
    format();
  }
  //格式化输出内容，这里只是为了测试方法的调用
  public static void format(){
    System.out.println("------------");
  }

}
```

现在我们来思考一下，为什么需要方法呢？

- 解决代码复用的问题：比如说 newLine 方法不需要重复编写这段逻辑
- 隐藏程序细节，这样程序更为清晰，从而降低复杂度

现在我们来改一下上节代码

```java
public class Custom {

  public static void main(String[] args) {
    random();
  }

  /**
  *生成6位随机数
  */
  public static void random(){
    int code = (int) ((Math.random()+1) * 100000);
    System.out.println(code);
  }

}
```

> 这样的代码是不是看的舒服一点，当代码这样解耦合后就可以支持多人协同开发了，我们还会讲到。

```java
public class Custom {

  public static void main(String[] args) {
    random();
    code();
  }

  /**
  *生成6位随机数
  */
  public static void random(){
    int code = (int) ((Math.random()+1) * 100000);
    System.out.println(code);
  }

  /**
  *生成4位随机数
  */
  public static void code(){
    int code = (int) ((Math.random()+1) * 1000);
    System.out.println(code);
  }

}
```

我们把课程中的随机数和作业的4位随机数放在了一起。大家有没有发现，random 和 code 代码其实没有太大的区别，只有 `* 100000` 和 `* 1000` 这个行为的区别

为了解决这个问题，我们需要引入一个新的概念，那就是**方法参数**

我们可以把 100000 和 1000 这个数字定义为一个 int 类型的变量，然后赋不同的值，通过方法参数传递过去就能解决啦。我们直接看一下代码

```java
public class Custom {

  public static void main(String[] args) {
    random(100000);
    random(1000);
  }

  /**
  *生成随机数
  */
  public static void random(int length){
    int code = (int) ((Math.random()+1) * length);
    System.out.println(code);
  }

}
```

大家看一下，这样代码是不厉害了很多？现在让我们来看一下这个方法参数的语法

```java
public static void random<1>(int length)<2> {
	int code = (int) ((Math.random() + 1 ) *length);
	System.out.println(code);
}
```

- <1> 方法名称：遵循小驼峰命名
- <2> 方法参数：参数类型，参数名

实际上方法参数和声明变量并无区别，只是这个变量是要定义在方法参数这个位置里，编程语言里把这个声明的变量叫做 **形参**

##### 方法调用

看了方法参数后，回头来看方法调用的问题，如果方法有了参数声明后，就必须要传入参数，否则会编译失败。

这个参数可以是变量，也可以是值,只是要特别注意数据类型要匹配，你不能给一个 int 参数 传入 String 字符串类型

编程语言里把这个传递的变量称为 **实参**

```java
// 直接传值
random(100000);

// 传递变量
int len = 100000;
random(len);
```

##### 2.5 多参数方法

```java
public class MessageCode {

  public static void main(String[] args) {
    code(1000);
  }

  public static void code(int len){
      int code = (int)((Math.random()+1)*len);
      System.out.println("亲爱的优课达用户，你本次的验证码是【"+code+"】");
  }

}
```

在我们实际工作中，其实短信的文字部分（一般称为文案）经常会被调整，运营同学经常会提出一些文案变更的需要。

我们前面提到过方法的特性之一：隐藏程序细节，所以如果每次都要修改方法内容，那么会导致复用以及维护成本变高。所以在实际运用中，我们会把文案也定义成变量，并且支持变量的值更新。

在我们这个场景里，我们就需要定义多个参数了，让我们来看一下这段代码

```java
public class MessageCode {

  public static void main(String[] args) {
    String text = "亲爱的用户，你本次的验证码是";
    code(text,1000);
  }

  public static void code(String text,int len){
      int code = (int)((Math.random()+1)*len);
      System.out.println(text+"【"+code+"】");
  }

}
```



OK，我们在这个例子里新添加了一个参数,你会发现多个形参其实也挺简单的，就是使用 `,`分隔一下。

### <3> 逻辑语句

#### 3.1 条件执行

##### 条件语句

在Java中，条件语句的格式为：

```java
if(condition) statement //这里的condition条件必须要用括号括起来
```

我们经常说计算机的世界除了0和1的组成外，就是一堆 if else 的集成，也就是说编程的很多工作都是要进行各种条件的判断，Java和其他编程语言一样支持条件语句，**条件语句**就是让我们执行条件判断的语法。

最简单的条件形式就是 if 语句

```java
public class ConditionTest1 {

  public static void main(String[] args) {
    sayX(20);
  }

  public static void sayX(int x){
    if(x>0){
      System.out.println("x：" +x);
    }
  }

}
```

关键字 if 后括号中的代码叫做：**条件表达式**，如果它为真，大括号中的语句就会执行；反之，则什么都不会发生。

if 语句也比较简单，如下

```java
if(表达式){

  代码块

}
```

注意这个格式哦，初学的时候经常会搞错格式导致语法错误

条件表达式可以包含任意的比较运算符（有时候也叫做关系运算符）

```java
x == y   // x 等于 y
x != y   // x 不等于 y
x >  y   // x 大于 y
x <  y   // x 小于 y
x >= y   // x 大于等于 y
x <= y   // x 小于等于 y
```

基本上这些和数学公式是一致的，但是还是有一些不同点，也是经常会出错的地方。

比如：**=** 和 **==**

> 在 Java 中 `=` 符号是赋值运算符，这个我们在变量那个章节里学习到过。 `==` 是判断是否相同的比较运算符

还有一点是误写的，Java 中不存在 =< 和 => 这两种写法，这是错误的

最后，再啰嗦一下，Java 中比较运算符的左边和右边的对象类型必须一样的，int 整数只能和 int 整数比较，双精度数 double 只能和 double 比较。

#### 3.2 选择性执行

除了我们刚才使用的 if 语句之外，我们还可以有第二种形式的条件执行那就是**选择性执行**

在Java中，更一般的条件语句格式如下所示：

```java
if(condition) statement1 else statement2;
```

选择性执行指的的就是有两条可选路径，我们通过判断条件来选择其中一条路径，看一下它的语法

```java
public class Condition{

  public static void main(String[] args){
    number(4);
    number(5);
  }

  public static void number(int x){

    if(x % 2 == 0){
      System.out.println(x+"是偶数");
    }else{
      System.out.println(x+"是奇数");
    }

  }
}
```

所以你可以看见选择性执行的不同就是多了一个 else ,注意看一下这个格式哦,尤其是大括号，这个经常会出错

```java
if(条件表达式){
  代码语句
}else{
  代码语句
}
```

#### 3.3 条件判断链

当我们掌握了条件语句和选择性语句，可以说我们基本上掌握了核心的逻辑语句，其实大部分程序的代码都是由 if else 组成的。

但是在某些时候我们会遇到条件判断多于两个的情况，并且需要根据条件的不同执行不同的分支，这个时候我们就需要新的技术：**条件链**

条件链的语法非常简单，我们以发布考试成绩的场景为例，现在很多考试已经不说具体的分数，而改为优秀、良好、及格、不通过这种了。我们来完成这段逻辑的代码

```java
public static void report(String name,double score){
  if(score >= 90){
    System.out.println(name+",你本次的成绩为优秀");
  } else if(score >= 80){
    System.out.println(name+",你本次的成绩为良好");
  } else if(score >= 60){
    System.out.println(name+",你本次的成绩为及格");
  } else {
    System.out.println(name+",你本次的成绩为不通过");
  }
}
```

我们可以看到，这里我们多了一个语法 `else if` 这个和 if 本质没有什么区别，唯一的区别在于它的执行顺序，我们在前面说过 Java 代码的执行是一行一行的执行，所以条件链的执行是先从第一个条件判断开始，如果判断不成功继续执行下一个判断，一直到没有条件符合的情况。

#### 3.4 嵌套条件

我们一直在反复的说 Java 是一行一行执行的，而条件语句基本上都是选择性的执行，有的时候我们会期望在符合一个条件后再去判断条件，这也就是所谓的**嵌套条件**，当然 Java 也支持多种嵌套方式的，以后我们还会学习到这点。

比如我们把上节课的内容，改一下，我想增加一个过滤及格同学的逻辑，对于及格的同学多发送一条短信，大家可以先自己想一想这个逻辑如何实现呢？

先不要看代码，闭上眼睛想一想

```java
public class StudentReport {

  public static void main(String[] args){

    report("小明",80);
    report("小王",90);
    report("小四",70);
    report("小五",50);
    report("小六",40);

  }

  public static void report(String name,double score){

    if(score >= 60){
      message(name);
      if(score >= 90){
        System.out.println(name+",你本次的成绩为优秀");
      } else if(score >= 80){
        System.out.println(name+",你本次的成绩为良好");
      }else{
        System.out.println(name+",你本次的成绩为及格");
      }
    } else {
      System.out.println(name+",你本次的成绩为不通过");
    }
  }

  public static void message(String name){
    System.out.println(name+"恭喜你成功进阶");
  }

}
```

我们可以看到，这里我们在 if 语句里再执行 if else 语句，这就是嵌套执行，Java 是可以多层嵌套的哦

#### 3.5 返回语句

在我们日常生活中我们经常会出现打断计划的一些情况，比如说:我和好朋友们约了明天11点去学校操场踢球，结果到了第二天突然高烧39度，只能取消踢球活动了。

从上面的描述中可以看到，因为意外我们需要中断原本的计划，这种场景其实发生的会比较多，那么在 Java 当中，可以通过**返回语句**来完成程序的中断。我们用代码来完成刚才的案例，大家理解一下返回语句

```java
public static void plan(double temperature){

  System.out.println("准备出门去学校");

  if(temperature>38){
    // 体温超过38度，属于发烧，忌运动
    return;
  }
  
  System.out.println("去操场踢球");

}
```

从上面的代码中可以看到，我们多了一个 `return;` 这就是返回语句，代码执行到这里的时候就会中断后面的代码。

大家可以从控制台的输出上仔细看看，理解这句话。

返回语句在之后我们还会频繁的运用到，这个简单的语句作用非常大，因为程序的很多地方都有这种意外中断的情况

> 有一点需要特别说明的，就是 `return;`语句之后是不能有其他代码的（除非是在嵌套代码里，比如上面的例子）

```java
public static void plan(double temperature){

  System.out.println("准备出门去学校");

  if(temperature>38){
    // 体温超过38度，属于发烧，忌运动
    return;
  }
  return;
  System.out.println("去操场踢球");

}
```

上面这个代码是错误的，编译就会报错了，因为 `return;` 之后不应该有代码。

#### 3.6 递归

掌握了前面几种条件执行的类型后，我们再来学习一个在程序设计中非常重要的思想，那就是**递归**

如果没有递归这个设计思想，代码都是非常死板的，因为它只能根据我们编写的 code 一行一行的呆板执行，不够灵活和智能。

递归的规范其实只有一句简短的话：一个方法也可以调用它自身。

我们看一个案例理解一下什么是**递归**

现在我们提供一个倒计时的功能

```java
public class CountDown {

  public static void main(String[] args) {
    count(3);
  }

  public static void count(int number) {
    System.out.println(number);
    number = number - 1;

    if (number == 0) {
      System.out.println("程序执行完毕");
      return;
    }
    count(number);

  }

}
```

在前面我们说过，递归主要体现的一种编程设计思想，其实语法很简单，后面我们还会继续运用到，学习编程除了基础语法外，就是不断的去接触和了解设计思想，也就是计算机思维

当一个方法调用它自身，这叫做**递归**，这种方法称为**递归方法**

### <4> 有返回值方法

#### 4.1 返回值

我们在上一课中学习了返回语句 `return;`,大家知道返回语句的目的是中断程序执行，相信大家没有忘记 `Math.random()`这个随机数方法吧，这个方法和我们自己写的方法有个很大的不同，那就是我们执行了`Math.random()`这个方法后，是有返回结果的。这也是本节课我们要学习的知识：**返回值**

我们再来看一下随机数的代码

```java
/**
 * 得到验证码
 */
public static void code(int len){
  // 得到随机数结果
  double val = Math.random();

  // 随机数结果*9+1 然后再乘以位数得到验证码
  int result = (int)((val*9+1)*len);
}
```

这段代码大家应该是很熟悉的了，为了强调返回值，这里我们把 `Math.random();`赋值给了`double val`；

那我们来看一下 random 这个方法 Java 的源代码是如何写的

```java
public static double random() {
   return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
}
```

我们可以对比一下区别，其实有两处格式的不同

> RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble(); 这个是另外一个 Java 方法，暂时不用管

##### 方法返回值类型的声明

第一处不同就是方法的声明上有不同

```java
// 验证码方法
public static void code(int len)

// 随机数方法
public static double random()
```

仔细观察一下，你会发现方法的格式做一下改变，把 `void` 换成了 `double`，这个改变就是方法返回值的声明，如果这个位置的代码写的是 `void` 表示的是无返回值，否则就是有返回值，返回值可以是我们前面介绍的数据类型（当然还可以是其他对象，以后我们还会用到）:int、String、double、boolean

所以如果我们想要定义一个有返回值的方法就需要按照这个格式来声明。

> 我们为什么需要给方法定义返回值类型呢？其实这个问题也很好解答，就像 `Math.random()` 方法一样，我们不关心方法内部的细节只想获取方法返回值的时候就可以这样做，待会通过案例来理解，现在先有个概念，因为很多时候学编程先学的是格式、语法、规范

##### 方法体返回语句的执行

第二处不同就是方法的返回语句有不同，在方法返回类型声明为 `double` 之后我们在方法执行的时候就必须执行 `return 返回结果;` 这个返回结果的类型必须和方法声明的返回值一致

说起来好像有点复杂哈，我们试一下就知道了，现在我们改造一下我们的验证码代码

```java
public class Captcha{

  public static void main(String[] args){
    //打印出4位随机码
    System.out.println("本次的验证码是:"+code(1000));
  }


  /**
  * 得到验证码
  */
  public static int code(int len){
    // 得到随机数结果
    double val = Math.random();
    // 随机数结果*9+1 然后再乘以位数得到验证码
    int result = (int)((val*9+1)*len);
    return result;
  }
}
```

这段代码中，我们调用了 code 方法，并得到了这个方法的结果，我们把这个结果打印出来了。

运行完之后，我们再来优化一下这个代码，很多时候我们虽然要求是 4 位验证码，但是并不知道结果是否正确（比如说如果返回了 5 位数、6 位数那就是错误的），这个时候就需要我们进行值的判断，比如上面的代码就可以是如下的。

```java
public class Captcha{

  public static void main(String[] args){
    // 得到验证码
    int codeValue = code(1000);

    // 如果 codeValue 在1000和9999之间，那么就是正确的4位随机数
    if(codeValue >= 1000 ){
      if(codeValue<=9999){
        System.out.println("本次的验证码是:"+codeValue);
      }
    }
  }


  /**
  * 得到验证码
  */
  public static int code(int len){
    // 得到随机数结果
    double val = Math.random();
    // 随机数结果*9+1 然后再乘以位数得到验证码
    int result = (int)((val*9+1)*len);
    return result;
  }
}
```

我们继续看一下结合 if 语句的返回值。 注意，如果有返回值，返回语句应该是程序的最后执行的行（大多数是最后一行，如果有 `if else` 语句可能就不是最后一行）

> 公司到季度末了准备发奖金,如果销售额<100000，奖金按 10%;销售额>=100000，奖金按 9%;销售额>300000,奖金按 7%;没有销售额，没有奖金

```java
public class BonusDemo{

  public static void main(String[] args){
     int amount = bonus(0);
     System.out.println(amount);

     amount = bonus(80000);
     System.out.println(amount);

     amount = bonus(280000);
     System.out.println(amount);

     amount = bonus(500000);
     System.out.println(amount);
  }

  /**
  *   计算奖金
  */
  public static int bonus(int amount){
    if (amount<100000){
      return amount*10/100;
    } else if(amount>300000){
      return amount*7/100;
    } else if(amount>=100000){
      return amount*9/100;
    } else {
      return 0;
    }
  }

}
```

#### 4.2 布尔&&逻辑运算符

我们在前面的课程里，数据运算结果的类型和操作符的类型均相同，比如说 `+`运算符如果传递的是两个 int 整数，那么其结果也是一个整数；或者如果传递的都是 double 类型，那么结果也是 double 类型。

而关系运算符和上面的运算符有很大的不同，它的结果要不然是 true 要么是 false。true 和 false 在 Java 中是非常特殊的值，我们将这个类型称为布尔型，这个我们在前面的第二章的数据类型里也有介绍过。我们现在深入的学习一下这个 boolean 类型

我们看一下这段代码

```java
if(x>0){
  System.out.println("x>0");
}
```

实际上，上面代码中的条件表达式的结果就是 boolean 类型。所以上面的代码也可以写成

```java
boolean flag = x>0;
if(flag){
  System.out.println("x>0");
}
```

boolean 类型除了作用于这里，也可以作为方法的参数或者返回类型。比如判断是否及格的方法

```java
public static boolean isPass(int score){
  return score >= 60;
}
```

##### 逻辑运算符

我们在前面学习过条件表达式，通过条件表达式可以完成条件的判断，实际上除了数学表达式之外，Java 还支持三种逻辑运算符：and（与）、or（或者）、not（非），对应的符号分别是 `&&`、`||`、`!`

使用逻辑运算符有什么用呢？可以用另外一种解释就是组合多个条件，举个例子

```java
if(x>0 && x <10){
  // 表示 x 大于0 并且 x小于10时才为真
}

if(x == 60 || x == 80){
  // 表示 x 等于60 或者 x 等于80 都为真
}

if(x!=0){
  // 表示x不等于0的时候
}
```

在有些时候，我们还可以对 boolean 数据进行 `!` 的运用这个表示对 boolean 值进行否定，比如

```java
boolean isPass = false;

if(!isPass){
  System.out.println("通过考试");
}
```

逻辑运算符的运用会非常多，因为很多时候我们的条件都是组合的，除了组合一次外还可以多次组合，比如

```java
if(x == 60 || x == 80 || x == 90){
  // 表示 x等于60 或者x等于80 或者x等于90为真
}
```

### <5> 循环

#### 5.1 自增和自减

##### 自减

大家应该还记得我们之前写的倒计时代码把

```java
public class CountDown {

  public static void main(String[] args) {
    count(3);
  }

  public static void count(int number) {
    System.out.println(number);
    number = number - 1;

    if (number == 0) {
      System.out.println("程序执行完毕");
      return;
    }
    count(number);

  }

}
```

在这段代码中，我们使用了 `number = number - 1;`完成了数据更新，每次拿 number 的值-1 得到新的值并且重新赋值给 number 变量。在编程语言中，我们把这种行为叫做**自减**，从名称上就可以理解到自己减自己

自减的语法是：`变量名称--，比如 number--;` 注意这个 `--`两个减号等同于代码`number=number-1;`由于默认是-1 所以 1 可以省略，上面的代码就可以改成

```java
public class CountDown {

  public static void main(String[] args) {
    count(3);
  }

  public static void count(int number) {
    System.out.println(number);
    number--;

    if (number == 0) {
      System.out.println("程序执行完毕");
      return;
    }
    count(number);

  }

}
```

##### 其他步长

实际上只要固定减数字的都可以采用自减的语法，但是又有一点的区别。比如说 `number = number -2;` 可以改成 `number-=2`;

##### 自增

实际上自增和自减没有啥区别，就是把`--`换成`++`。

```java
public static void main(String[] args){
  int a = 10;
  a++;
  System.out.println(a);
}
```

#### 5.2 数组

在编程语言里，除了前面说的字符串、数字、布尔这三个基础的数据类型外，其实还有一个基础数据类型，那就是**数组**，数组就是一组类型相同的数据组合在一起。

比如说，我们可以通过数组来存储任意的 int 类型数据，比如说大家的身高；也可以存储任意的字符串 String 类型数据，比如说大家的名字。数组是一个非常重要的数据结构，后面要学习的集合类底层也是在操作数组，所以在这了解数组的机制还是非常有必要的。

数组的创建和普通变量的创建基本上差不多，唯一有差别的是数组类型后面多了一个`[]`（中括号）。比如，`int[]`表示“整型数组”类型，`String[]`表示“字符串数组”类型.

我们看一下实际的案例，比如这样的一堆数字:`1,3,5,7,9,11`,我们用数组存储这些数字

```java
// 声明一个 int 数组的变量，数组大小为6
int[] numbers = new int[6];
```

大家注意看一下这个语法哦，除了[]之外，我们在赋值的地方也产生了变化，因为数组是一堆同类型数据的集合，所以它的大小是要确定的，`new int[6];`这个语句的作用就是创建一个新的数组空间，空间大小为 6。为什么是 6？因为上面要存储的数据是 6 个数字

创建好数组变量后，就需要存储每一个数据，那么我们可以借助`[下标]`来完成操作，比如

```java
// 声明一个 int 数组的变量，数组大小为6
int[] numbers = new int[6];

numbers[0] = 1;
numbers[1] = 3;
numbers[2] = 5;
numbers[3] = 7;
numbers[4] = 9;
numbers[5] = 11;
```

看了这段代码，你大概可以理解到下标的运用了，是的下标就是不超过数组长度的数字，0 代表的是数组第一个数据，1 代表的是第二个数字，这个从 0 开始的坐标请记住哦，因为编程语言里很多时候的位置都是从 0 开始的。

同样如果想获取数组的某一个数据，也是用下标，语法如下

```java
// 得到数组中第三个数字
int num = numbers[2];
System.out.println(num);
```

好的，现在我们来演示一下看看

相信大家看完运行以后，对数组的工作有了一点的理解。但是实际上数组还有不少的概念，我们抓一下重点的知识先了解一下。

##### 长度

数组对象都有一个值 `length`，可以得到该数组的长度，由于我们前面说过数组的坐标是从 0 开始的，所以如果想取数组的最后一个数据，正确的数组下标是 `length-1`，这点我们在初学的时候经常混淆。

```java
public static void main(String[] args) {
  int[] numbers = new int[8];

  int size = numbers.length;
  System.out.println(size);

}
```

现在我们调用一下这个方法。

我们继续看一下取最后一位的例子

```java
public static void main(String[] args) {
  int[] numbers = new int[8];

  int size = numbers.length;
  System.out.println(size);

  System.out.println(numbers[size]);

}
```

现在我们调用一下这个方法。

你会发现控制台里会输出错误消息，这是因为数组越界了，因为数组的坐标是从 0 开始，正确的范围就是`i>=0 && i<size`

##### 初始化变量

```java
public static void main(String[] args) {
  int[] numbers = new int[8];
}
```

实际上，上面的代码的目的就是做了一个数组的初始化，这个初始化的作用就是开辟了该长度的存储空间，这个概念我们经常会混淆，这里还是希望大家有个印象。

数组初始化完后，并没有存储实际的值，int 类型的数据默认值是 0，所以如果没有完成数组的赋值，那么 int 数组的每一个值都是 0；String 类型的数据默认值是 null，所以没有赋值，那么 String 数组的每一个值都是 null

> 数组的这些运用，我们在之后还会不断的进行练习，暂时记住这些语法就好了。

#### 5.3 使用 for 循环

当我们掌握了数组后，就会有一个新的需求，如果我们想遍历数组中的每一项数据就需要用到**循环**的知识。

举一个日常的例子让大家理解一下循环，下表是一个班级的所有姓名列表

| 名称 |
| :--: |
| 张三 |
| 李四 |
| 王五 |

大多数情况下，我们都需要操作这类表格数据，主要有两个需求

- 录入数据到计算机中去
- 遍历分析数据

首先我们看一下如何录入数据，

```java
String[] tables = new String[3];

tables[0] = "张三";
tables[1] = "李四";
tables[2] = "王五";
```

解决完存储之后，我们就需要遍历出数组中的每一条记录，这就需要运用循环的知识

循环的知识相对有一点点抽象，简单的来说就是有个计数器一直在递增，递增到指定的值为止，在数组中，我们可以通过这个计数器的值得到数组的对应下标的值。

比如上面的 tables 数组的长度为 3，那么这个计数器的起始值是 0，最大值是 2，循环的作用就是自动执行计数器从 0-2 的递增，它的语法如下

```java
for(int i = 0; i< tables.length;i++){
  String name = tables[i];
  System.out.println(name);
}
```

循环的语法就是 for 语句，for 语句中小括号的内容就是指定了计数器如何工作。

`int i=0;` 这句声明了一个新的计数器，它从 0 开始工作

```java
i< tables.length;` 这句声明了计数器的条件，最大值不能超过 `tables.length
```

`i++` 这句声明了计数器的工作机制，这里是递增，每次+1

记住这个语法，多练习几次就掌握了循环啦，现在我们演示一下

```java
public static void main(String[] args) {
  String[] tables = new String[3];

  tables[0] = "张三";
  tables[1] = "李四";
  tables[2] = "王五";

  for(int i = 0; i < tables.length; i++){
    String name = tables[i];
    System.out.println(i+"："+name);
  }

}
```

实际上数组的数据初始化，还有一个简写方式，如果数据已经很确定的情况下，比较说班级人员的名称，那么我们可以使用如下的语法

```java
public static void main(String[] args) {
  String[] tables = new String[]{"张三","李四", "王五"};

  for(int i = 0; i < tables.length; i++){
    String name = tables[i];
    System.out.println(i+"："+name);
  }

}
new String[]{"张三","李四", "王五"};` 这个语法就是初始化字符串数组数据;如果是数字数组的话，那就是 `new int[]{39,40,89};`;浮点数据就是 `new double[]{39,40,89};
```

> 虽然数组的这个初始化非常方便，但是我们刚才说过数据必须很确定才可以这样操作，这句代码同时完成了数组长度的设定和数组的赋值

##### 扩展知识点

今后大家可能会看到这样的代码：

```java
for (String name : tables) {

}
```

大家不用奇怪，这也是一种循环，等同于：

```java
for(int i = 0; i < tables.length; i++){
  String name = tables[i];
}
```

##### 嵌套循环

循环语句也遵循了编程语言的一个非常重要的特性，那就是嵌套，类似 if 语句一样，循环语句也可以嵌套循环语句，比如说我们打印一下 3*3 乘法表

```java
public static void main(String[] args) {

  for (int i = 1; i <= 3; i++) {
    String line = "";
    for (int j = 1; j <= i; j++) {
      // 拼接line字符串，打印出 类似 1*2=2 2*2=4 这样的效果
      line = line + j + "*" + i + "=" + j * i + " ";
    }
    System.out.println(line);
  }

}
```

> 稍微解释一下这段代码，第一个 for 循环的目的是为了控制行，3*3 代表的是有 3 行数据，每一行的数据是由第二个循环来完成的，基于乘法口诀的定义，每一行的最大乘法不会超过该行的行数，比如第一行应该打印 1*1=1，第二行应该打印 1*2=2 2*2=4,大家可以自行脑补一下 i、j 的值，理解一下这个逻辑

### <6> 字符串

#### 6.1 字符串

从概念上讲，Java字符串就是Unicode字符串序列。例如，串"Java\\u2122"由5个Unicode字符，J、a、v、a 和 TM。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例：

```java
String e = ""; //an empty string
String greeting = "Hello";
```

##### 子串

String 类的substring 方法可以从一个较大的字符串提取出一个子串。例如：

```java
String greeting = "Hello";
String s = greeting.substring(0,3);
```

创建了一个由字符"Hel"组成的字符串。sustring方法的第一个参数是开始位置，第二个参数是不想复制的第一个位置。这里要复制位置为0，1，2从0～2的字符，不包括3位置。

##### 拼接

Java语言允许使用+号连接（拼接）两个字符串。

```java
String expletive = "Expletive";
String PG13 = "deleted";
String message = expletive + PG13;
```

上述代码将"Expletivedeleted"赋给变量message。

> 当一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。
>
> ```java
> int age = 13;
> String rating = "PG" + age;
> ```
>
> rating设置为"PG13"

##### 不可变字符串

String类没有提供用于修改字符串的方法，由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串"Hello"永远包含字符H,e,l,l和o代码单元序列，而不能修改其中的任何一个字符，当然修改字符串变量,让它饮用另一个字符串，这就如同可以将存放3的数值变量改成存放4一样。

> 不可变字符串有一个优点：编译器可以让字符串共享。
>
> > 为了弄清楚具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量只想存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。
> >
> > Java的设计者认为： **共享带来的高效率远远胜于提取、拼接字符串所带来的低效率。**

#### 6.2 调用字符串对象方法

在计算机的世界中，很多时候离不开字符串的处理，因为从纸质的内容变成计算机数据这个过程的原始数据都是字符串，所以很多时候我们遇到的数据处理都是在操作字符串，处理字符串也是一项非常实用的技能。

在 Java 或其他一些编程语言中，对象表示具有相关性的数据和方法的集合。方法用来操作对象、执行计算和修改对象的数据等。在 Java 中 String 字符串也是对象，所以它也包含数据和方法的，都有那些呢？

字符串对象由字母组成，或者更一般的说，由字符组成。不是所有的字符都是字母，有些可能是数字、符号等。为了简单起见，我们统一称这些字符为字母。

字符串拥有的方法非常多，但是我们只要掌握很少的几个就已经足够了，我们分别来看一下

##### 字符串长度 length

- int length()

​		返回字符串的长度。

字符串长度非常实用，比如说我们发微博限制 140 个字，那就要计算字的个数，这个个数就可以通过字符串的长度方法来完成，语法如下

```java
public static void main(String[] args) {

  String message = "今天我在学习 Java 字符串";
  // 调用字符串的长度方法得到长度
  int size = message.length();

  System.out.println(size);
}
```

大家猜一下这个长度是多少呢？

我们现在改造一下上面的代码，把这段代码改成微博消息个数的验证方法，这样的好处就是我们可以重复利用这段逻辑，而不需要每次都自己写同样的代码，这也是封装为方法的好处

```java
public class Test71 {

  public static void main(String[] args) {

    boolean countPass = validateCount("今天天气挺好的");

    System.out.println(countPass);

  }

  public static boolean validateCount(String message){
    if(message.length()>140){
      return false;
    }
    return true;
  }

}
```

解释一下这段代码，首先我们定一个名为 validateCount 的方法:

- **参数**是一个 String（字符串）类型，因为我们想判断消息的字数，所以这个参数定义的是 String（字符串），参数名称我们就定义为 message（消息） 了
- **返回类型**是 boolean（布尔） 因为我们想要验证消息字数是否满足条件，所以这个时候使用 boolean（布尔） 作为返回类型，这样调用者无需关心程序细节
- **方法体**的逻辑就比较简单了，我们借助 `length()`方法来进行判断

> 这里要注意一下方法中如果声明了返回类型，那么方法体中一定是有 return 语句来进行相同的数据类型返回值的。

##### 取出字符串中的一个字 charAt

- char charAt(int index)

​		返回给定位置的代码单元。

一个字符串，比如：`Hello Java`，我们想取出第二个字，那么就可以使用 `charAt(index)`，index 就是具体的坐标（和数组一样，从 0 开始的），所以第二个字的 index 值是 1

```java
public static void main(String[] args) {

  String message = "Hello Java";
  // 取出第一个字
  char str = message.charAt(0);
  System.out.println(str);
  // 取出第二个字
  str = message.charAt(1);
  System.out.println(str);
}
```

> charAt 方法返回的数据类型是 char，你可以理解称单个字符类型就是 char，它只能存储一个字符

我们还可以结合字符串长度、for 语句，得到每一个字符，比如

```java
public class Test72 {

  public static void main(String[] args) {

    print("今天天气挺好的");

  }

  public static void print(String message){

    for (int i = 0; i < message.length(); i++) {
      char str =  message.charAt(i);
      System.out.println(str);
    }

  }

}
```

##### 去掉左右多余的空格 trim

- String trim()

  ​	返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。

我们经常由于误操作在输入内容的时候可能多打了一个空格，这个时候就需要我们把空格去掉，这就需要用到 `trim()` 方法了, trim 方法执行后得到一个新的字符串，这个新的字符串左右是没有空格的

```java
public class Test721 {

  public static void main(String[] args) {

    String str = " 优课达 ";
    // 打印一下现在的length
    System.out.println(str+"的长度是:"+str.length());

    // 处理一下去空格
    String newStr = str.trim();
    // 打印一下新字符串的length
    System.out.println(newStr+"的长度是:"+newStr.length());
    // 对比再打印一下老的字符串的length
    System.out.println(str+"的长度是:"+str.length());

  }

}
```

> 注意，trim 语句是会把字符串左右两边的空格都清除掉哦，不管是有多少个空格，比如说“  空格测试  ”这个字符串 trim 处理后变成“空格测试”，而”空格在右边  ”这个字符串 trim 后会变成”空格在右边”。原始的字符串执行 trim 方法后并不会改变值，这点需要注意下哦，上面的代码也有演示

#### 6.3 字符串常用方法

##### 查找字符串 indexOf

- int indexOf(String str)

​		返回字符串str匹配的第一个子串的开始位置，这个位置从索引0开始计算，如果不存在str则返回-1。

我们在工作当中经常会遇到过滤信息的需求，比如说我们想找出下面一段话中是否有 Java 这个词

> Java 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。任职于太阳微系统的詹姆斯·高斯林等人于 1990 年代初开发 Java 语言的雏形，最初被命名为 Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun 公司放弃了该项计划。随着 1990 年代互联网的发展，Sun 公司看见 Oak 在互联网上应用的前景，于是改造了 Oak，于 1995 年 5 月以 Java 的名称正式发布。Java 伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。

`indexOf("字符串")` 这个方法就是解决这类问题的，indexOf 方法接受一个 String 字符串，当调用这个方法的时候，就会去文本中去查找第一个匹配到的坐标索引值,所以我们可以得到一个 int 数字类型的数据。我们可以根据这个 int 数字的值来判断是否匹配

如果返回值是 -1 说明不匹配，如果返回值 != -1 ，那么说明匹配到了

所以上面的需求，我们可以如下实现

```java
  public static void main(String[] args) {
    String str = "Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。任职于太阳微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。";

    int index = str.indexOf("Java");

    if(index!=-1){
      System.out.println("匹配到了Java，索引位置是"+index);
    }else{
      System.out.println("没有匹配到了Java");
    }
  }
```

如果想找到第二个出现 Java 的位置，怎么实现呢？

```java
  public static void main(String[] args) {
    String str = "Java是一种广泛使用的计算机编程语言，于1995年5月以Java的名称正式发布。";

    int index = str.indexOf("Java");

    index = str.indexOf("Java", index + 4);

    System.out.println("第二次匹配到了Java，索引位置是" + index);

  }
```

> 这里，我们看到 indexOf 方法有了一个新的调用方式：`indexOf("字符串","开始索引值")`,第二个参数是一个数字类型，用于设定从什么位置开始查找。所以我们找到第一个匹配到的索引+匹配字符串长度就是开始值了，这个时候查找到的就是第二个匹配内容了

##### 字符串拼接 substring

- String substring(int beginIndex)

- String substring(int beginIndex , int endIndex)

​		返回一个新字符串。前者返回的是beginIndex到结尾的代码单元，后者返回的这个字符串包含原始字符串中从beginIndex到串尾endIndex-1的所有代码单元。

有的时候，我们还会有类似这样的需求，我们想得到某个匹配到的字符串之后的内容。比如还是上段文本，我们想取出 Java 之后的内容，怎么办呢？这时候我们就需要借助 substring 这个字符串拼接方法了

substring 方法有两种调用方式，一种是：substring(开始索引, 结束索引)，这个方法执行的结果就是拼接新的一个字符串从开始索引开始（含这个值）到结束索引结束（不含）；还有一种是 substring(开始索引)，这个方法执行的结果就是从开始索引开始（含这个值）一直到结束

我们来看一下上面的需求是如何完成的

```java
 public static void main(String[] args) {
    String str = "Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。任职于太阳微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。";

    int index = str.indexOf("Java");

    if (index != -1) {
      System.out.println("匹配到了Java，索引位置是" + index);

      String newStr = str.substring(index+4);
      System.out.println(newStr);

    } else {
      System.out.println("没有匹配到了Java");
    }
  }
```

> 细心的你应该会发现 `String newStr = str.substring(index+4);` 这句我们调用的开始索引做了一个+4 的计算，这是因为我们想取出 Java 之后的内容，那么就是 Java 这个的索引+它的长度，这个时候才对

如果我们只想取出 Java 之后的 3 个字符，那就需要计算一下结束索引值了,这个大家要思考一下哈。经常会因为没有算清楚导致计算错误的

```java
  // 结束索引应该是 index+4+3
  String newStr = str.substring(index+4,index+7);
```

##### 字符串开始和结束内容判断 startsWith/endsWith

- boolean startWith(String prefix)
- boolean endsWith(String suffix)

​		如果字符串以prefix开头或者suffix结尾，则返回true。

我们在电脑上经常会存放各种文件，这个时候就会有一个需求，根据文件名判断文件格式，比如是不是 word 文档。这个时候就要借助 endsWith 方法，`endsWith("字符串")`这个方法接受一个字符串参数，用于判断是否以该字符串结束的，所以返回类型是 boolean（布尔），我们根据返回值就可以判断了

```java
  public static void main(String[] args) {
    String fileName = "报告.doc";

    if(fileName.endsWith(".doc")){
      System.out.println("是word文档");
    }

  }
```

startsWith 和 endsWith 语法一致，不同的是 startsWith 判断的是文本开头是不是匹配内容。

比如说，我们想判断一个 网址是不是安全的地址，那么我们就可以使用 startsWith("https") 来判断

```java
  public static void main(String[] args) {
    String url = "https://www.youkeda.com";

    if(url.startsWith("https")){
      System.out.println("网址是安全的");
    }

  }
```

##### 字符串替换 replaceAll

-  String replaceAll(String replacement ， String destination)

文本替换是我们经常会遇到的需求，比如说把开头的文本中的 Java 换成 Python,这个时候就需要借助 replaceAll :`replaceAll("要替换的值","新值")` replaceAll 方法有两个字符串参数，第一个代表的是要替换的值，第二个代表的是新值，这个执行后会得到一个新的字符串（原始的字符串不会变哦）

```java
 public static void main(String[] args) {
    String str = "Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。";

    String newStr = str.replaceAll("Java","Python");

    System.out.println(newStr);
    System.out.println(str);
  }
```

> 大家可以仔细对比一下 newStr 是新的值，str 值并没有变化哦

其实除了文本替换外，还有一种作用是删除内容，我们只要将`新值`换成空格就可以了。比如我们想去掉文件的后缀名

```java
  public static void main(String[] args) {
    String fileName = "报告.doc";

    String name = fileName.replaceAll(".doc","");

    System.out.println(name);
  }
```

#### 6.4 字符串操作

##### 字符串分割 split

-  String[] split(String regex)

​		返回根据给定正则表达式的匹配字符串分开的数组。

很多时候，我们经常会处理有格式的文本数据，比如这样的

```java
姓名|年龄|性别
张三|20|男
李四|18|男
小花|18|女
```

多数时候处理这样的数据，会先把这种文本数据变成数组，每一行作为一条记录，从一个文本变成数组数据，那就需要 `split("分割字符串")`，注意这个分割字符串可以是字符串也可以是特殊的符号，比如说换行的符号是 `\n`(提醒一下换行符在文本文件里肉眼是看不见的),split 方法执行的结果是返回一个字符串数组对象，所以上面的内容改造成代码就可以是

```java
public static void main(String[] args){
  String text = "姓名|年龄|性别\n张三|20|男\n李四|18|男\n小花|18|女";

  // 使用 split 进行换行符的分割，得到一个新的数组对象
  String[] data = text.split("\n");

  // 因为第一行是标题不是数据，所以我们需要把长度-1
  // (注意要使用小括号包围，因为要先计算长度再组合字符串)
  System.out.println("共有:"+(data.length-1)+" 条记录");

}
```

我们还可以继续分割每一行的数据，这里要强调一下特殊字符的分割

> ```java
> .` `|` `*` 这三个字符如果作为分割符，那么就需要加上 `\\`,比如 `str.split("\\|")
> ```

```java
public static void main(String[] args){
  String text = "姓名|年龄|性别\n张三|20|男\n李四|18|男\n小花|18|女";

  // 使用 split 进行换行符的分割，得到一个新的数组对象
  String[] data = text.split("\n");

  // 因为第一行是标题不是数据，所以我们需要把长度-1
  // (注意要使用小括号包围，因为要先计算长度再组合字符串)
  System.out.println("共有:"+(data.length-1)+" 条记录");

  // 忽略第一行标题数据，所以我们把 i 设为1，从第二条记录开始
  for(int i=1;i<data.length;i++){
    // 使用 \\| 进行字符串分割，得到一个新数组对象
    String[] lines = data[i].split("\\|");
    System.out.println("姓名:"+lines[0]+" 年纪:"+lines[1]+" 性别:"+lines[2]);
  }


}
```

##### 大小写转化 toUpperCase/toLowerCase

- String toLowerCase()
- String toUpperCase()

返回一个新字符串。这个字符串将原始字符串中的大写字母改为小谢，或者将原始字符串中的所有小写字母改为大写。

很多时候为了统一格式输出，尤其是字母经常会统一大写或者统一小写，拼音一般会要求统一大写，所以这个时候，我们就需要借助 toUpperCase 方法，`toUpperCase()`方法没有参数，它的作用就是把字符中的字母全变成大写并且返回出新字符串数据

```java
  public static void main(String[] args) {
    String text = "ZhanSan";
    // 把拼音全部转化为大写字母
    String enName = text.toUpperCase();
    System.out.println(enName);
  }
```

> toLowerCase 和 toUpperCase 正好相反，用于把字符串改成全部小写字母，这里我们不演示了，大家可以把上面的例子代码改一改看看效果

##### 字符串连接 join

- String join(CharSequence delimiter , CharSequence ... element) 8

​		返回一个新字符串，用给定的定界符连接所有元素。

```java
String message = String.join("-", "Java", "is", "cool");
     // message returned is: "Java-is-cool"
```

##### 字符串比较 equals

- boolean equals(Object other)

  ​	如果字符串与other相等，返回true。

在 Java 中初学者经常会混淆一个概念，那就是两个字符串是否相同并不是用 `==`表达式，而是使用 `equals("被比较的字符串")` 方法

比如说：

```java
  public static void main(String[] args) {

    String text = "字符串";
    // 使用 equals 方法判断是否相同
    if (text.equals("字符串")) {
      System.out.println("equals 方法字符串相等");
    }
    // 前后顺序无所谓,下面代码是一样的
    if ("字符串".equals(text)) {
      System.out.println("equals 方法字符串相等");
    }
  }
```

> 在有些时候使用 == 运行结果也是成功的，那是因为 Java 的 jvm 编译做了优化，会把同一个代码块的字符串内容编译成一样的，为了避免出错，我们还是要求大家字符串是否相同判断必须用 equals 方法

##### 数字和字符串转化 Integer.parseInt

我们前面说过其实大多数情况下，原始数据都是字符串，但是显然我们是希望对字符串中的数字进行数学运用的，所以这个时候就遇到字符串转化数字或者数字转化字符串的情况。

在 Java 当中，我们可以使用 Integer 这个对象的 parseInt 方法进行处理，这个方法的作用就是让字符串变成数字

```java
  public static void main(String[] args) {
    String text = "123";
    // 转化字符串为数字
    int a = Integer.parseInt(text);
    System.out.println(a);

    // 转化字符串为数字
    a = Integer.parseInt("100");
    System.out.println(a);
  }
```

数字转化为字符串有两种方法，一种是之前运用的+，比如

```java
  public static void main(String[] args) {

    int a = 100;
    //使用空字符串相加数字，会自动变成字符串类型
    String str = ""+a;
    System.out.println(str);

  }
```

还有一种是使用 String.valueOf() 方法，valueOf 方法参数接受数字、浮点、布尔类型转化为字符串

```java
  public static void main(String[] args) {

    int a = 100;
    //使用valueOf强制把数字转化为字符串
    String str = String.valueOf(a);
    System.out.println(str);
  }
```

### <7> 创建对象

#### 7.1 Java 包管理器

##### 包（package）的导入

除了 String 字符串、int 数字类型、double 浮点类型，其实还有 LocalDate 日期类型(这是 Java8 版本才推出的)。我们为什么没有在前面介绍日期类型呢？这是因为 Java 体系非常庞大，为了管理更多的代码互不侵犯，所以采用一个叫 “包管理” 的机制来管理代码，简单来说就是把不同的 Java 代码放在不同的文件夹里，这个文件夹就是 “包（package）”。对于使用不同包的代码，得需要先导入这个包。

String、int、double、long 这些属于基础类型，所以不需要导入包。

在 Java 当中导入包的语句就是 `import 包名+类名;` ，包名+类名组成了完整的包路径。

> 注意这一句代码是在类文件的最前面哦

LocalDate 这个类的完整包路径是 `java.time.LocalDate`，在计算机磁盘里实际上就有这样的文件夹和文件 `java/time/LocalDate.java`

所有上面的代码应该是这样的

```java
import java.time.LocalDate;


public class DateTest {

  public static void main(String[] args) {
    // 得到当前的完整时间
    LocalDate now = LocalDate.now();
    // 打印出时间
    System.out.println(now.toString());
  }
}
```

> 注意，这里的 now() 方法执行后返回的当前程序所在计算机的系统时间，我们这里的计算机是由优课达提供的服务器，所以时间是服务器时间哦

我们也可以试一下没有 import 包的时候出现什么问题了

```java
public class DateTest2 {

  public static void main(String[] args) {

    // 得到当前的日期
    LocalDate now = LocalDate.now();
    // 打印出日期
    System.out.println(now.toString());

  }
}
Compilation error: Line 7 - 找不到符号
  符号:   变量 LocalDate
  位置: 类 DateTest2
```

相信你应该看到类似这样的错误了，当我们之后看见这样的错误，就有两种可能性：

- 1、类型写错了
- 2、类型没有 import（导入）包

我们可以继续深入一下这个 LocalDate 日期类

##### 日期时间和字符串的转化

细心的你应该会发现刚才时间输出的内容类似是这样的 `2019-06-13` 但是在有些时候，我们并不想看到这样格式的时间数据，我们平常更习惯的是看到这样的格式`年-月-日`变成 Java 语言的格式那就是 `yyyy-MM-dd` 这个格式和年月日分别是对应的哦。大家仔细看看

> 注意这个格式的字母是固定的，字母之外的字符是可以更换的哦

了解了格式之后，我们就需要利用这个格式来输出字符串了，我们还需要借助一个日期格式化类来帮助我们做格式化，这个类就是 `DateTimeFormatter`,它的完整包路径是 `java.time.format.DateTimeFormatter`,所以我们还是需要先 import（导入）一下，多个包的导入用换行就可以了每一行是一个 import 语句。那我们看一下代码是如何编写的

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class DateTest5 {

  public static void main(String[] args) {

    LocalDate time = LocalDate.now();
    // 打印默认的时间数据
    System.out.println(time.toString());

    // 创建一个格式化方式
    DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy年MM月dd");
    // 执行时间的格式化处理，得到期望格式的时间字符串
    String timeStr = df.format(time);
    // 打印时间
    System.out.println(timeStr);

  }
}
```

前面我们说过这个时间格式的字符串是可以更换的，比如说我们想要的时间是类似这样的`2019/06/01` 我们可以这样写

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class DateTest6 {

  public static void main(String[] args) {

    LocalDate time = LocalDate.now();

    // 创建一个格式化方式
    DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy/MM/dd");
    // 执行时间的格式化处理，得到期望格式的时间字符串
    String timeStr = df.format(time);
    // 打印时间
    System.out.println(timeStr);

  }
}
```

##### 获取日期时间具体的值

很多时候，我们想从一个日期里得到年份、月份、日、星期几等数据，这个怎么实现呢？我们看一下例子

```java
import java.time.LocalDate;

public class DateTest7 {

  public static void main(String[] args) {

    LocalDate time = LocalDate.now();

    // 得到当前时间所在年
    int year = time.getYear();
    System.out.println("当前年份 " + year);

    // 得到当前时间所在月
    int month = time.getMonth().getValue();
    System.out.println("当前月份 " + month);

    // 得到当前时间在这个月中的天数
    int day = time.getDayOfMonth();
    System.out.println("当前日 " + day);

    // 得到当前时间所在星期数
    int dayOfWeek = time.getDayOfWeek().getValue();
    System.out.println("当前星期 " + dayOfWeek);

  }
}
```

> 这里我们可以看到有些用 getValue()，有些没有.
>
> > getMonth() 和 getDayOfWeek() 方法的返回值不是具体的数字，而是一个对象（Java 官方的设计），所以必须用 getValue() 的到具体的数字。
> >
> > > 等大家 Java 能力提升后，可以自己查阅官方文档，学习细节。目前不用纠结具体返回什么对象

#### 7.2 时间日期类的运用

##### 字符串转化为日期时间

在前面我们把当前的时间打印出来，我们通过 `time.toString()` 这个方法的执行把 time 的数据变成了字符串，所以就会有一个方向的需求把字符串变成 LocalDate 类型，这种需求也是非常常见的，我们看一下如何完成

```java
import java.time.LocalDate;

public class DateTest8 {

  public static void main(String[] args) {
    // 定义一个时间字符串，日期是2019年1月1日
    String date = "2019-01-01";

    // 把字符串转化位 LocalDate 对象，并得到字符串匹配的日期
    LocalDate date2 = LocalDate.parse(date);
    // 打印出日期
    System.out.println(date2.toString());
  }
}
```

> 如上代码，`LocalDate.parse(date)` 这个 parse 方法可以把日期字符串转化为日期类型，注意这个字符串格式是 年-月-日 时:分:秒（英文格式是：yyyy-MM-dd HH:mm:ss）年是 4 位数字（yyyy），月是 2 位数字（MM），日是 2 位数字（DD），这个格式不能错哦，比如 2019 年 2 月 1 号就应该是`2019-02-01`而不是`2019-2-1`

如果日期字符串的格式不是 `yyyy-MM-dd`,那么就要借助 `DateTimeFormatter`,比如

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class DateTest81 {

  public static void main(String[] args) {
    // 定义一个时间字符串，日期是2019年1月1日
    String date = "2019/01/01";

    DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy/MM/dd");

    // 把字符串转化位 LocalDate 对象，并得到字符串匹配的日期
    LocalDate date2 = LocalDate.parse(date,df);
    // 打印出日期
    System.out.println(date2.toString());
  }
}
```

##### 时间日期的计算

很多时候，我们对日期时间避免不了计算，我们看几个生活场景

比如说预定酒店，2019 年 5 月 1 日入住，3 天后离店。从需求上可以看出，只要我们对日期的天数进行+3 的计算就可以完成了。LocalDate 类有一个 `plusDays(天数)` 方法用于执行天数的相加，这段代码如何实现呢

```java
import java.time.LocalDate;

public class DateTest9 {

  public static void main(String[] args) {

    LocalDate leaveTime = getLeaveTime("2019-05-01", 4);
    System.out.println(leaveTime.toString());
  }

  /**
   * 根据入住时间和入住天数得到离店时间
   *
   * @param checkInTime
   * @param days
   * @return
   */
  public static LocalDate getLeaveTime(String checkInTime, int days) {
    // 把字符串转化为 LocalDate 类型
    LocalDate time = LocalDate.parse(checkInTime);
    // 使用 plusDays 添加天数，得到新的时间
    LocalDate leaveTime = time.plusDays(days);
    return leaveTime;
  }

}
```

除了处理天数相加外，还可以处理其他的日期时间计算,我们整体看一下

```java
import java.time.LocalDate;

public class DateTest10 {

  public static void main(String[] args) {

    LocalDate now = LocalDate.now();
    System.out.println("当前：" + now.toString());

    System.out.println("加法运算");
    System.out.println("加1天：" + now.plusDays(1));
    System.out.println("加1周：" + now.plusWeeks(1));
    System.out.println("加1月：" + now.plusMonths(1));
    System.out.println("加1年：" + now.plusYears(1));

    System.out.println("减法运算");
    System.out.println("减1天：" + now.minusDays(1));
    System.out.println("减1周：" + now.minusWeeks(1));
    System.out.println("减1月：" + now.minusMonths(1));
    System.out.println("减1年：" + now.minusYears(1));

  }

}
```

> 日期时间计算的方法比较多，记不住没有关系，需要用的时候看看这段代码模仿一下就可以啦

##### 两个日期时间的判断

在日常工作中我们经常会对两个时间进行判断，比如说判断两个时间是否是同一天、一个日期是否在另外一个日期的前面或者后面，我们看一下对应的方法如何执行的

```java
import java.time.LocalDate;

public class DateTest11 {

  public static void main(String[] args) {

    LocalDate now = LocalDate.now();

    // 可以对两个 LocalDate 进行比较，
    // 可以判断一个日期是否在另一个日期之前或之后，
    // 或者判断两个日期是否是同年同月同日。

    boolean isBefore = now.minusDays(1).isBefore(LocalDate.now());

    System.out.println("是否在当天之前：" + isBefore);

    boolean isAfter = now.plusDays(1).isAfter(LocalDate.now());
    System.out.println("是否在当天之后：" + isAfter);


    // 判断是否是当天
    boolean sameDate = now.isEqual(LocalDate.now());
    System.out.println("是否在当天：" + sameDate);
  }

}
```

#### 7.3 面向对象-抽象

<img src="https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen Shot 2022-08-09 at 10.48.56 AM.png?raw=true" alt="Screen Shot 2022-08-09 at 10.48.56 AM" style="zoom:33%;" />

上图是一个简易版的户型图(房子对中国人都挺重要的，哈哈)，户型图确定了房子的构造和布局，开发商在卖楼之前会先公布户型图供客户了解并购买房子，到了该交付的时间，开发商会交付给业主房子，这个房子得和户型图是一致的，所以通过户型图是可以确定一个房子的完整信息

在 Java 中**对象**如上述的户型图一样，把房子设计成一个户型图就是**抽象**的过程。<img src="https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/hourse-design.svg?raw=true" alt="hourse-design" style="zoom:50%;" />

在 Java 面向对象中，我们可以把上述的抽象过程视为**面向对象**编程，在 Java 中一切皆对象，任何事物都可以抽象成一个 Java 对象，就像我们可以把房子抽象成户型图一样

> 当你理解了这个道理以后，我们可以在想想前面学习的 `LocalDateTime` 它就是抽象了时间而来的时间对象

##### 创建 House.java

我们用英文单词 House 代表上面的房子对象，现在我们看看如何创建 House 对象

我们在第一章的时候就了解到 Java 源码是由多个后缀名为 `java`的文本文件组成。在前面的课程中，我们其实也接触了很多 Java 类只不过是由系统创建的，现在我们开始尝试一下自己创建 Java 类。

创建 Java 类文件有四个规范需要遵守

- 文件名由`类名`+`.java`组成，比如说 HelloWord.java
- 类名遵循大驼峰命名法，就是首字母大写，另外类名里不能有中文和特殊字符哦（比如：&、#、@、* 等），只能是字母和数字。比如： HelloWord、Test、Test40
- Java 类内容遵守固定的格式

```java
public class 类名称 {

}
```

比如说 Java 文件是 House.java，那么文件内容是

```java
public class House {

}
```

- Java 类是存放在 Java 包中的，默认情况下 Java 工程中的代码是存放在 `src/main/java` 目录中，从这个目录开始才是包名开始的地方，这个是 Java 工程化推荐的目录结构。这点从字面上理解有点困难，大家可以直接看一下工程会更容易理解点。

看下图，创建类![Screen Shot 2022-08-09 at 11.00.36 AM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-09%20at%2011.00.36%20AM.png?raw=true)



点击新建类后，会出现对应的文件名输入框，输入 Java 文件名称就可以啦

![Screen Shot 2022-08-09 at 11.01.47 AM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-09%20at%2011.01.47%20AM.png?raw=true)

创建好文件，回车后会打开该文件，系统已经自动创建好Java文件

#### 7.4 面向对象-包

在本章开始，我们介绍了关于包 `package` 的概念,由于 Java 天生是面向企业级的编程语言，所以基于工程化的考虑，一般不会把所有的 Java 类都存放在默认的包下，这样文件会非常难于管理，一般我们开发的时候都会使用`package`来管理代码

##### 创建包和包下面的类

自定义包其实就是创建文件夹，包路径就是文件夹相对路径，比如说 `com.xxx.test` 这是一个包路径（注意包路径和子包路径直接使用`.`来做分隔），对应的文件路径就是 `src/main/java/com/xxx/test`,如果工程没有这个文件夹，就需要自己创建一下和创建文件一样，只是要大家多创建几个子文件夹哦。

![Screen Shot 2022-08-09 at 11.02.17 AM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-09%20at%2011.02.17%20AM.png?raw=true)

如果我们想创建 `com.xxx` 这个包，你可以一起输入

![Screen Shot 2022-08-09 at 11.02.57 AM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-09%20at%2011.02.57%20AM.png?raw=true)

> 现在我们说一下包名的规则，一般来说包名的开始是一个公司或者一个组织的域名的反写，如果是个人也可以遵守类似的规则，举个例子，优课达的域名是 `xxx.com`,那么包名的起始就是`com.xxx`,我们就需要创建`com/xxx`这样的两级目录。Java 的规范建议是用包管理代码

如果我们在某个包下创建 Java 文件，那么 Java 类的内容就需要多个一个声明包路径的语法

比如`com.xxx.test.Hello.java` 这样的 Java 类，我们可以分析一下，它的包名是

```java
com.xxx.test
```

类名称是`Hello`,创建好的类代码是这样的

```java
package com.xxx.test;


public class Hello {

}
```

正如你所见，我们多了一个 `package 包路径;`这样的语法，这个就是包的声明，注意这个语法，包路径是该 Java 所在的包目录。一个文件只有一个 package 语句，并且一般是在文件第一行

现在我们看一下视频如何完成创建包和类的



如上面视频，其实创建包和类非常容易的，下面的约定大家需要记住

```java
// Hello.java 的完整路径
com.xxx.test.Hello.java

// Hello.java 的完整路径第二种描述
// 省略了 .java 文件后缀名
com.xxx.test.Hello
```

当我们看到这样格式的时候，大家需要自己拆分一下包和类，然后去创建就好啦

##### 如何引入自定义的类

我们在第一节 Java 包管理的时候学习了 `import` 语句用于申明导入不同包的类对象，我们自己创建的类对象一样也有这个问题的。

比如 `House.java`,如果我们把这个类创建成

```java
com.xxx.model.House
```

上面的代码，你可以知道一个信息，House 对象的是存放在 `com.youkeda.model` 包里，那么我们如何 import 呢

```java
package com.xxx.test;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
//引入 House 类对象
import com.youkeda.model.House;

public class Hello {

}
```

正如你所见，不管是系统创建的还是我们自己创建的类对象，我们 import 的时候写上正确的完整类路径就可以了，就像

```java
import com.xxx.model.House;
```

import 语句得在 package 之后哦，这个顺序不能错了

#### 7.5 面向对象-属性/方法

<img src="https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/hourse-design.svg?raw=true" alt="hourse-design" style="zoom:50%;" />

设计师通过户型图展示了房子的特征和行为，这就可以表示一个房子信息了，我们可以再分析一下房子的情况：

##### 特征

- 颜色
- 卧室

##### 行为

- 打开水龙头
- 打开电灯

特征称为**对象属性**，而行为称为**对象方法**，完整的抽象过程分别是抽象对象名称、对象属性、对象方法。

##### 对象属性

我们先把房子的特征抽象成对象属性

```java
public class House {
    // 房子的颜色是绿色
    public String color = "green";
    // 房子的卧室有2间
    public int bedRooms = 2;
}
```

大家可以看看上面的代码，我们把在类中直接定义的变量称为对象属性，或者类属性

```java
public String color = "green";
```

这个和方法的变量不同点就是多了个 `public` 关键字，这个代表的是公共变量的意思

> 除了 public，还有 protected、private，以后我们还会介绍到

对象属性可以在定义的时候直接赋值，比如上面的`color = "green"`,我们默认房子的颜色为绿色

> 对象属性也可以不在定义的时候直接赋值，看功能的需要

##### 对象方法

我们把房子的行为抽象成 Java 类的方法

```java
public class House {
    // 房子的颜色是绿色
    public String color = "green";
    // 房子的卧室有2间
    public int bedRooms = 2;

    /**
     * 打开水龙头
     */
    public void runWater(){

    }

    /**
     * 打开电灯
     */
    public void turnLightsOn(){

    }
}
```

方法我们已经写过很多次了，大家仔细看看我们这里的方法有个区别，那就是没有 `static` 关键字了,有 static 的方法我们称为静态方法，没有 static 的方法叫对象方法，比如这里的

```java
/**
 * 打开电灯
 */
public void turnLightsOn(){

}
```

------

我们总结一下，对象属性和对象方法是面向对象的基础知识，当我们把对象名称、对象属性、对象方法都抽象出来，就算完成了面向对象的第一步：抽象。面向对象的语法上其实不难，主要难在于如何抽象，这个需要时间去消化的，我们后面还会课程继续介绍的。

#### 7.6 实例化对象

<img src="https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen Shot 2022-08-09 at 10.48.56 AM.png?raw=true" alt="Screen Shot 2022-08-09 at 10.48.56 AM" style="zoom:33%;" />

前面我们提到过户型图就像 Java 类一样，根据1个户型图是可以建造很多个房子的，这个建造房子的过程在 Java 当中就叫做对象实例化

实例有什么作用呢？

![hourse-my](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/hourse-my.svg?raw=true)

如上图，对于房子来说，咱们得知道谁是谁的房子。我们想要进入房子，就必须要先找到房子，找到房子才可以进入。

##### 实例化

在 Java 中实例化的语法其实很简单，以 `House` 为例

```java
//我的房子
House myHouse = new House();

//你的房子
House youHouse = new House();

//她的房子
House herHouse = new House();
```

仔细看一下上面的代码，在上面的代码中，我们根据 `House` 这个对象，实例化了3个房子分别是 myHouse、youHouse、herHouse。对象的属性和方法也只有实例化后才能被调用，就像我们刚才说的只有找到房子才能对房子进行操作，比如打开灯。

有了实例以后，现在我们如果想打开`你房子`的电灯，那么我们就可以执行

```java
youHouse.turnLightsOn();
```

如果想把她的房子颜色变成红色

```java
herHouse.color = "red";
```

正如我们知道房子是看得见、摸得着的物体，如果建造一个房子，那么就会土地盖楼。而在 Java 当中，实例化对象也是一样，会在 Java 内存中开辟一个存储空间来存储对象实例，这样才能确保每个实例是独一无二的、互不侵犯的，就如房子一样。

实例化这个好处就非常大了，就像开发商可以通过户型图来盖房子；而装修设计师也可以根据户型图来设计装修房间；一个户型图可以创建N个房子，重复利用的价值也非常大，对于 Java 对象来说，这个好处依然是存在的，一个类对象可以被实例化成多个实例，每个实例都可以被同样的方法、属性来操作，这样就具备了大规模系统工程化的能力。这个随着大家经验的增加而理解加深的，初期我们只要理解概念即可

##### 构造函数

我们还是要仔细解释一下实例化的细节，实例化的语法是

```java
new 构造函数();
```

很多学习Java 的人都给构造函数搞懵圈了，这个对于 Java 语言来说确实是最复杂的知识点了，实际上大家只要记住关键信息即可。你只需知道构造函数是其实一个比较特别的**对象方法**，具体表现在

1. 它的名称是和类名一模一样

   比如 House.java 这个类的构造函数名称就是 `House`，绝大多数情况下构造函数都是由 Java 系统自动创建的

2. 构造函数这个方法是没有返回值

   ```java
   public class House{
       //这就是默认的构造函数
       public House(){
       }
   
   }
   ```

3. 构造函数一般配合实例化一起使用的，你可以把构造函数当作类对象的初始化方法

请注意，构造函数是对象方法，所以也具备所有方法的能力，比如有参数、可以在方法里写代码逻辑

我们在后面还会继续学习构造函数，这里先有一个概念，因为实例化的背后就是执行了构造函数这个特定的对象方法

#### 7.7 构造函数

相信你现在对面向对象有了一些认识和理解，现在我们想优化一下 House，简化代码

##### 带参数构造函数

我们看一下下面的代码

```java
House myHouse = new House();
myHouse.color = "red";
```

我们如果创建多个 House 的实例，那么

```java
myHouse.color = "red";
```

就会显的特别冗余，那么这段代码，我们可以借助构造函数来实现代码的简化，实例化的时候就可以指定 color

我们可以看看 House 对象如何实现带参数的构造函数，我们在前面强调过构造函数就是对象方法，所以创建构建函数也非常简单

```java
public class House {
    // 房子的颜色是绿色
    public String color = "green";

    // 自定义一个带 color 参数的构造函数
    public House(String color){
      this.color = color;
    }
}
```

我们来看看上面的代码，大家会发现多了一个 `this`，实际这段构造函数代码的作用等同于之前的

```java
myHouse.color = "red";
```

`this` 和 `myHouse` 同等，也就是说 this 代表的是实例化后的对象

有了这个构造函数，我们就可以通过如下代码来实例化了

```java
House myHouse = new House("red");
```

##### 显示指定默认构造函数

这里有一点需要注意的是，如果在Java 类中定义了新的构造函数，那么默认的无参数构造函数就失效了。我们可以试试看

你应该看到如下的错误：

```java
./src/main/java/com/youkeda/action/HouseAction.java:8: 错误: 无法将类 House中的构造器 House应用到给定类型;
        House hourse = new House();
                        ^
  需要: String
  找到: 没有参数
  原因: 实际参数列表和形式参数列表长度不同
```

这就是默认的构造函数失效了，如果想让默认的构造函数生效，你可以再添加一个默认的

```java
public class House {
    // 房子的颜色是绿色
    public String color = "green";
    // 房子的卧室有2间
    public int bedRooms = 2;

    public House() {
        
    }

    // 自定义一个带 color 参数的构造函数
    public House(String color) {
        this.color = color;
    }
}
```

#### 7.8 ArrayList

掌握了对象的实例化后，我们其实能做的事情就非常多了，因为在 Java 的世界里，其实一切皆对象，只不过有些对象是 Java 自己创建的其他的就要我们自己来创建啦。比如我们所熟悉的 String、int、boolean 这些其实也都是由 Java 创建的对象。

> 有个特殊的点，需要大家了解一下 int、boolean 这个是编程语言的原生对象，实际上 Java 也有类似 String 这样的对象类型，int 的 Java 对象就是 Integer；boolean 的 Java 对象就是 Boolean；double 的 Java 对象是 Double。有 Java 对象和没有对象的区别在于有对象的默认值是 null，比如 int 的默认值是 0，但是 Integer 的默认值是 null；boolean 的默认值是 false，但是 Boolean 的默认值是 null。这两种写法是完全互通的，所以也不用太纠结这个，在有些需要用对象的地方用对象，否则就是用原生的。我们后面会用到

所以对象除了可以单独实例化，执行实例化的方法外，其实还可以作为方法的入参或者返回参数，因为从规范上来说，只要是对象都是允许的。现在我们还是通过案例来理解这个概念

假定文件夹 root 下有 N 个文件，现在我们遍历这些文件，并打印出文件名称。

> 由于 N 个文件的个数不确定，所以我们无法用数组来存储多个文件（因为数组的长度是事先确定的），这个时候我们就需要一个动态数组的方案来存储多个文件，这个动态数组在 Java 当中就是 `java.util.ArrayList` 对象

##### ArrayList 语法

ArrayList 本质上就是一个动态数组对象，可以方便的存储集合对象，一般来说我们会把同一个类型的数据存储在这个 ArrayList 里。我们如果要使用 ArrayList 就必须要先实例化，实例化的语法都是一样的，使用 new 关键字，并且需要指定对象类型

```java
// 这里的 Java 对象类型可以是任意的对象类型
// 比如 String、Integer、House 等
// 这里的 <> 是 Java 泛型的规范,记住这个语法就行了
ArrayList<Java 对象类型> list = new ArrayList<>();
```

> 注意一下，ArrayList 这个对象是存放在 `java.util`包下的，所以如果要使用它就需要先进行 import 完整的引入是`import java.util.ArrayList;`

##### add 方法

完成 ArrayList 实例化之后，就可以使用 ArrayList 的 `add` 方法进行数据的添加。我们看一下完成的例子

```java
import java.util.ArrayList;

public class ArrayListTest1{

  public static void main(String[] args){

    // 创建一个 ArrayList 存储字符串集合
    ArrayList<String> strs = new ArrayList<>();

    // 添加数据到 ArrayList 实例里
    strs.add("张三");
    strs.add("李四");

  }

}
```

##### get/size 方法

ArrayList 既然是动态数组那也就具备数组的特点：

- 可以获取长度 `size()`
- 可以根据索引获取具体的值 get(索引)，ArrayList 的索引是从 0 开始的

> 一般我们对索引的单词使用是 index

根据这两个特性也可以进行循环处理啦，大家可以回想一下 for 语句，我们改造一下上面的代码

```java
import java.util.ArrayList;

public class ArrayListTest1{

  public static void main(String[] args){

    // 创建一个 ArrayList 存储字符串集合
    ArrayList<String> strs = new ArrayList<>();

    // 添加数据到 ArrayList 实例里
    strs.add("张三");
    strs.add("李四");

    // 获取集合的长度
    int size = strs.size();

    // 使用 for 循环迭代每一条记录
    for(int i=0;i<size;i++){
       // 根据索引获取值，值的类型是 String
       String str = strs.get(i);
       System.out.println(str);
    }

  }

}
```

##### for 语句

实际上，如果在循环迭代集合的时候，我们还推荐另外一种写法

```java
import java.util.ArrayList;

public class ArrayListTest1{

  public static void main(String[] args){

    // 创建一个 ArrayList 存储字符串集合
    ArrayList<String> strs = new ArrayList<>();

    // 添加数据到 ArrayList 实例里
    strs.add("张三");
    strs.add("李四");

    // 获取集合的长度
    int size = strs.size();

    // 使用 for 循环迭代每一条记录
    for(String str : strs){
       System.out.println(str);
    }

  }

}
```

大家注意观察代码

```java
ArrayList<String> strs = new ArrayList<>();
for(String str : strs){
  System.out.println(str);
}
```

这个语法就是

```java
for( 集合变量的类型 变量名称 : 集合变量 )
```

在上面的例子中，我们的集合是字符串集合，所以我们使用的是

```java
for(String str : strs){
}
```

这种循环写法更方便，大家了解一下，和之前所学的 `fori`的区别在于，遍历集合的时候能否得到 `i` 值

```java
 for(int i=0;i<size;i++){
    // 根据索引获取值，值的类型是 String
    String str = strs.get(i);
    System.out.println(str);
 }
```

##### Map

![java-map1.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/java-map1.png?raw=true)

如上图，Map（映射）是遵循 key:value 这样的形式的集合。key、value 的类型可以是任何的 Java 对象。

我们大部分的情况下，都会使用 HashMap 这个 Map 的实现类。所以如果想得到一个 Map 的实例的话可以使用 HashMap

```java
import java.util.Map;
import java.util.HashMap;

// key value 得是 Java 类型
Map<key,value> map = new HashMap<>();
```

举个例子，我们把 1、2、3、4、5、6、7 这个数字映射为英文的星期，利用 Map 如何完成呢？

| key  | value     |
| ---- | --------- |
| 1    | Monday    |
| 2    | Tuesday   |
| 3    | Wednesday |
| 4    | Thursday  |
| 5    | Friday    |
| 6    | Saturday  |
| 7    | Sunday    |

首先我们可以使用 `map.put(key,value)` 这个方法完成数据的存储

由于 Map 的键和值都是 Java 对象类型，所以我们在实际创建的时候也需要指定对应的类型，上面的案例中 key 是数字类型：Integer，value 是字符串类型:String，所以我们可以用 `Map<Integer,String>`来表示，这也是关于**泛型**的用法

```java
// 实例化Map对象
Map<Integer,String> map = new HashMap<>();

map.put(1,"Monday");
map.put(2,"Tuesday");
map.put(3,"Wednesday");
map.put(4,"Thursday");
map.put(5,"Friday");
map.put(6,"Saturday");
map.put(7,"Sunday");
```

现在这个 map 实例已经包含了 7 条记录啦，我们完成了集合的存储。

如果我们想知道数字 3 对应的值，那么我们就可以使用 `map.get(key)`这个方法来获取啦

```java
String weekText = map.get(3);
System.out.println(weekText);
```

大家看一看，使用 Map 存储这种键值对的数据是不是很方便？

由于 Map 也是一种集合数据，所以也有集合大小的方法：`size()`和遍历能力`for`

比如上面的代码想要打印出集合大小

```java
int size = map.size();
System.out.println(size);
```

Map 的遍历相对麻烦一点，因为是 key：value 格式，所以我们一般先得到这个数据格式的集合（entrySet），完整的例子如下：

```java
 for (Map.Entry<Integer,String> entry : map.entrySet()){

   System.out.println("Key = " + entry.getKey() +
                  ", Value = " + entry.getValue());
 }
```

Map 的运用相对复杂一点，大家如果不是特别理解也没有关系，我们多练习几次，先习惯它的语法。

### <8> IM项目实战

#### 8.1 实战机器人对话

> 哇哦，你学到这里啦，恭喜你已经完成了 Java 语言的入门，学习编程我们总是在强调实战、练习，所以接下来我们需要大家多花点时间结合本课程的知识来完成项目实战。实战是最佳的运用手段，可以让我们对知识点进行总结和扩展

##### 项目介绍

本次项目我们来实现一下机器人聊天，这个聊天对话的对象是一个名叫`小Q`的人工智能机器人，它会根据我们发的内容自动回复一些消息。

需要大家利用本门课的知识来完成这个练习哦，当然为了让大家可以更好的进行编程，我们已经把项目工程环境准备好了,我们实现了机器人的服务。接下来我们来分步骤完成剩余的任务哦

我们这个项目工程是一个 Java Maven 工程，以后我们会学习到，这里我们能够运行就可以啦。

如果要运行代码，打开 `Application.java`文件，点击运行按钮。

##### 任务

###### 任务一：

在包路径 `com.youkeda.service` 下创建 `MessageService.java` 类

> 创建类不是仅仅创建一个空文件。画外音是需要**写完整**类的定义，包括 package、类名、甚至大括号 {}

###### 任务二：

在 MessageService.java 类中创建一个

```java
public RobotService robot = new RobotService();
```

类变量，用于调用机器人服务。

> 类变量的概念在接下来的课程中会学到。这里需要了解：
>
> > 类变量不包含在任何方法中；直接写在类的 **{}** 中；

###### 任务三：

在MessageService.java 对象中创建一个 `send()` 类方法用于接受消息，

> 所谓接受消息就是方法的参数，方法被其它类调用时，传入了参数值，即为收到了消息

并调用机器人进行消息的回复，调用完成后返回回复的消息。

> 机器人就是 RobotService，大家点击 RobotService.java 查看代码，会看到有一个 reply() 方法；
>
> > 调用 reply() 方法传入 send() 方法接受到的消息； reply() 方法的返回值就是回复的消息；

所以这个 `send()` 方法的参数也是一个 **字符串** ，返回参数也是 **字符串** 。

方法体里调用类变量 robot 执行 robot.reply 方法并返回 reply 执行的结果

###### 任务四：

打开 Application.java 文件，点击运行看看哦。

##### 总结一下

本项目用到了 Java 面向对象和 Java 网络知识，这在后面会继续.

