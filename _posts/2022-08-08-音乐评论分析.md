---
Layout: post
desc: 音乐评论分析
title:  音乐评论分析
tag:  study
---

### 1.1 项目介绍

#### 项目介绍

##### 前言

大家学习Java也有一段时间了，在这段时间的学习里，我们接触了Java的大部分知识，每天都会被很多同学催着更新课程，我们感到非常开心，今天就带大家来玩一把有趣的。

在实际开发过程中，在我们动手开发之前，都是由产品经理为我们（测试、前端、后端、项目经理等）先讲解一下需求，我们了解了需求之后，才开始一起来讨论技术方案。

#### 项目流程

![image.png](https://style.youkeda.com/img/ham/course/j12/2.1-1.svg)

我们自己实现一些小功能时同样需要讨论需求，也就是告诉别人我们为什么要做这个东西？或者我们想利用这款产品解决什么问题。

##### 一、项目需求

大家每天都离不开音乐，对大家来说，最走情怀的音乐平台是哪个？----- 对，网易云音乐！

![image.png](https://style.youkeda.com/img/ham/course/j12/1-2.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

在平时听歌时，我非常喜欢刷每一首歌的评论，这些评论往往句句扎心，从心底触动到我，比如这首歌

<<像我这样的人>>

![image.png](https://style.youkeda.com/img/ham/course/j12/1-3.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

这首歌的评论：

![image.png](https://style.youkeda.com/img/ham/course/j12/1-4.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

在评论中，最上面的是热门评论，我想知道每个歌手的歌曲评论中出现最频繁的词语是什么，如下图所示：

![zhoujielun.png](https://style.youkeda.com/img/ham/course/j12/1-8.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

从这些词语中，我们可以迅速了解评价的大概内容，留下一个初步的印象。统计词汇的过程，其实就是目前流行的大数据领域的一种应用。

##### 二、功能描述

###### 2.1 抓取单曲

采用爬虫+数据分析的方式，抓取指定歌手的热门单曲：

![image.png](https://style.youkeda.com/img/ham/course/j12/1-6.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

###### 2.2 抓取评论

可以看到张信哲的热门单曲有50首，我再抓取每一个首歌的热门评论：

![image.png](https://style.youkeda.com/img/ham/course/j12/1-7.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

###### 2.3 分词

我将热门评论记录内容，对评论用工具进行分词，然后按照词汇出现的频率，频率越高字体越大，呈现词云结果，最后的效果如下：

**张信哲**

![zhangxinze.png](https://style.youkeda.com/img/ham/course/j12/1-9.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

> 如果是其它歌手：

**邓紫棋**

![dengziqi.png](https://style.youkeda.com/img/ham/course/j12/1-10.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

**田馥甄**

![tianfuzhen.png](https://style.youkeda.com/img/ham/course/j12/1-11.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

##### 三、技术方案

我们把上面的需求梳理，整合成项目技术方案，如下列表所示：

1. 自动查询某个歌手的所有热门歌曲
2. 自动获取每一首歌的基础信息，专辑信息
3. 自动获取每一首歌的热门评论，最新评论
4. 对所有的热门评论进行统计形成词云

接下来我们一步步带领大家去实现上面的功能。

### 2.1 获取热门歌单

#### 热门歌单

##### 认识API

首先第一步，我们需求获取某个歌手的歌单信息。

查询某个歌手的歌单信息API描述信息如下：

| 信息描述 | 信息说明                                                     |
| -------- | ------------------------------------------------------------ |
| API地址  | [http://neteaseapi.youkeda.com:3000/artists?id=xxx](javascript:void(0)) |
| 请求方式 | GET                                                          |
| 参数说明 | id - 歌手ID                                                  |

从上面的API可以看出，如果我们有歌手ID，那我们便能够查询到歌手所有的单曲，比如：周杰伦在网易云音乐上的ID `6452`

那么我们组装成的`完整URL`为： http://neteaseapi.youkeda.com:3000/artists?id=6452

大家可以在浏览器中访问这个地址，我们可以看到返回的数据是Json格式，大致为：

```json
{
  "artist": {
    "img1v1Id": 109951163111191410,
    "topicPerson": 0,
    "alias": [
      "Jay Chou"
    ],
    "trans": "",
    "picUrl": "https://p1.music.126.net/ql3nSwy0XKow_HAoZzRZgw==/109951163111196186.jpg",
    "followed": false,
    "picId": 109951163111196200,
    "albumSize": 35,
    "briefDesc": "著名歌手，音乐人，词曲创作人，编曲及制作人，MV及电影导演。新世纪华语歌坛领军人物，中国风歌曲始祖，被时代周刊誉为“亚洲猫王”，是2000年后亚洲流行乐坛最具革命性与指标性的创作歌手，亚洲销量超过3100万张，有“亚洲流行天王”之称，开启华语乐坛“R&B时代”与“流行乐中国风”的先河，周杰伦的出现打破了亚洲流行乐坛长年停滞不前的局面，为亚洲流行乐坛翻开了新的一页，是华语乐坛真正把R&B提升到主流高度的人物，引领华语乐坛革命整十年，改写了华语乐坛的流行方向。",
    "musicSize": 488,
    "img1v1Url": "https://p1.music.126.net/o-FjCrUlhyFC96xiVvJZ8g==/109951163111191410.jpg",
    "name": "周杰伦",
    "id": 6452,
    "publishTime": 1516594084751,
    "picId_str": "109951163111196186",
    "img1v1Id_str": "109951163111191410",
    "mvSize": 8
  },
  "hotSongs": [
    ……
  ],
  "more": true,
  "code": 200
}
```

从返回结果中我们可以看出两个重要数据：

1. `artist` 是歌手的`歌单`（也叫“专辑”，这里统一称歌单）数据，里面包含了歌手信息，歌手名称，别名，简介，歌曲书，专辑数等

2. ```
   hotSongs
   ```

    

   值的格式是：

   ```
   []
   ```

   ，表示

   ```
   歌曲
   ```

   数据

   ```
   集合
   ```

   。一个歌单

   ```
   包含
   ```

   一组歌曲。每个

   ```
   歌曲
   ```

   有id，名称等属性。

   - 由于歌曲的属性字段太多，为了避免干扰就不列出来了。

##### 如何查询歌手ID

在网易云音乐中搜索歌手，进入歌手主页，如下图所示，链接中红框便是歌手ID

![歌手主页](https://style.youkeda.com/img/ham/course/j12/2-1.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

##### 开发阶段核心步骤

###### 1.需求分析

从以上对歌单数据的分析，我们可以得出关键模型（定义对象及其属性）是：

- `歌单`
- `歌曲`

要完成数据爬取，需要搭配的服务（定义操作、行为）是：

- 歌单服务`接口`
- 歌单服务`实现类`

> `模型+服务` 适合很多 Java 程序的场景，是一种通用的思路，这点务必要记住并学会应用。

本课程会带着大家一起循序渐进完成任务。大家必须在此过程中体会并总结，形成适合自己的思路、方法，这是最重要的。

###### 2.概要设计

概要设计阶段是完成 `模型+服务` 的整体结构。

这是一个比较经典的结构。以后大家在遇到复杂的场景时，区别只是需要设计更多的`模型`和更多的`服务`而已。

![设计图](https://style.youkeda.com/img/ham/course/j12/2-2-1.svg)

> 设计规范：

- `service` 包存放服务接口，其子包 `impl` 存放服务实现类。
- `model` 包存放模型。

###### 3.项目依赖

请看在 pom.xml 文件中添加依赖的写法：

```xml
<dependencies>
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>      
            <artifactId>okhttp</artifactId>
            <version>4.1.0</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>      
            <artifactId>fastjson</artifactId>
            <version>1.2.62</version>
        </dependency>
    </dependencies>
```

根据经验，预先添加必要的依赖库。当然也可以在项目开发过程中添加。

程序如果编译、运行出错，就有必要`检查`依赖库是否完整、正确。

### 2.2 模型设计

#### 歌单及歌曲模型详细设计

本节其实就是业务模型的详细设计。

回顾`周杰伦`的歌单（http://neteaseapi.youkeda.com:3000/artists?id=6452）数据：

大家可以在浏览器中访问这个地址，我们可以看到返回的数据是Json格式：

```json
{
  "artist": {
    "img1v1Id": 109951163111191410,
    "topicPerson": 0,
    "alias": [
      "Jay Chou"
    ],
    "trans": "",
    "picUrl": "https://p1.music.126.net/ql3nSwy0XKow_HAoZzRZgw==/109951163111196186.jpg",
    "followed": false,
    "picId": 109951163111196200,
    "albumSize": 35,
    "briefDesc": "著名歌手，音乐人，词曲创作人，编曲及制作人，MV及电影导演。新世纪华语歌坛领军人物，中国风歌曲始祖，被时代周刊誉为“亚洲猫王”，是2000年后亚洲流行乐坛最具革命性与指标性的创作歌手，亚洲销量超过3100万张，有“亚洲流行天王”之称，开启华语乐坛“R&B时代”与“流行乐中国风”的先河，周杰伦的出现打破了亚洲流行乐坛长年停滞不前的局面，为亚洲流行乐坛翻开了新的一页，是华语乐坛真正把R&B提升到主流高度的人物，引领华语乐坛革命整十年，改写了华语乐坛的流行方向。",
    "musicSize": 488,
    "img1v1Url": "https://p1.music.126.net/o-FjCrUlhyFC96xiVvJZ8g==/109951163111191410.jpg",
    "name": "周杰伦",
    "id": 6452,
    "publishTime": 1516594084751,
    "picId_str": "109951163111196186",
    "img1v1Id_str": "109951163111191410",
    "mvSize": 8
  },
  "hotSongs": [
    ……
  ],
  "more": true,
  "code": 200
}
```

##### 分析

第一层 `artist` 是歌单；第二层是歌单的各个数据字段。歌单以下字段比较有用：

| 字段      | 作用、含义                                                   |
| --------- | ------------------------------------------------------------ |
| id        | 歌单的唯一id                                                 |
| alias     | 别名。明星可能有各种名字，包括英文名、艺名等，所以这里是一组。 |
| picUrl    | 封面图。                                                     |
| briefDesc | 艺人介绍                                                     |
| img1v1Url | 正方形封面图。适合展示歌单列表等场景                         |
| name      | （艺人的）名称                                               |

当然，有可能你会觉得其它字段也比较有用需要抓取，没关系，也可以写到代码里。

并列第一层 `hotSongs` 是歌曲数据。歌曲的字段太多了，但比较有用的字段是：

| 字段 | 作用、含义   |
| ---- | ------------ |
| id   | 歌曲的唯一id |
| name | 歌曲的名称   |

##### 设计

在确定了需要的属性字段后，就可以完成模型图了：

![设计图](https://style.youkeda.com/img/ham/course/j12/2-2-2.svg)

###### 扩展知识点

Java 用来定义模型的类，叫 `POJO` （Plain Ordinary Java Object）类。

在《Java面向对象》课程第一章（`Java 面向对象`）第四节（`封装`）已经讲过对象封装的规范（不熟悉的同学可以复习一下）。在此基础上，没有业务逻辑、即不允许有增、删、改、查等`操作数据的方法`的类，叫作 `POJO` 类。

### 2.3 服务设计

#### 服务设计

服务的接口及其实现，组成了操作`数据`的核心能力。

所谓`数据`，就是上一节学习的 `POJO` 模型，那么服务就是为了完成业务逻辑。

##### 分析

###### 一、抓取

项目目标是提供抓取歌单的服务，给其它类调用，是一个通用能力，让具体的业务根据需要抓取歌单。那么就需要`抓取歌单`数据的方法。

- 既然是给其它类调用，那么应该定义成 `public`

- 这个方法不需要返回值，只是提供抓取功能，所以方法返回值定义为 `void`

- 方法的作用是开始执行抓取任务，可以命名为 `start` 。注意方法名一定要代表功能含义，让别人阅读时能理解是做什么的

- 方法的参数当然是

  ```
  字符串类型
  ```

  的歌单ID。本章第一节讲了，歌单其实是属于某位歌手的，所以这里命名为

   

  ```
  artistId
  ```

   

  。

  - 两个单词，第二个单词首字母大写。`Id` 是唯一的编号。

```java
  public void start(String artistId);
```

> 作为核心服务，必须具备良好的`扩展性`，能支持服务调用者抓取任意歌单，不能写死歌单ID。如此设计，服务就显得很灵活。

###### 二、歌单

抓取歌单的目的，是使用歌单。所以还需要提供查询方法`查询歌单`。方法的参数也是歌单ID。

```java
  public Artist getArtist(String artistId);
```

###### 三、歌曲

歌单中有很多歌曲，还可以提供一个`查询歌曲`的方法。虽然歌单模型中已经包含歌曲了，但是提供一个`通用`、`简单`、`易用`的方法也是有意义的。方法参数是 歌单ID和歌曲ID。

```java
  public Song getSong(String artistId, String songId);
```

##### 设计

在确定了需要的方法后，就可以完成模型图了：

![设计图](https://style.youkeda.com/img/ham/course/j12/2-2-3.svg)

###### 扩展知识

对于`服务实现`类，往往需要一个初始化实例变量的方法，这样做`扩展性`比较好。

请看代码：

```java
  private Map<String, Artist> artists;
  
  private void init() {
    artists = new HashMap<>();
  }
```

### 2.4 爬取歌单服务实现步骤一

#### 服务实现

大家可能体会到了，开发的过程是由大到小，由粗到细的过程。

架子已经搭好，接下来的任务是专注于业务逻辑的实现。

回顾服务详细设计图：

![设计图](https://style.youkeda.com/img/ham/course/j12/2-2-3.svg)

我们先来看上一节已经在核心服务中加好的 `start()` 方法。

##### start() 方法实现的整体思路

`SongCrawlerServiceImpl` 类的 `start()` 方法的作用是执行歌单的抓取。

但歌单爬取比较复杂，下列思路供大家参考：

![流程图](https://style.youkeda.com/img/ham/course/j12/2-2-4.svg)

- 在 `SongCrawlerServiceImpl` 类的 `start()` 方法中按顺序实现这些步骤，就实现了歌单的抓取操作；
- 封装为一个私有方法，是因为包含了一系列子步骤；
  - 因为这些方法不需要暴露给其他类调用的，所以用 `private` 修饰符；
  - 封装私有方法的核心目的，还是理顺思路，抽象出一个相对完整的步骤；
- 私有方法名及参数需要大家动脑筋想一想。

### 2.5 爬取歌单服务实现步骤二

#### 任务

本节完成 `SongCrawlerServiceImpl` 类的 `start()` 方法的第二步：

##### 2.构建填充了属性的 Artist 实例

![流程图](https://style.youkeda.com/img/ham/course/j12/2-2-4-2.svg)

###### 要求

- 参考流程图，在 `SongCrawlerServiceImpl` 类的 `start()` 方法中添加第一个私有方法。
- 在这个私有方法中，从第一步抓取的源数据对象中，解析 `artist` 数据字段，创建歌单对象并填充属性值。

可能需要回顾一下本章第一节的 API 返回的数据，特别要注意观察数据的格式哦。

###### 资料

在 《Java网络编程》课程中（[点击查看](https://learn.youkeda.com/j14)），讲解了 `JSON` 的知识，以及 `FastJSON` 和 `Okhttp3` 库的用法。不熟悉的话可以复习哦。

###### 注意

- `SongCrawlerTest` 系统已经提供了，会检查是否编译、运行正常哦。这个类大家不用改了。

- 每一节都是新的

  ```
  独立
  ```

  的任务，包括前面几节的任务在内的代码，都要补全、不要遗漏哦。

  - 如果出错，需要检查:
    - `依赖` 是否添加完毕，
    - 代码中必要的 `import` 是否有遗漏。

### 2.6 爬取歌单服务实现步骤三

#### 任务

本节完成 `SongCrawlerServiceImpl` 类的 `start()` 方法的第三步：

##### 3.构建一组填充了属性的 Song 实例

![流程图](https://style.youkeda.com/img/ham/course/j12/2-2-4-3.svg)

###### 要求

- 参考流程图，在 `SongCrawlerServiceImpl` 类的 `start()` 方法中添加第一个私有方法。
- 在这个私有方法中，从第一步抓取的源数据对象中，解析 `hotSongs` 数据字段，创建歌曲集合，并对每个歌曲对象填充其属性。

> 特别提醒：

请务必仔细观察歌单原始数据，`artist` 的值是一个对象，而 `hotSongs` 不是。对 `JSON` 数据格式及规范不熟悉的同学，请复习资料。

###### 资料

在 《Java网络编程》课程中（[点击查看](https://learn.youkeda.com/j14)），讲解了 `JSON` 的知识，以及 `FastJSON` 和 `Okhttp3` 库的用法。不熟悉的话可以复习哦。

###### 注意

- `SongCrawlerTest` 系统已经提供了，会检查是否编译、运行正常哦。这个类大家不用改了。

- 每一节都是新的

  ```
  独立
  ```

  的任务，包括前面几节的任务在内的代码，都要补全、不要遗漏哦。

  - 如果出错，需要检查:
    - `依赖` 是否添加完毕，
    - 代码中必要的 `import` 是否有遗漏。

### 2.7 爬取歌单服务实现步骤四

#### 任务

> 回顾爬取歌单数据的整体流程：

![流程图](https://style.youkeda.com/img/ham/course/j12/2-2-4.svg)

##### start() 方法

经过前三节的开发，已经完成了前三个步骤。

实际上，start() 更像是一个总装器，前三个步骤，实际上已经完成了歌单个歌曲对象，剩下的步骤，就是完成最后的装配。

###### 要求

- 完成最后两个小步骤。歌曲对象存入本地的数据仓库（Map类型的实例变量 `artists` ）

###### 资料

在 《Java网络编程》课程中（[点击查看](https://learn.youkeda.com/j14)），讲解了 `JSON` 的知识，以及 `FastJSON` 和 `Okhttp3` 库的用法。不熟悉的话可以复习哦。

###### 注意

- `SongCrawlerTest` 系统已经提供了，会检查是否编译、运行正常哦。这个类大家不用改了。

- 每一节都是新的

  ```
  独立
  ```

  的任务，包括前面几节的任务在内的代码，都要补全、不要遗漏哦。

  - 如果出错，需要检查:
    - `依赖` 是否添加完毕，
    - 代码中必要的 `import` 是否有遗漏。

### 2.8 查询歌单和查询歌曲服务实现

#### 任务

> 回顾服务详细设计图：

![设计图](https://style.youkeda.com/img/ham/course/j12/2-2-3.svg)

`SongCrawlerServiceImpl` 类最复杂的抓取歌单方法 `start()` 已经实现完毕。剩下的两个方法在本节中一起实现。

##### getArtist() 方法

歌单查询就比较简单了。

拿方法参数 `artistId` 从本地 `artists` 仓库中取出歌单即可。

##### getSong()

- 先通过第一个参数获取到歌单对象。
- 再遍历歌单中包含的歌曲列表，遇到 `id` 相等的歌曲，即可返回。

###### 资料

在 《Java网络编程》课程中（[点击查看](https://learn.youkeda.com/j14)），讲解了 `JSON` 的知识，以及 `FastJSON` 和 `Okhttp3` 库的用法。不熟悉的话可以复习哦。

###### 注意

- `SongCrawlerTest` 系统已经提供了，会检查是否编译、运行正常哦。这个类大家不用改了。
- 每一节都是新的`独立`的任务，包括前面几节的任务在内的代码，都要补全、不要遗漏哦。
- 如果出错，需要检查:
  - `依赖` 是否添加完毕，
  - 代码中必要的 `import` 是否有遗漏。

### 3.1 歌曲详细信息

#### 歌曲详情

通过上一章的学习，我们必须掌握：

- 阅读 `API` ，学会如何调用 `API`。
- 分析及设计`模型`、`服务`。
- 开发核心模型和服务的一般过程。

在本章中，我们继续利用 `API` 补全每首歌信息。

#### 本章目标

- 获取每首歌的详细信息包含：音乐文件地址、所在专辑、所属歌手
- 获取每首歌的热门评论和最新10条评论

#### 歌曲相关的 API

##### 1.获取每首歌的详细信息

| 信息描述 | 信息说明                                                     |
| -------- | ------------------------------------------------------------ |
| API地址  | [http://neteaseapi.youkeda.com:3000/song/detail?ids=xxx,xxx](javascript:void(0)) |
| 请求方式 | GET                                                          |
| 参数说明 | ids － 歌曲id，如果查询多个歌曲id之间用逗号隔开              |
| 测试例子 | http://neteaseapi.youkeda.com:3000/song/detail?ids=347230,347231 |

例子的数据内容太多了，这里就不贴出来了。自己观察可以看到，`ar`是所属歌手信息，`al`是所在专辑信息。

##### 2.获取每首歌的评论

| 信息描述 | 信息说明                                                     |
| -------- | ------------------------------------------------------------ |
| API地址  | [http://neteaseapi.youkeda.com:3000/comment/music?id=xxx&limit=xxx](javascript:void(0)) |
| 请求方式 | GET                                                          |
| 参数说明 | id － 歌曲idlimit － 评论条数                                |
| 测试例子 | http://neteaseapi.youkeda.com:3000/comment/music?id=186016&limit=1 |

注意：

如果看不懂 `URL` 中 `?`、`=`、`&` 等符号的含义，请复习《Java网络编程》课程

##### 3.获取每首歌的音乐文件地址

| 信息描述 | 信息说明                                                     |
| -------- | ------------------------------------------------------------ |
| API地址  | [http://neteaseapi.youkeda.com:3000/song/url?id=xxx,xxx](javascript:void(0)) |
| 请求方式 | GET                                                          |
| 参数说明 | id － 歌曲id，如果查询多个歌曲id之间用逗号隔开，注意`不是ids` |
| 测试例子 | http://neteaseapi.youkeda.com:3000/song/url?id=405998841,33894312 |

歌曲详情API和歌曲音乐文件地址API，支持多个歌曲id用逗号隔开，就意味着支持批量查询。

批量查询可以有效减少网络传输次数，提升性能和效率。

#### 模型设计

上一章中，我们主要完成了 `歌单` 的模型设计和服务，`歌曲`模型只是简单的设计了两个属性：`id` 和 `name` 。

模型的设计是跟具体场景和需求有关。上一章的需要主要针对的是歌单，歌曲的模型可以满足需求。

本章的重点是歌曲，需要获取每首歌的详情、评论、音乐文件地址，那么原来的歌曲模型就不能满足需求了，需要对歌曲模型进行`扩展`。

![设计图](https://style.youkeda.com/img/ham/course/j12/3-1-1-1.svg)

[点击查看完整版](https://style.youkeda.com/img/ham/course/j12/3-1-1.svg)

在这个设计中，与以往略有一点不同的是，`评论者`其实就是某位`用户`，所以评论者的类型是 `User` 。用户模型其实是非常通用的，因为一般来说用户可以做很多事情，跟很多模型都有关。

但是对于评论模型来说，为了准确表达用户在评论中的作用，实例变量的名称叫作 `commentUser` ，也就是说，变量名不一定要与其类型完全相同，根据场景，可以不一致，能清晰表达含义即可。

请看代码：

```java
public class Comment {

  private User commentUser;
  
  public User getCommentUser() {
    return commentUser;
  }

  public void setCommentUser(User commentUser) {
    this.commentUser = commentUser;
  }

}
```

### 3.2 服务设计

#### 服务设计

学完上一章的同学们应该可以意识到，继上一节完成歌曲模型的扩展后，本节就要完成歌曲服务相关接口和方法的设计了。

实际上，在抓取歌单的时候，已经抓取到歌曲相关的基础信息了。那么我们只需要在抓取过程中进行扩展，增加抓取歌曲详情、评论信息即可。

#### 服务设计

![设计图](https://style.youkeda.com/img/ham/course/j12/3-2-1-1.svg)

[点击查看完整版](https://style.youkeda.com/img/ham/course/j12/3-1-2.svg)

- 把原来 `start()` 方法里完成的抓取步骤，挪到 `initArtistHotSongs()` 中，作为歌曲和歌单初始化的方法。

- 增加三个装配方法：

  - `assembleSongDetail()` 组装歌曲的详细信息
  - `assembleSongComment()` 组装歌曲的评论
  - `assembleSongUrl()` 组装歌曲的音乐文件地址

- `start()` 方法的作为装配工，按顺序调用各个步骤：

  ![start方法流程图](https://style.youkeda.com/img/ham/course/j12/3-2-2.svg)

- `start()` 方法变化较大，相当于做了一次`重构`。

这样做的目的，是基于把`相对独立操作进行封装`的思想，实现歌单抓取的过程中把步骤封装成私有方法也是基础这个思想。

这么做的优点让代码`条理更清晰`、更容易理解、更易于维护。

`start()` 方法重构过程的示例，请看代码演示：

```java
  @Override
  public void start(String artistId) {
    // 参数判断，未输入参数则直接返回
    if (artistId == null || artistId.equals("")) {
      return;
    }

    // 执行初始化
    init();

    // 初始化歌曲及歌单
    initArtistHotSongs(artistId);
  }

  private void initArtistHotSongs(String artistId) {
    // 取得整体数据对象。
    Map returnData = getArtistObj(artistId);
    // 构建填充了属性的 Artist 实例
    Artist artist = buildArtist(returnData);
    // 构建一组填充了属性的 Song 实例
    List<Song> songs = buildSongs(returnData);
    // 歌曲填入歌单
    artist.setSongList(songs);
    // 存入本地
    artists.put(artist.getId(), artist);
 }
```

##### 扩展知识点

1. 什么是重构？

   在`不改变代码接口`的情况下，对代码作出修改，以改进程序的`内部结构`。本质上说，重构就是在代码写好之后`改进它的设计`。

2. 重构的目的？

   - 提高代码质量(性能、可读性、可重用性)
   - 修改Bug
   - 增加新功能

> 本次 `start()` 方法的重构，为了增加新的功能。
> 没有修改对外暴露的接口，只是修改了方法体内的实现。对其它调用者来说是`透明`

### 3.3 歌曲详情信息

#### 服务实现

模型和服务方法确定后，就到了实现的环节了。

在编码之前，大家可以先回忆一下爬取歌单的实现步骤。实际上无论是爬取歌单，还是将要爬取的歌曲信息、评论信息整体的过程是大体相似的：

![爬取过程简要流程图](https://style.youkeda.com/img/ham/course/j12/3-3-1.svg)

但是我们回忆一下歌曲详细信息的 API ：

| 信息描述 | 信息说明                                                     |
| -------- | ------------------------------------------------------------ |
| API地址  | [http://neteaseapi.youkeda.com:3000/song/detail?ids=xxx,xxx](javascript:void(0)) |
| 请求方式 | GET                                                          |
| 参数说明 | ids － 歌曲id，如果查询多个歌曲id之间用逗号隔开              |
| 测试例子 | http://neteaseapi.youkeda.com:3000/song/detail?ids=347230,347231 |

与歌单 API 不同的是，歌曲详情 API 中 `ids` 的值要复杂一些。

歌曲ID已经保存在歌单数据仓库 `artists` 中，那么我们就多了一个步骤：组装 `ids` 的值。

为了组装 `ids` 的值，我们就需要对歌单进行遍历操作，把歌曲ID一个个找出来。

##### 多个id值用逗号隔开

大家可以用字符串相加（`+`）的方式，把歌曲 id 与逗号拼接成一个字符串。

下面演示一种更加优雅的方式：

```
private void assembleSongDetail(String artistId) {
    Artist artist = getArtist(artistId);
    // 收集一个歌单中所有歌曲的id，放入一个list
    List<String> songIds = new ArrayList<>();
    List<Song> songs = artist.getSongList();
    for (Song song : songs) {
      songIds.add(song.getId());  
    }
    
    // 一个歌单中所有歌曲的id，组装成用逗号分割的字符串，形如：347230,347231。记住这个用法，很方便
    String sIdsParam = String.join(",", songIds);
  }
```

##### 方法重构

本节开头的过程分析中，识别了`与API无关的通用步骤`。

实际上我们已经写了 `private Map getArtistObj(String artistId)` 方法实现了这个步骤。但这个方法需要重构，使爬取歌曲详情时也可以复用，必须`避免重复代码`：

下面演示如何重构（重构前的代码注释掉了，大家可以比较一下前后差异）：

```
//private Map getArtistObj(String artistId) {
  private Map getSourceDataObj(String prefix, String postfix) {
    // 构建歌单url
    //String aUrl = ARTIEST_API_PREFIX + artistId;
    String aUrl = prefix + postfix;

    return null;//这一行仅演示，不要照抄哦
  }

  private void initArtistHotSongs(String artistId) {
    // 取得整体数据对象。
    //Map returnData = getArtistObj(artistId);
    Map returnData = getSourceDataObj(ARTIEST_API_PREFIX, artistId);
  }
```

（仅演示，为了效果，删除了一批无关的代码）

> 私有方法重构以后，要检查所有的调用代码，避免编译错误。

大家可以多看几遍，记住`动态演示`的修改点。

##### 小技巧：巧用 `Map`

调用歌曲详情 API 返回的结果中，歌曲存放在一个集合中，使用起来不方便。可以把源歌曲详情对象放在一个 Map 中，可以很方便的读取。

请看下面演示：

```java
private void assembleSongDetail(String artistId) {
    Artist artist = getArtist(artistId);
    List<String> songIds = new ArrayList<>();
    List<Song> songs = artist.getSongList();
    for (Song song : songs) {
      songIds.add(song.getId());
    }

    String sIdsParam = String.join(",", songIds);
    // 抓取结果
    Map songsDetailObj = getSourceDataObj(S_D_API_PREFIX, sIdsParam);
    // 原始数据中的 songs 是歌曲列表
    List<Map> sourceSongs = (List<Map>) songsDetailObj.get("songs");
    // 临时的 Map
    Map<String, Map> sourceSongsMap = new HashMap<>();
    // 遍历歌曲列表
    for (Map songSourceData : sourceSongs) {
      String sId = songSourceData.get("id").toString();
      // 原始歌曲数据对象放入一个临时的 Map 中
      sourceSongsMap.put(sId, songSourceData);
    }
    
    // 再次遍历歌单中的歌曲，填入详情数据
    for (Song song : songs) {
      String sId = song.getId();
      // 从临时的Map中取得对应的歌曲源数据，使用id直接获取，比较方便
      Map songSourceData = sourceSongsMap.get(sId);
    }
    
  }
```

### 3.4 歌曲评论及音乐文件

#### 服务实现

经过前面的几轮练习，大家对抓取信息的实现应该比较熟悉了。

如果你对整体流程不熟悉，再复习流程图和每节任务代码。

![爬取过程简要流程图](https://style.youkeda.com/img/ham/course/j12/3-3-1.svg)

##### API 是否支持批量参数的区别

必须注意的是，`歌曲详情API`、`歌曲文件API` 都是支持批量查询（id号用逗号分割的形式）的，而 `歌曲评论API` 不支持批量查询，这就导致抓取代码实现有所不同。

- 如果 `API` 支持批量查询，就要选调用API获取批量数据，再对歌曲进行循环遍历，解析出需要的源数据。

  > 批量查询的目的是 `减少远程网络请求次数`、`提高效率` 。

- 如果 `API` 不支持批量查询，就只能先对歌曲进行循环遍历，每次遍历都调用一次 `API` ，再解析数据。

  > 这么做效率相对较低。

所以，切勿每次遍历都调用一次**支持批量查询**的 *API* 。

下面演示 `歌曲评论API` 的过程中有什么不同：

```java
private static final String S_C_API_PREFIX = "http://neteaseapi.youkeda.com:3000/comment/music?id=";

private void assembleSongComment(String artistId) {
    Artist artist = getArtist(artistId);
    List<Song> songs = artist.getSongList();
    for (Song song : songs) {
      String sIdsParam = song.getId() + "&limit=5";
      // 抓取结果
      Map songsCommentObj = getSourceDataObj(S_C_API_PREFIX, sIdsParam);
      
    }
  }
```

具体的 ***评论API*** 地址及说明，请随时查阅 ***3.1*** 哦。

##### 方法重构

`重构` 又来了！

`歌曲详情API`、`歌曲文件API` 都支持批量查询，对应的 `assembleSongDetail()` 方法 、 `assembleSongUrl()` 方法，都需要组装 `xxxx,xxxx` 格式的参数。

我们先实现了 `assembleSongDetail()` 方法，再实现 `assembleSongUrl()` 方法时，就需要对组装批量参数的代码进行重构。

> 坚决抵制拷贝代码的行为，避免重复代码。

下面演示重构过程： 具体变化可对比之前的作业

```java
private void assembleSongDetail(String artistId) {
    Artist artist = getArtist(artistId);
    // 删除其它语句，保留必要的语句
    List<Song> songs = artist.getSongList();
    String sIdsParam = buildManyIdParam(songs);
    // 抓取结果
    Map songsDetailObj = getSourceDataObj(S_D_API_PREFIX, sIdsParam);
  }

  private void assembleSongUrl(String artistId) {
    Artist artist = getArtist(artistId);
    // 删除其它语句，保留必要的语句
    List<Song> songs = artist.getSongList();
    String sIdsParam = buildManyIdParam(songs);
    // 抓取结果
    Map songsFileObj = getSourceDataObj(S_F_API_PREFIX, sIdsParam);
  }

  private String buildManyIdParam(List<Song> songs) {
    // 收集一个歌单中所有歌曲的id，放入一个list
    List<String> songIds = new ArrayList<>();
    for (Song song : songs) {
      songIds.add(song.getId());  
    }
    // 一个歌单中所有歌曲的id，组装成用逗号分割的字符串，形如：347230,347231。记住这个用法，很方便
    String sIdsParam = String.join(",", songIds);
    
    return sIdsParam;
  }
```

### 4.1 制作图云

#### 图云

前面三章，我们完成了歌单信息的抓取。这一切都是为了最后一章做准备：制作图云。

![zhoujielun.png](https://style.youkeda.com/img/ham/course/j12/1-8.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

类似这种由关键词组成的图云，就是`词云`。词云的呈现形式是图片，在视觉上突出了关键词，效果非常好。

而关键词的来源，就是歌单中，每首歌的评论。

那么具体怎么做呢？

1. 对评论进行分词。例如：
   - 老子要听一辈子周杰伦 分词结果： `老子` / `要` / `听` / `一辈子` / `周杰伦`
   - 半夜听着周董的老歌，看着大家的评论，满满的回忆 分词结果：`半夜` / `听着` / `周董` / `的` / `老歌` / `看着` / `大家` / `的` / `评论` / `满满的` / `回忆`
2. 把分词以后的关键词出现次数进行统计，排序
3. 最后根据关键词的频率进行视觉显示

上述都是理论思路，但每一步其实都是很难的，涉及到非常多复杂技术，比如：词性标注，自然语言分析，歧义词分析，图片绘制，图文智能排版等。

需要大家都很强的`数学`、`数据结构`、`算法`功底，再用上几周、甚至几个月的时间才能理解。

那么，有没有更加简便和快速的办法实现词云呢？

答案是有的，使用别人写好的工具。

##### Kumo

在 `Java` 中，最常用的词云库为 `Kumo` 。github地址为：

https://github.com/kennycason/kumo

使用方式也比较简单，首先我们需要在 `pom.xml` 文件中引入相关的依赖。

```xml
<dependency>
  <groupId>com.kennycason</groupId>
  <artifactId>kumo-core</artifactId>
  <version>1.17</version>
</dependency>
<!-- 下面tokenizers是为了中文分词引入 -->
<dependency>
  <groupId>com.kennycason</groupId>
  <artifactId>kumo-tokenizers</artifactId>
  <version>1.17</version>
</dependency>
```

> 每个语言的分词词性和分词算法是不同的，所以需要单独引入中文分词：kumo-tokenizers 。

##### 服务设计

![类图](https://style.youkeda.com/img/ham/course/j12/4-1-1-1.svg)

[点击查看完整版](https://style.youkeda.com/img/ham/course/j12/4-1-1.svg)

- 在 `SongCrawlerServiceImpl` 中增加一个方法 `private void generateWordCloud(String artistId)` ，此方法被对外暴露的接口方法 `start()` 在最后一个步骤调用，爬取信息后接着制作词云。

##### 使用 Kumo

`Kumo` 的使用，学习起来也是要理解很多概念。我们已经为大家封装好了一个工具类：`WordCloudUtil` 。 `generateWordCloud()` 会调用到 `WordCloudUtil` 。

下列代码演示了如何调用 `WordCloudUtil` ：

```java
@Override
  public void start(String artistId) {
    
    generateWordCloud(artistId);
  }

private void generateWordCloud(String artistId) {
    Artist artist = getArtist(artistId);
    List<Song> songs = artist.getSongList();
    List<String> contents = new ArrayList<>();
    for (Song song : songs) {
      // 遍历歌曲所有的评论，包括普通评论和热门评论，把评论内容字符串存入 contents 集合  
    }
    
    // 调用方法，制作词云
    WordCloudUtil.generate(artistId, contents);
}
```

> `WordCloudUtil` 的具体代码，大家可以参照注释进行研究。但不是本课程的重点，主要学会调用即可。