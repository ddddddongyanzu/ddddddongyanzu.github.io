---
Layout: post
desc: 深入 SSM 框架
title:  深入 SSM 框架
tag:  study
---

## 深入 SSM 框架

### <1> MyBatis 入门



#### 1.1 MyBatis 简介



在当下 MyBatis 已经时最主流的持久层框架，具体一点就是操作数据库的框架；MyBatis 非常清凉，只需要通过简单的 XML 或者注解就可以完成数据映射和操作数据。



很多大公司（比如 阿里巴巴 ）都采用MyBatis 作为 Java 的持久层框架，主要原因在于它可以灵活地自定义SQL又兼具ORM框架的特性。



##### ORM 介绍

ORM 对象关系映射 （英语：Object Relational Mapping ，简称ORM，或 O/RM ，或 O/R mapping），是一种程序设计技术用于实现面向对象编程语言里不同类型系统的数据之间的转换。

![orm](/Users/dongyanzu/Desktop/orm.png)

ORM 把数据库映射成对象

```java
数据库的表（table) --> 类 (class)
记录(record 行数据) -> 对象(object)
字段(field) --> 对象的属(attribute)
```

有了 ORM 能力就可以很容易的把SQL对象变成 Java 对象了，这样开发效率就会大幅度提升，自定义SQL这个能力其实蛮重要的，尤其在互联网企业中，因为需要工程师能够更精细的掌控SQL，优化每一个SQL 语句。这也是MyBatis 能够超越其它框架在大厂被选用的重要原因。



在 Java 领域里所有的数据库框架都是基于 JDBC 的，这个是底层；如果能没有学过和了解过也没有问题，等你掌握了 Mybatis 再看 JDBC 也挺容易的。

> 绝大多数情况下只会面试的时候会问一些JDBC问题，但是实际工作很少直接打交道了

有了MyBatis，现在用Java操作数据库就非常简单啦，比如MySQL数据库。下面我们看看如何集成MyBatis 框架。



##### 集成 MyBatis

在Spring initalizr中创建一个MyBatis的工程（添加MyBatis，Web，SQL）



##### 注意事项

1. 添加 Spring Web 依赖
2. 添加 MyBatis Framework 依赖
3. 添加 MySQL Driver 依赖



如果你在现有的 SpringBoot 工程里即成，你可以直接在pom.xml里即成

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.2</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>


```

##### 配置 MySQL连接



配置好MyBatis 环境后，如果启动应该会提示报，因为SpringBoot 会自动加载数据库连接，所以这个时候你得需要配置一下datasource



##### 启动错误日志：

```shell
***************************
APPLICATION FAILED TO START
***************************

Description:

Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

Reason: Failed to determine a suitable driver class


Action:

Consider the following:
  If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.
  If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).
```

##### 配置数据源

在工程的 `application.properties`文件里，数据源配置 格式为：

```properties
spring.datasource.url = jdbc:mysql://mysql数据库地址:数据库端口/数据库名称？serverTimezone=GMT%2B8
spring.datasource.username=用户名
spring.datasource.password=密码
```

> 解释一下`serverTimezone=GMT%2B8`这个参数的作用在于设置数据库的时区为中国区域，这样查询出来的时候和我们平常的时间是一致的，药不然根据默认时区数据显示时间会相差8小时。

1. 配置前选择

这里有两种方法供大家选择



第一种：自己购买数据库



这里所有的数据都会存在自己的数据库中，并且新用户首年比较便宜。



在阿里云上购买RDS的操作对于新手来说比较复杂，我们在这里介绍：



推荐的是阿里云的云翼计划，可以点击下面的入口快速进入页面，后续的操作在阿里云上完成。



> 注意我们购买的数据库版本是8.0，不要购买过时的5.7版本哦。



##### 如何配置自己的数据库

在购买完成之后，我们就要搭建自己的数据库了。



> 注意在配置数据库时，需要将字符集选择为utf8mb4，而不是utf8;



第二种：用课的服务器搭建数据库



参考我们的《MySQL》，启动MySQL服务后，创建名为`comment`的数据库：

```SQL
CREATE DATABASE comment;
```

2. 配置写法

工程的`application.properties`文件里添加数据源的配置为



```properties
spring.datasource.url=jdbc:mysql://192.168.0.1:3306/comment?serverTimezone=GMT%2B8
spring.datasource.username=root
spring.datasource.password=
```

> 平台上启动MySQL服务都是专属的，所以不需要密码。

如上面的配置，仔细看看，在自己的工程把连接改成自己的数据库地址，这个配置如果正确的话，那么就可以成功的启动应用了。





#### 1.2 实战评论组建概要设计

想要利用 MyBatis 操作数据库，除了数据源之外我们还需要继续完成配置。



为了更好的理解配置过程，我们还是根据案例来分解，这次我们开发一个通用的文章评论组建，如下。

> 评论组建还是有不少难度的，遇到想不明白的时候希望大家多多思考。

评论产品

![comments](/Users/dongyanzu/Desktop/comments.png)



添加评论

![reply2](/Users/dongyanzu/Desktop/reply2.png)



回复评论

![reply](/Users/dongyanzu/Desktop/reply.png)



##### 概要设计



从软件工程设计的角度来说，我们希望对所有的产品先做模型设计，然后再看数据库的设计。



所以我们需要先分析一下评论这个产品的模型，大家也可以对照产品设计稿思考一下，有哪些功能，功能的元素有哪些。

![comments-1](/Users/dongyanzu/Desktop/comments-1.svg)

通过分析，我们可以发现，这里有三个大的功能点：

- 用户登录
- 写评论
- 回复评论

现在我们可以开始抽象对象，设计领域模型，大致能够得出需要一个用户模型和评论模型这两个模型



> 这里有一个难点那就是回复评论这个动作，我们得需要设计一个Tree结构才能满足数据存储。当多个人回复同一条评论A的时候，我们可以把回复的评论当作评论A的子，这样就形成了Tree结构了。

现在我们设计一下领域模型，大家可以看一下，以后遇到类似的场景也可以这么设计

![comments-uml](/Users/dongyanzu/Desktop/comments-uml.svg)

由于评论组件可以运用在很多地方，比如文章，笔记，博客等等，所以我们需要关联到某一个主键上，也就是这里的`refId`



在Comment模型里，我们添加了一个`children`字段并且设定类型为`List<Comment>`，这个字段存储所有该评论被回复的数据。



通过这个领域的设计，我们确定了这个可以满足产品的需求，那么我们就可以开始设计表结构了。



> 为什么要先设计模型，因为模型是为了产品而设计的，但是表设计并不是面对对象的设计思路，所以直接设计表很有可能不满足需求了，



##### 数据库设计



通过模型我们来设计一下表结构，为了满足上述的模型，我们得需要设计两个表`user、comment`

![comment-er](/Users/dongyanzu/Desktop/comment-er.svg)

如上面的表关系，这里有三个字段需要大家仔细思考一下

- `ref_id`一般字符串的主键或者外键我们都是设置`varchar(32)`，这是一种约定
- `user_id`
- 我们在Comment.java模型里面关联了User对象，但是在数据库表中，我们只需要做一个主键字段关联即可。
- 一般来说`user_id`这种写法就说明关联的是`user`表的主键，这是一种约定。

- `parent_id`
- 我们在Comment.java模型里设计了children字段来包含所有的子评论，但是在数据库表中，我们只需要做一个父主键就可以了，因为实际查找数据的时候，是通过父找子的。

> 如果对数据模型和表结构不理解，可以先继续学习下去，通过编码来消化这个设计方案。以后类似的场景都可以这样先设计，比如说菜单，企业的通讯录等等，其实微信公众号的评论也是类似这样的。

具体字段信息看下面的表结构

user表

| 表字段       | 字段类型     | 允许Null | 字段描述                        |
| ------------ | ------------ | -------- | ------------------------------- |
| id           | bigint       | 不允许   | 自增主键                        |
| user_name    | varchar(20)  | 不允许   | 用户名，20位长度已经足够了      |
| pwd          | varchar(32)  | 不允许   | 密码                            |
| nick_name    | varchar(20)  | 允许     | 昵称                            |
| avatar       | varchar(200) | 允许     | 头像,url长度有点长，设置200长度 |
| gmt_created  | datetime     | 不允许   | 创建时间                        |
| gmt_modified | datetime     | 不允许   | 修改时间                        |

comment表

| 表字段       | 字段类型      | 允许Null | 字段描述             |
| ------------ | ------------- | -------- | -------------------- |
| id           | bigint        | 不允许   | 自增主键             |
| ref_id       | varchar(32)   | 不允许   | 关联外部内容的主键   |
| user_id      | bigint        | 不允许   | 关联用户表主键       |
| content      | varchar(1000) | 不允许   | 评论内容，最长1000字 |
| parent_id    | bigint        | 允许     | 父评论ID             |
| gmt_created  | datetime      | 不允许   | 创建时间             |
| gmt_modified | datetime      | 不允许   | 修改时间             |



#### 1.3 MyBatis 映射对象



请继续围绕着评论组件这个目标前进。既然我们已经完成了工程数据库的连接、表结构的创建，现在我们来看一下如何完成MyBatis工程的配置。



##### DO 对象规则



所有的ORM框架都需要有一个 Java 对象来映射数据的表，并且是意义对应的，一般我们把这类对象称为`DO`对象，对象名称的规范是`表名+DO`



user表对应的类对象名称就是`UserDO`；comment表对应的类对象名称就是`CommentDO`

> 如果你的表名称是类似`ykd_user`这种格式的，你可以使用`UserDO`或者`YKDUserDo`（不过多数情况下，我们使用前面的`UserDo`)



##### DO 对象包规则



一般情况下企业都会把这个`DO`对象存放在`xxx.xxx.dataobject`包下，所以`DO`就是dataobject的缩写。



现在评论组件的包约定是`com.youkeda.comment`,那么对应的`DO`包就是

```
com.youkeda.comment.dataobject
```

##### DO 对象数据类型



DO对象和普通的POJO类并无不同，唯一要注意的点是属性类型要和数据库类型进行匹配，这个是`JDBC`制定的规范，常用的数据类型映射如下

| JDBC类型（数据库字段类型） | Java数据类型 |
| -------------------------- | ------------ |
| VARCHAR                    | String       |
| TEXT                       | String       |
| INTEGER                    | int          |
| DOUBLE                     | double       |
| BIGINT                     | long         |
| DATETIME                   | Date         |

当然还有其他的数据类型，不过其他数据类型在互联网架构中我们一般并不推荐使用，所以就不列举了。



> 注意默认情况下，数据库的日期类型对应的是Java的`java.util.Date`对象

##### 创建DO对象



现在我们来吧user表，映射为

`UserDO`

表结构在前面：



| 表字段       | 字段类型     | 允许Null | 字段描述                        |
| ------------ | ------------ | -------- | ------------------------------- |
| id           | bigint       | 不允许   | 自增主键                        |
| user_name    | varchar(20)  | 不允许   | 用户名，20位长度已经足够了      |
| pwd          | varchar(32)  | 不允许   | 密码                            |
| nick_name    | varchar(20)  | 允许     | 昵称                            |
| avatar       | varchar(200) | 允许     | 头像,url长度有点长，设置200长度 |
| gmt_created  | datetime     | 不允许   | 创建时间                        |
| gmt_modified | datetime     | 不允许   | 修改时间                        |

UserDO对象

根据数据类型的转化类型，我们写出下面的`UserDO`类

```java
package com.youkeda.comment.dataobject;

import java.time.LocalDateTime;

public class UserDO {

    private long id;

    private String userName;

    private String pwd;

    private String nickName;

    private String avatar;

    private LocalDateTime gmtCreated;

    private LocalDateTime gmtModified;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPwd() {
        return pwd;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }

    public String getAvatar() {
        return avatar;
    }

    public void setAvatar(String avatar) {
        this.avatar = avatar;
    }

    public LocalDateTime getGmtCreated() {
        return gmtCreated;
    }

    public void setGmtCreated(LocalDateTime gmtCreated) {
        this.gmtCreated = gmtCreated;
    }

    public LocalDateTime getGmtModified() {
        return gmtModified;
    }

    public void setGmtModified(LocalDateTime gmtModified) {
        this.gmtModified = gmtModified;
    }
}
```

#### 1.4 MyBatis DAO



在 Java 工程化中，我们一般会把数据层的服务称为`DAO`层，DAO层会包含对数据库操作的接口和实现类。



MyBatis 很强悍的地方在于只需要定义接口就可以完成数据的增删改查，接口开发是Java经常采用的方式。为什么可以只需要定义接口就完成数据处理？这个问属于比较深层次的，MyBatis框架在背后做了很多动态处理的行为，我们在以后可以逐步去掌握它的底层。还是那句老话，先熟练运用。



##### 创建DAO层

以评论组件为例，我们可以先创建包。

`com.youkeda.comment.dao`

##### 定义 DAO 接口

继续以`user`表为例，我们创建一个`UserDAO`这样的接口

> 注意需要放在dao包里

```java
package com.youkeda.comment.dao;

import org.apache.ibatis.annotation.Mapper;

@Mapper
public interface UserDAO {


}
```

这个接口的特殊性在于接口需要添加一个`@Mapper`的注解，当然别忘记`import`



`import org.apache.ibatis.annotation.Mapper`



##### 引用 DAO

当我们完成 MyBatis DAO 的定义后，Spring 启动的时候会自动加载这个接口并动态创建一个 Spring Bean，所以我们只需要按照Spring Bean 的方法完成资源注入。

现在我们创建一个`UserController`用于处理用户的`Web`服务。

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

}
```

#### 1.5 MyBatis 查询

我们在之前的小节中，利用了SQL语句插入了一条用户记录。如果我们想查询`user`表的所有数据，我们可以执行

`select * from user`

在 MyBatis中，最强大的地方就在于和`SQL`语句天然集成的，也就是在我们完成前面的步骤，接下来的操作就是补充SQL就完事了。

1. 添加接口方法

```java
package com.youkeda.comment.dao;

import org.apache.ibatis.annotations.Mapper;
import UserDO;
import java.util.List;

@Mapper
public interface UserDAO {

    public List<UserDO> findAll();

}
```

如上，我们新增了一个`findAll`的方法



`public List<UserDO> findAll();`



查询多条记录的时候，请使用`List`作为返回类型；如果查询所有记录，方法名称一般定义为`findAll`



2. 添加`@Select`注解

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface UserDAO {

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

}
```

`@Select`注解的完整包路径是

```JAVA
org.apache.ibatis.annotation.Select;
```

3. API 测试

> 现在DAO层完成开发了，我们可以在controller里进行测试一下服务，可以写一个API来完成测试。

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class UserController {

  @Autowired
  private UserDAO userDAO;

  @GetMapping("/users")
  @ResponseBody
  public List<UserDO> getAll() {
    return userDAO.findAll();
  }

}
```



我们可以看到API输出到值，`userName、nickName、gmtCreated、gmtModified` 这四个字段并没有数据显示，这是因为这四个字段在 `user` 表的名称都是采用`_`做分隔的，比如 `userName` 对应的 user 表字段是`user_name`，由于 MyBatis 转化对象的时候是按照名称一一对应的，表字段和DO字段名称不一致的时候，数据就会映射失败了。

我们有一个简单的办法完成数据映射，那就是使用 SQL 的别名，我们改造一下 SQL 语句

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface UserDAO {

  @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
  List<UserDO> findAll();

}
```

#### 1.6 MyBatis 插入

下面是我之前我们的插入SQL语句

> 由于user.id是自增主键，所以这里我们并没有对ID主键设定值。

```sql
INSERT INTO user
  (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
VALUES(
  'admin',
  'admin',
  '管理员',
  'https://cdn.v2ex.com/gravatar/ykdadmin?s=80&d=identicon',
  now(),
  now()
)
```

在MyBatis中同样支持插入，你可以使用``@Insert`注解

> Insert注解的完整包路径是`org.apache.ibatis.annotations.Insert`

不过我们还是按照顺序来完成插入方法的实现。

> 大家在写代码的时候，请记住编写顺序，这点非常重要，因为可以避免很多意外的情况。代码有些时候还是比较容易一碰就散。

1. 添加接口方法

我们新增了一个 insert 方法

```java
int insert(UserDO userDO);
```

insert 方法介绍



执行SQL插入语句的时候，会返回插入行数，一般成功是返回1，所以我们设置返回类型为int。

> 如果想要判断插入是否成功就可以通过`返回值>0`来判断咯

Java 一切皆对象，插入数据的时候，我们一般都是直接传递数据对象，比如这里的UserDO对象，所以insert方法定义了`UserDO userDO`参数，完整的代码如下：

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface UserDAO {

  int insert(UserDO userDO);

  @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
  List<UserDO> findAll();

}
```

2. 添加@Insert注解

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface UserDAO {

  @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
  int insert(UserDO userDO);

  @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
  List<UserDO> findAll();

}
```

如上，仔细看看代码，会发现我们改造了SQL语句，我们把value值换成了`#{变量名}`这种格式，这个就是MyBatis获取动态值的一种方式，执行的时候会自动从上下文参数（这里的上下文就是userDO）里获取这个变量名的值。

```java
VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
```

比如 `#{userName}`实际上就是执行`userDO.getUserName()`这个方法来获取`userName`变量值，MyBatis会自动更新生成正式的SQL语句渠道数据库里执行，这就完成了动态数据存储。



3. API测试

> 现在controller里进行测试一下服

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class UserController {

  @Autowired
  private UserDAO userDAO;

  @GetMapping("/users")
  @ResponseBody
  public List<UserDO> getAll() {
    return userDAO.findAll();
  }

  @PostMapping("/user")
  @ResponseBody
  public UserDO save(@RequestBody UserDO userDO) {
    userDAO.insert(userDO);
    return userDO;
  }

}
```

> 一般数据插入我们都使用POST请求，同时使用JSON方式传递数据，为了接受JSON参数，需要在参数中添加`@RequestBody`注解

4. 查看主键值

看了上面的返回值，应该会发现输出的内容里并没有刚刚插入的主键值，很多时候我们是需要知道这个值的。



我们可以在`@Insert`注解上继续添加一个`@Options`主键，Options的完整包路径是

`org.apache.ibatis.annotations.Options`

我们看一下完整的代码

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Options;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface UserDAO {

  @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
  @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
  int insert(UserDO userDO);

  @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
  List<UserDO> findAll();

}
```

Options 注解有三个参数

- userGeneratedKeys

> 设置为true，代表允许数据库自增主键

- keyColumn

> 设置表的主键字段名称，一般都是`id`

- keyProperty

> 设置`DO`模型的主键字段，一般都是`id`

现在我们可以继续执行一下API调用，你会发现JSON输出的时候有包含id值了。



MyBatis开发有很多时候，就是要记住这个配置，所以得多加练习。



#### 1.7 Mybatis修改

修改表内容也是非常常见的操作，我们继续按照步骤来看MyBatis如何实现修改数据



1. 接口方法



修改和保存其实很类似，所以我们定义了`update`方法：



```java
int update(UserDO userDO);
```

由于 SQL 执行更新语句的时候，会返回影响的行数，所以我们的方法的返回类型设置为 int



和 insert 一样，我们设置update方法参数为UserDO的对象，最后完成的DAO代码是

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) " +
            "VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int insert(UserDO userDO);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

    int update(UserDO userDO);
}
```



2. `@Update`注解

现在我们可以再完善 SQL 语句了，我们使用@Update注解，可以仔细看看`@@Update`注解的运用



```java
@Update("update user set nick_name=#{nickName}",gmt_modified=now() where id=#{id})
```

这里，我们只修改了`nick_name`字符，并且根据`id`主键来执行`update`

> 从现在开始，请大家记住任何的数据修改，都需要同步修改`gmt_modified`字段，这样就可以清楚地知道数据在上面时候被修改了。



完整的代码如下：

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) " +
            "VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int insert(UserDO userDO);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();


    @Update("update user set nick_name=#{nickName},gmt_modified=now() where id=#{id}")
    int update(UserDO userDO);
}
```

3. API测试

我们提供了一个update api 来测试数据修改

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @PostMapping("/user")
    @ResponseBody
    public UserDO save(@RequestBody UserDO userDO) {
        userDAO.insert(userDO);
        return userDO;
    }

    @GetMapping("/users")
    @ResponseBody
    public List<UserDO> getAll() {
        return userDAO.findAll();
    }

    @PostMapping("/user/update")
    @ResponseBody
    public UserDO update(@RequestBody UserDO userDO) {
        userDAO.update(userDO);
        return userDO;
    }

}
```

#### 1.8 MyBatis 删除



MyBatis 删除就非常简单了，我们继续三步骤



1. 接口方法

一般删除都是根据主键来删除的，所以这里我们定义了一个delete方法



```java
int delete(long id);
```

由于 SQL 助兴删除语句的时候，会返回删除的行数，所以我我们的方法返回类型设置为 int



MyBatis除了可以支持 DO 对象传递参数之外，还可以接受普通参数，比如String , int , long 之类的。为了能够在SQL语句中完成普通参数解析，我们还需要对参数增加一个注解`@param`,这样继续改进delete方法。



```java
public interface UserDAO {

		int delete(@Param("id") long id);
}
```

@Param 的完整包路径是

`org.apache.ibatis.annotations.Param`



为了简化包的依赖，我们可以直接使用

`import org.apache.ibatis.annotations.*`

这样，我们就不需要额外导入MyBatis的相关包依赖了，完整的代码如下：

```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) " +
            "VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int insert(UserDO userDO);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

   
    int delete(long id);
}
```

2. `@Delete`注解

现在我们嗯可以在完善SQL语句了，大家可以仔细看看`@Delete`注解的运用

```java
@Delete("delete from user where id=#{id}")
```

> 请注意：#{id} 中的 id 要和 @Param("id") 中的 id 一样哦，如果我们定义的是 @Param("key") 那么 SQL 语句就得是

```java
@Delete("delete from user where id=#{key}")
```

> **@param('key')这个用法在以后运用的还是比较多的，因为它可以实现自定义上下文参数，非常实用方便。**

完整的代码如下：



```java
package com.youkeda.comment.dao;

import UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    @Insert("INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified) " +
            "VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int insert(UserDO userDO);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

    @Delete("delete from user where id=#{id}")
    int delete(@Param("id") long id);
}
```



3. API 测试

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @PostMapping("/user")
    @ResponseBody
    public UserDO save(@RequestBody UserDO userDO) {
        userDAO.insert(userDO);
        return userDO;
    }

    @GetMapping("/users")
    @ResponseBody
    public List<UserDO> getAll() {
        return userDAO.findAll();
    }

    @GetMapping("/user/del")
    @ResponseBody
    public boolean delete(@RequestParam("id") Long id) {
        return userDAO.delete(id) > 0;
    }

}
```

为了验证删除成功，我们使用

```java
return userDAO.delete(id) > 0;
```

通过返回值是否大于0，判断删除是否成功



#### 1.9 MyBatis 简单查询

数据查询是我们做的最多的事情，以用户登录为例，我们会从数据库里根据用户名来查询这条记录，这个和之前的findAll就不一样了。



下面实现：



##### 设计接口方法

```java
public interface userDAO {
	UserDO findByUserName(@Param("userName") String name);
}
```

`findByUserName`方法通过传递自定义参数`userName`来获取`UserDO`数据



##### @SELECT 注解



通过用户名获取用户记录的SQL其实很简单



`select * from user where user_name=? limit 1`



为了防止数据意外，所以我们需要添加`limit 1`确保只取出一条数据。现在结合`@Select`注解来看看



```java
public interface UserDAO {
	@Select("select id , user_name as userName ,pwd ,nick_name as nickName , avatar , gmt_created as gmtCreated ,gmt_modified as gmtModified from user where user_name=#{userName} limit 1")
	UserDO findByUserName(@Param("userName") String name);
}
```

##### API测试一下



现在完成了DAO层开发后，我们继续用API测试一下

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
public class UserController {

  @Autowired
  private UserDAO userDAO;

  @PostMapping("/user")
  @ResponseBody
  public UserDO save(@RequestBody UserDO userDO) {
    userDAO.insert(userDO);
    return userDO;
  }

  @GetMapping("/users")
  @ResponseBody
  public List<UserDO> getAll() {
    return userDAO.findAll();
  }

  @GetMapping("/user/del")
  @ResponseBody
  public boolean delete(@RequestParam("id") Long id) {
    return userDAO.delete(id) > 0;
  }

  @PostMapping("/user/update")
  @ResponseBody
  public UserDO update(@RequestBody UserDO userDO) {
    userDAO.update(userDO);
    return userDO;
  }

  @GetMapping("/user/findByUserName")
  @ResponseBody
  public UserDO findByUserName(@RequestParam("userName") String userName) {
    return userDAO.findByUserName(userName);
  }

}
```

### <2>MyBatis XML语句

#### 2.1 MyBatis XML配置

​	在当下，很多时候业务需求还是比较复杂的，我们上一章学习使用注解执行SQL的方式还是不够的，多数情况下企业还是喜欢用XML来执行SQL。这也是MyBatis推荐的方式，因为XML更灵活，并且可以执行逻辑判断，这正是我们锁需要的能力。

> 不管是XML还是注解方式，MyBatis底层执行原理都是一样的，所以我们继续在之前的工程基础上进行改造。

由于XML是比较复杂的，所以我们还是希望可以一步一步的进行拆解开发，请大家记住这些关键步骤。



上一章中我们已经完成了MyBatis的基础配置，想要使用MyBatisXML，首先得在`application.properties`文件中，添加配置`mybatis.mapper-locations`这个配置用于指定MyBatis Mapper XML文件路径，一般来说这个路径和DAO 的包路径一致，所以我们的配置应该是：

```java
mybatis.mapper-locations=classpath:com/youkeda/comment/dao/*.xml
```

当我们配置好后，系统启动的时候，MyBatis 框架会自动扫描工程下的指定的路径，并完成这个路径下所有 XML 文件的加载（`*`会匹配所有，正则表达式中的通配符）。

> 一般我们都会把代码之外的文件存放在resource文件目录里，所以上面配置对应完整的文件路径是

`src/main/resources/com/youkeda/comment/dao/`



##### 补充说明

当然，如果有多个路径，也可以使用`,`隔开添加多个,比如：

```xml
mybatis.mapper-locations=classpath:com/youkeda/dao/*.xml,classpath:com/youkeda/comment/dao/*.xml
```

#### 2.2 MyBatis XML Mapper



现在我们继续改造工程，请大家记住一个约定，一个DAO类对应一个DAO.xml 文件（当然也有些企业把 DAO 命名为Mapper），比如`UserDAO.java`会对应`UserDAO,xml`



`UserDAO.xml`文件路径存放在 resources 目录下，根据前一节，我们知道这个文件存放在

```xml
src/main/resources/com/youkeda/comment/dao/UserDAO.xml
```

1. 头信息

创建完xml文件后，先需要复制下面的内容，这个是固定格式的：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
```

2. mapper 根节点

有了头信息后，我们继续添加 mapper 节点，比如

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">


</mapper>
```

> 注意顺序不能错乱，xml格式很讲究顺序的。

如上，mapper这个节点有一个属性`namespace`这个是命名空间的含义，一般就是我们这个mapper所对应的DAO接口的全称，比如我们这里的`UserDAO`



XML 配置容易出错，记住规则即可。



3. resultMap

resultMap 用于处理表和 DO 对象的属性映射，确保表中的每个字段都有属性可以匹配。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

  <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
    <id column="id" property="id"/>
    <result column="user_name" property="userName"/>
  </resultMap>

</mapper>
```

如上，resultMap 节点在 mapper 根节点内，记住这个顺序。解释一下这个节点：

- id

> 唯一标示，一般我们的命名规则是`xxxResultMap`，比如这里的`userResultMap`，基于这样的规则就能保证唯一了。

- type

> 对应的 DO 类完整路径，比如这里的`com.youkeda.comment.dataobject.UserDO`

3.1 resultMap 子节点

resultMap 还有子节点，最主要的是`id、result`这两个子节点

- id

> 设置数据库主键字段信息，column属性对应的是表的字段名称，property对应的是DO属性名称

- result

> 设置数据库其它字段信息，column属性对应的是表的字段名称，property 对应的是 DO属性名称

现在我们写个完整的resultMap

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

  <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
    <id column="id" property="id"/>
    <result column="user_name" property="userName"/>
    <result column="pwd" property="pwd"/>
    <result column="nick_name" property="nickName"/>
    <result column="avatar" property="avatar"/>
    <result column="gmt_created" property="gmtCreated"/>
    <result column="gmt_modified" property="gmtModified"/>
  </resultMap>

</mapper>
```

有了 resultMap ，我们在上一节中查询使用的别名`user_name as userName`这种写法就不用了。





#### 2.3 MyBatis XML Insert 语句



现在我们继续来了解一下 MyBatis XML 实现 insert 功能，为了和之前的注解区分，我们新增了一个 add 方法。



```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {
	int add(UserDo userDO);
}
```

现在我们需要打开UserDAO.xml 文件添加 insert 语句



```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

 <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
    <id column="id" property="id"/>
    <result column="user_name" property="userName"/>
    <result column="pwd" property="pwd"/>
    <result column="nick_name" property="nickName"/>
    <result column="avatar" property="avatar"/>
    <result column="gmt_created" property="gmtCreated"/>
    <result column="gmt_modified" property="gmtModified"/>
  </resultMap>

  <insert id="add" parameterType="com.youkeda.comment.dataobject.UserDO" >
    INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
    VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
  </insert>

</mapper>
```

我们仔细看看，在mapper节点下添加了`insert`节点，它有两个属性

- id

> 同 DAO 类的方法名，有一个 xml 内是要唯一的，比如这里的`id=add` 是和 `UserDAO.add`是一致的

- parameterType

> 这个用于传递参数类型，一般是和`UserDAO.add`方法的参数类型一致的，可以仔细看看我们的add方法 `int add(UserDo userDO)`

`id、parameterType`这两个属性，在后面的`update、delete、select`语句中都有，记住就好。



insert 节点内的代码就是和我们之前在注解里面使用的SQL一样的。



现在我们改一下API的方法调用



```java
@PostMapping("/user")
@ResponseBody
public UserDO save(@RequestBody UserDO userDO) {
	userDAO.add(userDO);
	return userDO;
}
```

如果我们想同时获得插入的主键id值，你还需要配置`useGeneratedKeys、keyProperty`，这和之前注解的`@Options`介绍的一样

```xml
<insert id="add" parameterType="com.youkeda.comment.dataobject.UserDo" useGeneratedKeys="true" keyProperty="id">
   INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
    VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
</insert>
```

#### 2.4 MyBatis XML Update/Delete 语句

##### update

继续完成 MyBatis XML Update 能力，和之前其实都差不多，知识把`insert`换成了`update`，MyBatis XML的语法还是比较容易理解的，因为基本上都是字面含义。



我们可以先把`UserDAO.update`方法的`@Update`注解去掉。



```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    int add(UserDO userDO);

    int update(UserDO userDO);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

    @Delete("delete from user where id=#{id}")
    int delete(@Param("id") long id);

    @Select("select id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified  from user  where user_name=#{userName} limit 1")
    UserDO findByUserName(@Param("userName") String name);

}
```

然后我们完善一下UserDAO.xml，添加`update`节点

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

    <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
        <id column="id" property="id"/>
        <result column="user_name" property="userName"/>
        <result column="pwd" property="pwd"/>
        <result column="nick_name" property="nickName"/>
        <result column="avatar" property="avatar"/>
        <result column="gmt_created" property="gmtCreated"/>
        <result column="gmt_modified" property="gmtModified"/>
    </resultMap>

    <insert id="add" parameterType="com.youkeda.comment.dataobject.UserDO" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
        VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
    </insert>

    <update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
        update user set nick_name=#{nickName},gmt_modified=now() where id=#{id}
    </update>

</mapper>
```

##### delete 

继续完成 delete.xml语句的编写，我们还是先改造DAO

```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    int add(UserDO userDO);

    int update(UserDO userDO);

    int delete(@Param("id") long id);

    @Select("SELECT id,user_name as userName,pwd,nick_name as nickName,avatar,gmt_created as gmtCreated,gmt_modified as gmtModified FROM user")
    List<UserDO> findAll();

    @Select("select * from user where user_name=#{userName}")
    UserDO findByUserName(@Param("userName") String name);

}
```

然后修改xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

    <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
        <id column="id" property="id"/>
        <result column="user_name" property="userName"/>
        <result column="pwd" property="pwd"/>
        <result column="nick_name" property="nickName"/>
        <result column="avatar" property="avatar"/>
        <result column="gmt_created" property="gmtCreated"/>
        <result column="gmt_modified" property="gmtModified"/>
    </resultMap>

    <insert id="add" parameterType="com.youkeda.comment.dataobject.UserDO" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
        VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
    </insert>

    <update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
        update user set nick_name=#{nickName},gmt_modified=now() where id=#{id}
    </update>

    <delete id="delete">
        delete from user where id=#{id}
    </delete>

</mapper>
```

注意，这里的`delete`节点并没有配置parameterType 属性，这是因为

```java
int delete(@Param("id") long id)
```

这个`delete`方法的参数是由`@Param`注解组成，默认情况下，MyBatis会把这类数据当成`Map`数据来传递，而MyBatis默认的`parameterType`类型就是`Map`所以省略不写。



#### 2.5 MyBatis XML Select 语句

通过前面的几次开发，我们应该对 MyBatis XML 有一点感觉了，我们再总结一下基于 XML 模式的开发顺序



1. 创建 DO 对象
2. 创建 DAO 接口 ，配置`@Mapper`注解
3. 创建 XML 文件，并完成`resultMap`配置
4. 创建 DAO 接口方法
5. 创建对应的XML语句



请记住这个顺序，MyBatis的开发难点就是于此，因为相对细节很多，如果不按照顺序开发，很容易顺线莫名其妙的错误，切记！



现在我们来看一下最后的 xml 语句：select



我们还是先改一下 UserDAO 的方法

```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserDAO {

    int add(UserDO userDO);

    int update(UserDO userDO);

    int delete(@Param("id") long id);

    List<UserDO> findAll();

    UserDO findByUserName(@Param("userName") String name);

}
```

然后，我们编写 xml 文件，这次我们新增两个 select 语句

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.youkeda.comment.dao.UserDAO">

    <resultMap id="userResultMap" type="com.youkeda.comment.dataobject.UserDO">
        <id column="id" property="id"/>
        <result column="user_name" property="userName"/>
        <result column="pwd" property="pwd"/>
        <result column="nick_name" property="nickName"/>
        <result column="avatar" property="avatar"/>
        <result column="gmt_created" property="gmtCreated"/>
        <result column="gmt_modified" property="gmtModified"/>
    </resultMap>

    <insert id="add" parameterType="com.youkeda.comment.dataobject.UserDO" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO user (user_name, pwd, nick_name,avatar,gmt_created,gmt_modified)
        VALUES(#{userName}, #{pwd}, #{nickName}, #{avatar},now(),now())
    </insert>

    <update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
        update user set nick_name=#{nickName},gmt_modified=now() where id=#{id}
    </update>

    <delete id="delete">
        delete from user where id=#{id}
    </delete>

    <select id="findAll" resultMap="userResultMap">
        select * from user
    </select>

    <select id="findByUserName" resultMap="userResultMap">
        select * from user where user_name=#{userName} limit 1
    </select>

</mapper>
```

我们仔细看看这个select语句

```xml
<select id="findByUserName" resultMap="userResultMap">
  select * from user where user_name=#{userName} limit 1
</select>
```

**注意**这里我们多使用了一个属性`resultMap`这个值我们一般配置为该XML文件下的`resultMap`节点的id值，比如这里的`userResultMap`

MyBatis通过`resultMap`完美的解决了额外的数据映射问题。



现在我们完成**模糊查找用户**的功能，可能通过用户名去查找用户或者通过用户昵称查用户。



首先需要创建一个 DAO 方法，接收`userName、nickName`两个参数

```java
List<UserDO> query(@Param("keyWord")String keyWord);
```

因为这里匹配到的用户可能会很多，所以我们方法的返回类型是 List

请自行开发完 XML 语句,然后你可以使用

```java
@GetMapping("/user/query")
```

来进行测试，得使用SQL的like语法。

```xml
<select id="query" resultMap="userResultMap">
        select * from user where user_name like CONCAT('%', #{keyWord} ,'%')
        or nick_name like CONCAT('%' , #{keyWord} , '%')
    </select>
```



### <3> MyBatis 动态SQL

#### 3.1 MyBatis XML 条件语句

掌握了 MyBatis XML 的基础能力后，我们开始学习XML的增强功能，或者说这也是再解释为什么我们使用MyBatis XML 方案。



##### if 语句

```xml
<update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
  update user set nick_name=#{nickName},gmt_modified=now() where id=#{id}
</update>
```

比如上面的SQL语句，如果`nickName`为`NULL`，这样修改就会出问题了，因为我们都知道`nickName`字段不应该为`NULL`的。



所以`update`语句里，我们一般会结合条件语句来执行的。

```xml
<update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
  update user set
   <if test="nickName != null">
    nick_name=#{nickName},gmt_modified=now()
   </if>
   where id=#{id}
</update>
```

通过这个`if`语句，我们就可以对数据提前做判断，从而确保数据不会因为错误而丢失。

> 注意，有了逻辑语句以后，仔细两个字段间的`,`不要漏掉了。当然 MyBatis 还是比较强大的，也会有一些纠错行为。执行SQL错误的时候，就需要我们仔细检查检查了。

##### set语句

在上面的update语句中，如果nickName为null，SQL会变成

```SQL
update user set where id=?
```

这是错误的SQL语句。



在实际开发中，我们一般会结合set语句来编写update语句

```xml
<update id="update" parameterType="com.youkeda.comment.dataobject.UserDO">
  update user
  <set>
    <if test="nickName != null">
      nick_name=#{nickName},
    </if>
    <if test="avatar != null">
      avatar=#{avatar},
    </if>
    gmt_modified=now()
  </set>
   where id=#{id}
</update>
```

任何情况下，修改操作一定更新gmt_modified时间，就可以避免所有列值都为null时引起SQL语法错误。



并且，使用`<set>`语句，系统会自动取出最后一个逗号（`,`），而不用担心到底哪个列才是最后一个。

> update语句修改多个列是很常见的情况

这样就可以笔钱出现问题了



##### if+select

除了上面的这种案例，if语句也可以用于查询语句等，很多时候我们的查询条件都是动态的，比如下面的例子；我们想模糊查找某个时间后注册的用户。

```java
List<UserDO> search(@Param("keyWord")String keyWord,
      @Param("time")LocalDateTime time);
```

SQL XML 文件如下

```xml
<select id="search" resultMap="userResultMap">
  select * from user where
    <if test="keyWord != null">
      user_name like CONCAT('%',#{keyWord},'%')
        or nick_name like CONCAT('%',#{keyWord},'%')
    </if>
    <if test="time != null">
      and  gmt_created <![CDATA[ >= ]]> #{time}
    </if>
</select>
```

> `>=、<、<=、>=、&`这类的表达式会导致MyBatis解析失败，所以我们需要使用`<![CDATA[key]]>`来包围住。

由于这里的参数是LocalDateTIme，我们学习过Http的知识应该知道，URL传递过来的参数都是字符串类型的，所以这里的API调用有点特殊

```java
package com.youkeda.comment.control;

import com.youkeda.comment.dao.UserDAO;
import com.youkeda.comment.dataobject.UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @GetMapping("/user/search")
    @ResponseBody
    public List<UserDO> search(@RequestParam("keyWord") String keyWord,
    @RequestParam("time")
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    LocalDateTime time) {
        return userDAO.search(keyWord, time);
    }
}
```

如上面的代码所示，我们在`LocalDateTime time`这个参数里还额外增加了`@DatetimeFormat`注解，这个注解是由Spring提供的，用于把字符串参数转化为日期类型。

```java
org.springframkework.format.annotation.DateTimeFormat
```

DateTimeFormat 支持我们自定义日期数据格式，一般我们建议使用`yyyy-MM-dd HH:mm:ss`这个我们在 Java入门的时候已经学习过了，所以想要正确的接受日期，url的参数值不能写错

```java
time=2020-01-01 00:00:00
```

这个数据格式必须要遵守



##### where

上面例子的SQL查询语句在实际运行的时候会有两种例外



1. keyWord 为 null，SQL会变成

```SQL
select * from user where and gmt_created >= ?
```

变成错误的SQL

2. keyWord、time 都为null，SQL 会变成

```SQL
select * from user where
```

这也是错误的SQL



我们前面说过MyBatis XML 是有纠错能力的，这个时候我们建议把SQL中where改成MyBatis XML 的where 子句，就可以解决这种非常常见的问题

```xml
<select id="search" resultMap="userResultMap">
  select * from user
   <where>
      <if test="keyWord != null">
          user_name like CONCAT('%',#{keyWord},'%')
            or nick_name like CONCAT('%',#{keyWord},'%')
      </if>
      <if test="time != null">
        and  gmt_created <![CDATA[ >= ]]> #{time}
      </if>
   </where>
</select>
```

继续优化模糊查找用户的功能，我们把时间改成开始和结束，查找这个时间段内注册的用户

```java
List<UserDO> search(@Param("keyWord")String keyWord,
      @Param("startTime")LocalDateTime startTime,
      @Param("endTime")LocalDateTime endTime
      );
```

补充说明

MyBatis XML 条件语句还有

- choose
- when
- otherwise
- trim

这几个相对来说用的会少一些，如果有这种需求可以看一下MyBatis 中文文档。



#### 3.2 MyBatis XML 循环语句

在实际开发中，经常会遇到批量插入的需求，MyBatis 可以很好的支持这个，只需要使用foreach语句就可以满足了。



比如批量插入 user ，我们先创建 DAO 方法。

```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.time.LocalDateTime;
import java.util.List;

@Mapper
public interface UserDAO {

    int batchAdd(@Param("list") List<UserDO> userDOs);

}
```

我们来看一下`foreach`语法

```xml
<insert id="batchAdd" parameterType="java.util.List" useGeneratedKeys="true" keyProperty="id">
	INSERT INTO user(user_name,pwd,nick_name,avatar,gmt_created,gmt_modified)
	VALUES
	<foreach collection="list" item="it" index="index" separator=",">
		(#{it.userName},#{it.pwd},#{it.nickName},#{it.avatar},now(),now())
	</foreach>
</insert>
```

`foreach`相当于执行了 Java 的 for 循环，它有几个属性

-  collection 指定集合的上下文参数名称，比如这里的list，对应的是`@Param("list")`
- item指定遍历中的每一个数据的变量，一般我们用it命名，所以就可以使用`it.userName`这种获取具体的值了
- index集合的索引值，从0开始
- separator 遍历每条记录并添加分配符

上面的SQL最终执行会变成

```
INSERT INTO user (user_name,pwd,nick_name,avatar,gmt_created,gmt_modified)
		VALUES
		(?,?,?,?,now(),now()),
		(?,?,?,?,now(),now()),
		(?,?,?,?,now(),now())
```

MyBatis 会自动优化最后一个`,`确保SQL是正确的。

> 批量插入在实际工作场景中使用的是非常多，我们用好foreach语句即可，有的时候面试官也会问批量插入的问题

除了批量插入，还有一个场景也是使用foreach最多的，那就是使用SQL in 查询的时候，比如说我们查询多个用户信息的时候。



还是先创建DAO方法

```java
package com.youkeda.comment.dao;

import com.youkeda.comment.dataobject.UserDO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.time.LocalDateTime;
import java.util.List;

@Mapper
public interface UserDAO {

    List<UserDO> findByIds(@Param("ids") List<Long> ids);

}
```

然后，我们再完善SQL XML

```xml
<select id="findByIds" resultMap="userResultMap">
    select * from user
    <where>
        id in
        <foreach item="item" index="index" collection="ids"
                    open="(" separator="," close=")">
            #{item}
        </foreach>
    </where>
</select>
```

这里多了两个参数

- open

> 表示的是节点开始时自定义的分配符

- close

> 表示的是节点结束时自定义的分配符

上面的 SQL 执行后比会变成

```SQL
select * from user where id in (?,?,?)
```

### <4> MyBatis 分页进阶

#### 4.1 MyBatis 分页插件

分页查询基本上是必备的能力，MyBatis 可以通过插件来很好的支持分页查询，目前最成熟的方案是`pagehelper`这个第三方插件。

我们只需要在工程的pom.xml里添加如下依赖即可，目前最新的版本是`1.2.13`



```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.13</version>
</dependency>
```

`pagehelper`非常易用，内部做了很多的优化工作，让开发者基本不需要额外处理MyBatis XML 逻辑，我们通过代码来看一下，继续改造`UserController.getAll`方法

```java
package com.youkeda.comment.control;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.youkeda.comment.dao.UserDAO;
import com.youkeda.comment.dataobject.UserDO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @GetMapping("/users")
    @ResponseBody
    public List<UserDO> getAll() {
        // 设置当前页数为1，以及每页3条记录
        Page<UserDO> page = PageHelper.startPage(1, 3).doSelectPage(() -> userDAO.findAll());
        return page.getResult();
    }

}
```

如上，我们使用`PageHelper`类来处理分页，它的完整包名是

`com.github.pagehelper.PageHelper`

我们结合lambda语法，在`doSelectPage`lambda 方法中执行MyBatis 查询方法，就会自动执行分页逻辑，并且返回分页对象`Page`，我们再仔细看看方法调用的情况

`````java
PageHelper.startPage(1,3);
`````

`startPage`第一个参数是指定页数，第二个参数指定的是每页的记录数

>MyBatis PageHelper 比较智能，如果查询第0页会自动转化为查询第一页（让开发者不纠结这个坐标值），如果查询的页数超过总页数也会自动查询最后一页。比如下面的调用和上面是一样的。

```java
PageHelper.startPage(0, 3);
```

返回类型`Page`对象是MyBatis 封装的分页模型，通过这个我们可以得到

- `getResult()` 获取分数数据
- `getPages()` 获取总页数
- `getTotal()` 获取总记录数
- `getPageNum()` 获取当前页面数

> `page`的完整路径是`com.github.pagehelper.Page`

在企业开发中，我们都额外封装一个通用的分页模型`Paging`用于处理返回值，参数如下

> 以后我们在各种项目中可能会经常反复用这个模型，就不再额外介绍了。

```java
package com.youkeda.comment.model;

import java.io.Serializable;
import java.util.List;

/**
 * 分页模型
 */
public class Paging<R> implements Serializable {

    private static final long serialVersionUID = 522660448543880825L;
    /**
     * 页数
     */
    private int pageNum;

    /**
     * 每页数量
     */
    private int pageSize = 15;
    /**
     * 总页数
     */
    private int totalPage;

    /**
     * 总记录数
     */
    private long totalCount;

    /**
     * 集合数据
     */
    private List<R> data;

    public Paging() {

    }

    public Paging(int pageNum, int pageSize, int totalPage, long totalCount, List<R> data) {
        this.pageNum = pageNum;
        this.pageSize = pageSize;
        this.totalPage = totalPage;
        this.totalCount = totalCount;
        this.data = data;
    }

    // 省略 getter、setter

}
```

Paging 模型比较简单，主要提供

- `pageNum` 当前页面数
- `pageSize` 每页记录数
- `totalPage` 总页面数
- `totalCount` 总记录数
- `data` 当前页面的集合数据 我们还提供了一个构造函数

我们继续改造一下`UserController.getAll`方法



```java
package com.youkeda.comment.control;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.youkeda.comment.dao.UserDAO;
import com.youkeda.comment.dataobject.UserDO;
import com.youkeda.comment.model.Paging;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @GetMapping("/users")
    @ResponseBody
    public Paging<UserDO> getAll() {
        // 设置当前页数为1，以及每页3条记录
        Page<UserDO> page = PageHelper.startPage(1, 3).doSelectPage(() -> userDAO.findAll());

        return new Paging<>(page.getPageNum(), page.getPageSize(), page.getPages(), page.getTotal(), page.getResult());
    }
}
```

#### 4.2 Druid 连接池

当我们掌握了 Java 数据库的操作能力后，就必然会面对一个新的问题，那就是性能优化，一般来说数据源连接池是最佳的优化方案，我们可以对比之前学习线程池的知识。



采用数据源连接池方案可以极大的提高数据处理能力，因为 Java 连接数据库比较耗时的，如果每次查询都重新连接数据库那样性能非常低下。换成连接池以后，我们的数据库操作就无需每次都去连接数据库，只是复用连接，从而完成性能的提升。

> 这个概念还是希望大家能够记住的，因为有的时候面试会经常提问到

基于性能的考虑，目前SpringBoot 官方集成的连接池是`HikariCP`，这个时候现在所有方案里性能最佳的，Spring也是默认就集成好了，并不需要我们额外处理。但是今天我们想介绍的是阿里巴巴出品的`Druid`，它有如下优势

- 性能优越（目前略低于 HikariCP）
- 扩展能力极强
- 具备 SQL 拦截功能
- 具备数据统计分析功能，比如慢 SQL 分析



当我们在维护一个产品的时候，会发现除了性能需要考虑，还需要考虑可扩展性，那么监控就是我们最重要的手段，而Druid在这方面做的非常好，所以我们还是强烈建议使用Druid，而且这个框架在阿里巴巴已经使用了很多年非常稳定，至于其他的方案我们就不推荐和分析了。



为了使用Druid，需要在pom.xml 文件里添加依赖



```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.23</version>
</dependency>
```

目前最新的是这个版本，保持更新就好。



Druid的配置是比较多的，具体的大家可以看`Druid Spring Boot Starter 中文文档`

我们继续看一下如何开启监控，你需要在`application.properties`文件里增加配置项

```xml
spring.datasource.druid.stat-view-servlet.enabled=true
spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*
spring.datasource.druid.stat-view-servlet.login-username=druid
spring.datasource.druid.stat-view-servlet.login-password=druid
spring.datasource.druid.stat-view-servlet.allow=
spring.datasource.druid.stat-view-servlet.deny=
```

上面的`login-username`和`login-password`是可以自己定义的



我们运行看一下，如果是本地访问地址是

`http://localhost:8080/druid/login.html`

以后我们就可以通过查看 SQL 监控来进行监控了，这里会把 慢SQL 给打印出来的，这个还是非常实用的性能优化方案，记住就可以了。



### <5> 评论服务开发（一）

#### 5.1 评论服务领域开发

在前面的课程中，为了学习MyBatis，我们都是采用API调用DAO层来演示的，在实际企业工作中，一般我们都会把逻辑写在service层，不太会直接在 API 调用 DAO的，这点要记住。



我们接下来通过实战一步步的完成评论服务开发，根据业务流程我们会拆分成如下：

- 用户注册服务
- 用户登录服务
- 用户发表评论
- 用户回复评论
- 查询文章评论

之前的领域模型

![comments-uml (1)](/Users/dongyanzu/Desktop/comments-uml (1).svg)

首先我们需要对于这两个模型的创建，领域模型一般存在`model`包下，这个完整的包路径

`com.youkeda.comment.model`

User对象里有一个属性`pwd`，我们都知道密码是不能泄漏的，所以我们需要在服务器输出的时候过滤掉这个属性，我们可以使用jackson的注解来忽略

```java
package com.youkeda.comment.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.ser.std.NullSerializer;

import java.time.LocalDateTime;

/**
 */
public class User {

    @JsonSerialize(using = NullSerializer.class)
    private String pwd;

}
```

当我们配置了

```java
@jsonSerialize(using = NullSerializer.class)
```

API 在返回 JSON 结果的时候，就不会有这个字段的值了，从而达到安全的作用



另外，对于时间我们一般都希望输出的格式是`yyyy-MM-dd HH:mm:ss`，我们依然可以借助jackson的注解来完成格式化输出。

```java
package com.youkeda.comment.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.ser.std.NullSerializer;

import java.time.LocalDateTime;

/**
 */
public class User {

    @JsonSerialize(using = NullSerializer.class)
    private String pwd;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime gmtCreated;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime gmtModified;

}
```

根据上面的要求，完成`User、Comment`两个类的开发



#### 5.2 用户注册服务

注册一个账户主要是根据用户名、密码来注册的，用户注册这个行为有可能会失败，比如用户名重复、密码太简单等等。为了能够正确描述返回数据，我们新增一个`Result`公共模型，用于处理API返回值，和之前的`Paging`一样

```java
package com.youkeda.comment.model;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.io.Serializable;

/**
 * JSON 返回模型
 */
public class Result<D> implements Serializable {

    @JsonProperty("isSuccess")
    private boolean success = false;

    private String code;
    private String message;

    private D data;

    // 省略 getter、setter

}
```

上面的Result模型，我们在success字段上增加一个注解`@JsonProperty("isSuccess")`，这个用于自定义JSON输出时候的字段名称，可以看演示结果，感受一下。



这些`JSON`的技巧都要记住，比较常用。



现在来改造一下UserController.getAll 方法看看

```java
package com.youkeda.comment.control;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.youkeda.comment.dao.UserDAO;
import com.youkeda.comment.dataobject.UserDO;
import com.youkeda.comment.model.Paging;
import com.youkeda.comment.model.Result;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@Controller
public class UserController {

    @Autowired
    private UserDAO userDAO;

    @GetMapping("/users")
    @ResponseBody
    public Result<Paging<UserDO>> getAll(@RequestParam(value = "pageNum", required = false) Integer pageNum,
                                         @RequestParam(value = "pageSize", required = false) Integer pageSize) {
        Result<Paging<UserDO>> result = new Result();

        if (pageNum == null) {
            pageNum = 1;
        }
        if (pageSize == null) {
            pageSize = 15;
        }
        // 设置当前页数为1，以及每页3条记录
        Page<UserDO> page = PageHelper.startPage(pageNum, pageSize).doSelectPage(() -> userDAO.findAll());

        result.setSuccess(true);
        result.setData(
            new Paging<>(page.getPageNum(), page.getPageSize(), page.getPages(), page.getTotal(), page.getResult()));
        return result;
    }
}
```

```json
{
  "code": null,
  "message": null,
  "data": {},
  "isSuccess": true
}
```

我想你应该看到了如上的数据，Result 的 success 属性输出 JSON 的时候变成了 isSuccess，符合我们的预期。

这里还有一个新的问题，code、message 字段为null，但是还是输出到 JSON 中去了，这样很浪费流量。我们需要把 null 字段的 JSON 给直接过滤掉，还有一些 JSON 的配置可以集中优化一下，打开 application.properties 文件，新增如下配置

```xml
spring.jackson.deserialization.fail-on-unknown-properties=false
spring.jackson.default-property-inclusion=non_null
```

上面2个配置分别的作用是

- 允许序列化未知的字段，可以兼容Java模型和JSON数据不一致的情况
- 忽略null字段



现在需要我们完成UserService接口的实现类



```java
package com.youkeda.comment.service.impl;

import com.youkeda.comment.model.Result;
import com.youkeda.comment.model.User;
import com.youkeda.comment.service.UserService;
import org.springframework.stereotype.Component;

@Component
public class UserServiceImpl implements UserService {
    @Override
    public Result<User> register(String userName, String pwd) {
        return null;
    }
}
```

`UserServiceImpl`是一个Spring Bean ，所以需要添加`@Component `注解



##### 任务要求

1. 引入 UserDAO Bean
2. 完成 Register 逻辑

![user_reg1](/Users/dongyanzu/Desktop/user_reg1.svg)

补充说明



判断非空 非 null



在企业中，我们一般会结合commons-lang3库来处理字符串，你需要在pom.xml中添加依赖



```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.10</version>
</dependency>
```

完成配置后，可以使用`StringUtils.isEmpty(Str)`来判断是否为空，StringUtils的完成路径为：

```java
org.apache.commons.lang3.StringUtils
```

##### 判断用户名是否存在

我们可以使用 `UserDAO.findByUserName`查询数据是否存在，如果存在记录则说明用户名已经存在了。



##### 加密

一般来说，我们会使用md5算法进行加密，建议使用`commons-code`库进行加密处理，同样需要先添加依赖



```xml
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.14</version>
</dependency>
```

看一下加密的例子：

```java
// 密码加自定义盐值，确保密码安全
String saltPwd = pwd + "_ykd2050";
// 生成md5值，并转为大写字母
String md5Pwd = DigestUtils.md5Hex(saltPwd).toUpperCase();
```

DigestUtils的完整包路径是

```java
org.apache.commons.codec.digest.DigestUtils
```

##### Result 返回处理

如果当我们执行成功的时候，我们需要正确的返回 Result 对象，我们需要

```java
Result<User> result = new Result<>();

UserDO userDO1 = new UserDO();
userDO1.setUserName(userName);
//初始昵称等于用户名
userDO1.setNickName(userName);
userDO1.setPwd(md5Pwd);
userDAO.add(userDO1);

//设置执行成功
result.setSuccess(true);

//将 UserDO 对象转化为 User 对象
User user = new User();
user.setId(userDO1.getId());
user.setUserName(userDO1.getUserName());
user.setNickName(userDO1.getNickName());

result.setData(user);

return result;
```

由于我们在`register`方法定义的返回模型是`Result<User>`，所以API层是完全感知不到UserDO模型的，这就需要我们手工转化一下对象类型

> DO 到 Model 的互换在Java工程是最常见的行为，大家习惯就好，这也是java语言不太优雅的地方，相比其他语言繁琐了点，有利有弊。



完成了service的开发后，现在我们继续完成API层的开发。记住我们在本章开始说的，这个开发模式才是企业采用的方式。



设计领域模型->开发基础的DAO->开发Service->开发API



现在继续之前的任务，完成UserAPI开发，只需要创建API类，完整的包路径是

```java
com.youkeda.comment.api.UserAPI
```

别忘记给UserAPI添加`@Controller`注解，因为它也是一个Spring MVC 的Bean 对象



现在我们开始完善注册用户这个 API , 在这个API里我们需要调用UserService.register来完成注册

> 大多数情况下，API就是根据定义来完成数据处理和组装的过程，所以大多数情况下，API逻辑是比较少的

我们期待的API定义如下

注册服务

- 请求地址（URL）

> POST/api/user/reg

- 请求内容（Request Param）

> ```json
> {
>   "userName":"用户名称，必须输入",
>   "pwd":"用户密码，必须输入"
> }
> ```

- 返回内容（Response）

> Result<User>

根据上面的注册服务描述，完成API开发



#### 5.3 用户登录服务



有了前面的基础后，我们继续开发用户登录服务，用户登录我们在Spring课程中也有讲到过，这里我们继续使用MyBatis完成开发。



越往后的开发，大家会逐步发现，代码是一环套一环的，前面的设计、逻辑对后续都是有影响的，所以需要不断的总结和思考才行。比如前面我们加密了密码，这里判断密码是否相同就得需要加密了。



另外由于用户可能会很多，所以一般我们把userId（user表的id值存储到session里就可以了，尽可能节省session的存储空间）



> session的空间是非常宝贵的，不要存太多数据进去，存多了很吃内存和影响性能。

我们接下来，继续一步步完成这个服务的开发。



我们继续在UserService接口下创建login方法，用于处理登录逻辑

```java
package com.youkeda.comment.service;

import com.youkeda.comment.model.Result;
import com.youkeda.comment.model.User;

public interface UserService {

    /**
     * 执行登录逻辑，登录成功返回 User 对象
     *
     * @param userName
     * @param pwd
     * @return
     */
    public Result<User> login(String userName, String pwd);

}
```

这里我们继续把返回类型设置为`Result<User>`这是为了传递错误信息，如果登录失败，就可以通过`Result`模型的`isSuccess`来确定了，而错误信息可以通过`code`和`message`属性来获取



如果登录成功，我们可以把User对象通过Result的data字段返回给调用房



完成login方法的创建，同时在UserServiceImpl类添加login方法的默认实现，比如

```java
@Override
public Result<User> login(String userName, String pwd) {
    return null;
}
```

##### login 方法的具体实现

任务要求，完成login逻辑

登录逻辑

![user_login1](/Users/dongyanzu/Desktop/user_login1.svg)



#### 5.4 用户退出服务

我们期待的API定义如下



退出登录服务

- 请求地址（URL）

> `Get /api/user/logout`

- 返回内容（Response）

> `Result`

根据上面的服务描述，完成API开发



#### 5.5 优化DO与Model互转



在前面，我们遭遇到多次UserDO转换为User对象的情况，如果每次都重新创建对象，代码重复的非常多，大家可以想象下面的代码到处都是多糟糕：

```java
// 将 UserDO 对象转化为 User 对象
User user = new User();
user.setId(userDO.getId());
user.setUserName(userDO.getUserName());
user.setNickName(userDO.getNickName());
user.setAvatar(userDO.getAvatar());
user.setGmtCreated(userDO.getGmtCreated());
user.setGmtModified(userDO.getGmtModified());
```

在企业中，我们一般会把这种转换代码抽象成公共方法，放在UserDO对象里，一般命名为`toModel`，比如

```java
package com.youkeda.comment.dataobject;

import com.youkeda.comment.model.User;
import java.time.LocalDateTime;

public class UserDO {

    /**
     * DO 转换为 Model
     *
     * @return
     */
    public User toModel() {
        User user = new User();
        user.setId(getId());
        user.setUserName(getUserName());
        user.setNickName(getNickName());
        user.setAvatar(getAvatar());
        user.setGmtCreated(getGmtCreated());
        user.setGmtModified(getGmtModified());
        return user;
    }
}
```

根据这个要求，完成上述代码的开发，并重构一下UserServiceImpl类，去掉重复的代码，改为方法调用。



完成上面的操作后，参考UserDO的toModel方法，继续完成Comment和CommentDO类的优化。



### <6> 评论服务开发（二）

#### 6.1 发送评论

完成了用户登录后，我们就可以正式的发布评论了。没有登录的时候是不能发送评论的。



有一点需要提醒大家，在很多时候如果关联userId的记录，都是从登录信息里获取到的，也就是session里获取id，这也是我们正式的开始使用登录数据



由于发送评论是要先登录的，所以完成这个评论服务的测试是需要前置动作的。随着项目的复杂度提升，我们会发现很多的功能都是依赖前置服务的，所以大家得仔细分析、思考。



以文章评论为例，我们需要先确定一个文章的ID，这个我们先自定义一个，比如`refId=2050001`，后面我们可以以这个来测试开发，希望大家可以习惯这个过程，就是先假定一些数据，然后推导逻辑。



> 假定数据在编程领域里叫mock，这个词以后可能会经常遇到。



接下来，我们还是先设计接口并实现它，最后完成API设计开发。



为了完成评论服务，我们设计一下`CommentService`

```java
package com.youkeda.comment.service;

import com.youkeda.comment.model.Comment;
import com.youkeda.comment.model.Result;

public interface CommentService {

    /**
     * 发布评论
     *
     * @param refId    外部 ID
     * @param userId   用户 ID
     * @param parentId 父评论 ID
     * @param content  评论内容
     * @return
     */
    public Result<Comment> post(String refId, long userId,
                            long parentId, String content);

}
```

这里，我们着重解释一下`parentId`字段，因为评论是可以继续回复的，所以如果我们对某一条评论进行回复的时候，你就可以传递`parentId`值。如果是一级评论，那么parentId一般设置为0，代表的是根节点。

> 一级评论指的是对文章的评论，二级评论是对评论的回复。

##### 评论逻辑

![comment_post1](/Users/dongyanzu/Desktop/comment_post1.svg)

##### 安全处理



基于安全的考虑，用户自定义输入的文本需要禁止HTML标签，这样可以避免很多恶意的代码，这个技能大家请掌握住。



我们可以使用`commons-test`这个库进行HTML转义，从而达到禁用HTML标签的作用，你需要添加依赖

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-text</artifactId>
    <version>1.8</version>
</dependency>
```

执行下面的代码可以完成转义：

```java
String body = StringEscapeUtils.escapeHtml4(content);
```

`StringEscapeUtils`的完整路径是`prg.apache.commons.test.StringEscapeUtils`



##### 任务

根据上面的要求

1. 完成CommentService接口的定义
2. 实现CommentService实现类 CommentServiceImpl的创建
3. 完成 post 方法的实现逻辑



我们期待的CommentAPI定义如下



发布评论服务

- URL

> POST /api/comment/post

- Request Param

> ```json
> {
>   "refId":"文章ID",
>   "parentId":父评论Id,
>   "content":"评论内容"
> }
> ```

Response:

> `Result<Comment>`

请根据上面的服务描述，完成API开发



获取 userId



我们通过前面接口的开发一个知道需要传递 userId ， 这个值你应该从session里获取。

```java
long userId = (long) session.getAttribute("userId");
```

如果在本地开发的话，务必要先调用登录接口哦，要不然完成不了测试



#### 6.2 查询评论



激动人心的时候来了，我们开始完成最后一个任务，评论的查询，大家可以再看一下界面，找找感觉先

![comments (1)](/Users/dongyanzu/Desktop/comments (1).png)



在这个界面里，有两个难点需要我们解决，我们在之前还没有处理过这种复杂的数据

1. 评论表需要关联数据表进行查询数据
2. 组装树数据结构

我们先完成关联查询，现在改进一下`CommentDAO.findByRefId`查询方法

MyBatis查询的时候，除了返回DO模型外，也可以支持其他模型，我们改造一下方法的返回类型。



```java
package com.youkeda.comment.dao;

import com.youkeda.comment.model.Comment;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

@Mapper
public interface CommentDAO {

    List<Comment> findByRefId(@Param("refId") String refId);

}
```

然后在 CommentDAO.xml文件里新增Comment的resultMap

```xml
<resultMap id="commentModelResultMap" type="com.youkeda.comment.model.Comment">
    <id column="id" property="id"/>
    <result column="ref_id" property="refId"/>
    <result column="content" property="content"/>
    <result column="parent_id" property="parentId"/>
    <result column="gmt_created" property="gmtCreated"/>
    <result column="gmt_modified" property="gmtModified"/>
</resultMap>
```

为了完成上面的配置，我们还需要在`Comment`对象里增加`parentId`字段，以保证数据能够被处理。

```java
public class Comment {

    private long id;

    private String refId;

    private User author;

    private String content;

    private List<Comment> children;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime gmtCreated;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime gmtModified;

    private long parentId;

}
```

大家注意看Comment对象里还有一个字对象User，我们是否可以查询的时候直接映射子对象呢？当然可以了，MyBatis有这种能力，resultMap有一个子节点`association`可以聚合其他模型。



仔细看看这个`association`配置，其实和resultMap差不多

- property 对应的是 comment 表的字段名称
- javaType 对应的是 Java 对象

我们并没有映射所有的字段，因为我们只需要`user_id、userName、nickName、avatar`几个字段即可



现在我们改造一下`findByRefId`查询语句



```xml
<select id="findByRefId" resultMap="commentModelResultMap">
    select a.*,u.user_name,u.nick_name,u.avatar from comment a left join user u
    on a.user_id=u.id where a.ref_id=#{refId} order by a.gmt_created desc
</select>
```

我们之前为了测试的`CommentController.findByRefId`方法的返回值也要调整为Comment，要不然编译会失败



```java
@GetMapping("/comment/findByRefId")
@ResponseBody
public List<Comment> findByRefId(@RequestParam("refId") String refId) {
	return commentDAO.findByRefId(refId);
}
```

现在根据上面的几个调整，完成开发。



MyBatis 组合模型还是有一点的复杂，多想一想逻辑，下次遇到这种需求可以参考我们这个案例。





我们继续完成 `CommentService`，增强 query 方法

```java
package com.youkeda.comment.service;

import com.youkeda.comment.model.Comment;
import com.youkeda.comment.model.Result;

public interface CommentService {

    /**
     * 查询评论
     *
     * @param refId
     * @return
     */
    public Result<List<Comment>> query(String refId);

}
```

然后我们完成接口方法的实现，这个实现的难点在于把集合变成tree结构，也就是说如果评论有回复，那么回复数据应该在这条评论的children字段里。

##### 代码提示

```java
//查询所有的评论记录包含回复的
List<Comment> comments = commentDAO.findByRefId(refId);
//构建 map 结构
Map<Long, Comment> commentMap = new HashMap<>();
//初始化一个虚拟根节点，0 可以对应的是所有一级评论的父亲
commentMap.put(0L, new Comment());
//把所有的评论转换为 map 数据
comments.forEach(comment -> commentMap.put(comment.getId(), comment));
// 再次遍历评论数据
comments.forEach(comment -> {
    //得到父评论
    Comment parent = commentMap.get(comment.getParentId());
    if (parent != null) {
        // 初始化 children 变量
        if (parent.getChildren() == null) {
            parent.setChildren(new ArrayList<>());
        }
        // 在父评论里添加回复数据
        parent.getChildren().add(comment);
    }
});
// 得到所有的一级评论
List<Comment> data = commentMap.get(0L).getChildren();
```

上面的代码，可以多看看消化一下，以后遇到类似的Tree数据，都可以采用这种方法来处理。



##### 任务

根据上面的要求

1. 完成CommentService 接口 query 方法的定义
2. 完成query 方法的实现逻辑



我们期待的comment API 定义如下



查询评论服务

- URL

> GET /api/comment/query

- Request Param

> ```
> {
> "refId" : "文章ID"
> }
> ```

- Response

> `Result<List<Comment>>`

请根据上面的服务描述完成API开发



### <7> Spring 安全

#### 7.1  CORS

`CORS`是一个 W3C 标准 ， 全称是“跨域资源共享”（Cross-orgin- resource sharing）。它允许浏览器向跨源服务器，发出 XML HttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。



这句话说的有点复杂，这个技术产生的背景是由于安全的考虑，浏览器会禁止读取跨域名的资源，比如你在taobao.com域名下请求baidu.com域名的服务，就被禁止了。



我们在前端调用 Ajax 就会经常碰到这样的错误

```
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite
```

当我们在控制台里看到这样的错误信息，那就说明请求跨域啦

> 跨域这个在前后端调用比较频繁，不同的域名访问就会发生跨域

CORS 技术就是相当于开个信任的通道，让服务器信任调用方解决跨域的问题

关于它的内部机制，推荐大家查看阮一峰的文章介绍的比较详细 [跨域资源共享 CORS 详解 ](https://www.ruanyifeng.com/blog/2016/04/cors.html)。

我们这里主要来看 SpringBoot 如何支持 CORS 请求，实际上非常简单，我们推荐使用 Filter 方式来解决

```java
package com.youkeda.comment;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.time.Duration;

@Configuration
public class CorsConfig {

    @Bean
    public FilterRegistrationBean corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        // 设置你要允许的网站域名，如果全允许则设为 *
        config.addAllowedOrigin("*");
        // 如果要限制 HEADER 或 METHOD 请自行更改
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        config.setMaxAge(Duration.ofDays(5));
        source.registerCorsConfiguration("/**", config);
        FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));
        // 这个顺序很重要哦，为避免麻烦请设置在最前
        bean.setOrder(0);
        return bean;
    }
}
```

如上，只要在工程里创建 CorsConfig 这个类就可以啦，代码如上主要是自定义了一个 Filter 拦截所有的请求从而完成 Cors 的配置。由于这个配置是一次性的，所以大家的工程如果没有这个配置，或者看到错误，就可以添加一下就搞定了

```
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite
```
