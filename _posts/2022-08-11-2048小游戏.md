---
Layout: post
desc: js 2048
title: js 2048
tag: study
---

## 2048小游戏

### <1> 2048项目介绍

#### 1.1 2048 项目介绍

本节课是JavaScript的实战课程。在本课程中，我们利用之前的HTML、CSS、Javascrip的知识，并教会大家如何把这些知识融会贯通在实战项目中。

我们先来看一看最终作品演示：


线上地址为：https://2048game.com/

我们本次作业最终效果将和上面保持一致。

首先我们来理理要完成的内容和大概的知识点，这点非常重要，移动要理解需求。

##### 实战需求

1. 游戏是一个4x4的方格，每个方格我们称作一个Tile或者Call
2. 游戏开始能随机出现2个Tile，每个的值90%可能为2，10%的可能为4
3. 可以通过上、下、左、右键盘操作，每个TIle按照方向移动到不可移动为止。
4. 如果移动以后两个TIle的内容值一页，则进行合并。
5. 每个TIle移动会有100ms的移动动画。
6. 每个TIle的出现又个短暂的放大效果。
7. 每次TIle的合并有个短暂的放大回弹效果。
8. 顶部Score记录当前分数，BestScore记录有史以来最高分，每次合并都会产生分数的变化，分数计算规则为：分数=原来分数+合并后的值。
9. 游戏时时刻刻记录进度，刷新页面重现游戏进度
10. 当某个TIle的值为2048，游戏胜利
11. 当每个方格都有值，并且相邻两个方格无法再进行合并，则游戏结束。

##### 实战技术知识点

1. 静态页面渲染：需要HTML，CSS基础知识，包括学习scss知识。
2. 开始游戏等时间处理，需要使用DOM监听事件
3. TIle移动处理，需要监听键盘事件（暂时不处理H5中收拾事件等情况）
4. TIle动态随机添加：需要使用DOM动态操作
5. TIle移动、合并；需要使用Javascript列表，对象，方法等数据结构和常用技巧。
6. Tile动画：需要使用CSS的transform和animation等动画效果
7. 本地缓存：需要使用Javascript localStorage 浏览器缓存
8. ....
9. 

##### 提示

1. 本次开始为了更好的监听键盘事件，最好再去安排预判模式下进行操作
2. 本次开发将采取老师开发一部分，学生自己完成剩余部分的方式进行
3. 本次开发几乎不会进行脚药，大家需要自觉完成代码，达到真正掌握技术的目的
4. 本节课对数学能力有一定的要求，在有难度的章节，可以暂时跳过。

### <2> 2048静态页面开发

#### 2.1 2048 静态页面（一）

本节课我们首先完成静态页面的开发

我们分析下页面结构如下：

![img](https://style.youkeda.com/img/course/f10/2/2.jpeg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

对应的HTML结构代码如下：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta chasert="UTF-8" />
    <title>优课达-2048</title>
    <link rel="stylesheet" href="./style/index.css" />
  </head>
  <body>
    <div class="container">
      <nav>...</nav>
      <div class="desc">...</div>
      <main>
        <div class="game-grid">...</div>
        <div class="title-container">...</div>
      </main>
      <footer>...</footer>
    </div>
  </body>
</html>
```

整个页面的CSS文件较大，为了更加清晰的理解CSS文件。我们利用`SCSS @import`特性对文件进行分离，如下文件目录。

```js
|-- images
|-- style
    |-- index.scss  // scss入口文件 + footer
    |-- nav.scss    // 头部区域文件
    |-- main.scss   // 主体区域文件
    |-- desc.scss   // 描述区域文件
|-- index.html
```

我们阅读下`main.scss`文件，代码如下：

```scss
$field-width: 290px;
$grid-spacing: 10px;
$grid-row-cells: 4;
$tile-size: ($field-width - $grid-spacing * ($grid-row-cells + 1)) / $grid-row-cells;
$tile-border-radius: 3px;

main {
  margin-top: 20px;
  margin-left: auto;
  margin-right: auto;
  box-sizing: border-box;
  width: $field-width;
  height: $field-width;
  position: relative;
  padding: $grid-spacing;
  background: #bbada0;
  border-radius: 8px;

  .game-grid {
    .grid-row {
      .grid-cell {
      }
    }
  }
}
```

我们利用`scss变量`声明中心方格区域的长度，间隔等属性，如果以后我们需要适配移动端，只需要修改这里等变量值即可，这就是`scss`的优势--可编程的CSS。

#### 2.2 2048静态页面（二）

为了方便以后TIle方块动态渲染，我们加入2、4、8到2048，11个方块静态页面，最终效果如下：

![img](https://style.youkeda.com/img/course/f10/2/4.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

大家思考一下，应该如何渲染这些方块？

我们分析下其相同点和不同点：

1. 它们都有一样的大小，圆角，动效，所以我们需要设置一个统一的class为`tile`。
2. 它们每个数字颜色的字体大小都不同，因此我们需要为每个值设置单独的样式，class为`tile-(x)`（x 为 2、4、6、8、16...2048）.
3. 它们的位置可以总结为**行(row)、列(column)**,因此我们可以使用绝对定位进行布局，class为`title-position-(row)-(column)`.
4. 每个元素都有移动（translate)和放缩(scale)动画，因为两个动画都是`translate`的一个属性，会出现冲突。因此我们将每个TIle分为外框`tile`和`tile-inner`两个部分，`tile`用于元素移动，`title-inner`用于元素放缩。

通过上面的分析，我们可以对于图示中的2的HTML代码设置为：

```html
<div class="tile tile-2 tile-position-1-1">
  <div class="tile-inner">2</div>
</div>
```

> tile-2 表示这个tile的值为2 tile-position-1-1 表示这个tile 的位置在第一行第一列

我们加入CSS代码如下：

```scss
.tile-container {
  position: absolute;
  left: 0;
  top: 0;

  .tile {
    position: absolute;
    width: $tile-size;
    height: $tile-size;
    border-radius: 4px;
    transition: transform 100ms ease-in-out;
  }

  .tile-inner {
    width: 100%;
    height: 100%;
    line-height: $tile-size;
    background: #eee4da;
    text-align: center;
    font-weight: bold;
    font-size: 34px;
    color: #776e65;
  }

  @for $x from 1 through $grid-row-cells {
    @for $y from 1 through $grid-row-cells {
      .tile-position-#{$x}-#{$y} {
        $xPos: $grid-spacing + floor(($tile-size + $grid-spacing) * ($y - 1));
        $yPos: $grid-spacing + floor(($tile-size + $grid-spacing) * ($x - 1));
        transform: translate($xPos, $yPos);
      }
    }
  }

  .tile.tile-2 .tile-inner {
    background: #eee4da;
  }
}
```

特别注意这段代码:

```scss
@for $x from 1 through $grid-row-cells {
  @for $y from 1 through $grid-row-cells {
    .tile-position-#{$x}-#{$y} {
      $xPos: $grid-spacing + floor(($tile-size + $grid-spacing) * ($y - 1));
      $yPos: $grid-spacing + floor(($tile-size + $grid-spacing) * ($x - 1));
      transform: translate($xPos, $yPos);
    }
  }
}
```

我们通过 scss 的**循环和变量**，动态生成 4 行 4 列的 Tile **Position**样式。

可以看到我们已经渲染一个 **2**。

大家观察一下`index.scss`生成的`index.css`文件，能看到如下代码：

```css
main .tile-container .tile-position-1-1 {
  transform: translate(10px, 10px);
}
main .tile-container .tile-position-1-2 {
  transform: translate(80px, 10px);
}
...
```

通过循环，可以自动生成 1-1 到 4-4 的 16 个 class。

### <3> 2048 模型设计，随机渲染

#### 3.1 2048对象设计

本节课我们将开始接入`Javascript`代码，在介入之前我们首先将上一节作业中结果页面应仓，我们结果页面使用`mask`class，并使用`display:flex;`。

我们将其改为`display:none`。

##### Tile 对象

我们开始分析该如何使用JS来完成这个效果。因为项目比较大，不能使用简单的JS代码来实现，我们得考虑到文件分离，JS对象的使用。

在此处，我们可以把每个方格，可以当成一个`Tile`对象，每个`Tile`应该有`row`,`column`,`value`三个属性分别表示行、列、值，对应的JS代码为：

```js
// tile.js
function Tile(position, value) {
  this.row = position.row;
  this.column = position.column;
  this.value = value;
}
```

如上面代码：

> 对象一般命名方式为大写开头
>
> 一个方格（**Tile**），我们可以理解为用`position(row、column)`和`value`构建而成。

##### Grid 对象

同样，所有的`Tile`对象，是由整个面板管理的，我们称之为`Grid`对象。

对`Grid`对象而言，他需要知道自己是 4 * 4 的方格，因此我们可以写如下代码：

```js
// grid.js
function Grid(size = 4) {
  this.size = size;
}
```

> size 表示长宽分别为多少格。

我们继续用`Grid`对象来存储`Tile`内容，在这里我们可以使用**二维数组**来存储。我们继续添加代码：

```js
//grid.js
function Grid(size = 4) {
  this.size = size;
  this.cells = [];
  this.init(size);
}

// prototype 设置方法
Grid.prototype.init = function (size) {
  for (let row = 0; row < size; row++) {
    this.cells.push([]);
    for (let column = 0; column < size; column++) {
      this.cells[row].push(null);
    }
  }
};
```

> 在上面我们学习新的设置**类方法**的技术，我们可以使用 **propotype**。那这种方式和之前学习的有什么区别呢？简单来看我们可以将对象中**属性和方法分离**，其他作用我们以后慢慢讲到，大家在此处只需要继续这种写法即可。
>
> 在 `init` 方法中，我们初始化一个 4 * 4 的二维数组，数组里面每个值都是`null`。

##### 引入 JS

我们引入 JS 代码，注意因为`Grid`对象会依赖于`Tile`对象，因此`grid.js`在引入的时候需要放置在`tile.js`文件下面

我们看看 HTML 中的代码最终结果为：

```html
<html>
  ...
  <body>
    ...
    <script src="./scripts/tile.js"></script>
    <script src="./scripts/grid.js"></script>
    <script src="./scripts/index.js"></script>
  </body>
</html>
```

代码演示



我们在`index.js`打印一下`new Grid()`可以看到如下结果（左边是 JSConsole，右边是 Chrome Console）：

![img](https://style.youkeda.com/img/course/f10/3/2.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)![img](https://style.youkeda.com/img/course/f10/3/3.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

从这个信息，可以知道当前`Grid面板`中每个位置都是`null`, 没有一个`Tile`。 用这种 **2 维数组** 结构可以清晰的对应整个 **2048** 方格信息。

##### 往 Grid 添加 Tile

我们开始往 Grid 添加 Tile，我们首先在`Grid`加入 `add` 方法，代码如下：

```js
//grid.js

//...

Grid.prototype.add = function (tile) {
  this.cells[tile.row][tile.column] = tile;
};
```

我们修改`index.js`文件，创建一个`Tile`, 并将其添加到`Grid`中，代码如下：

```js
// index.js
let grid = new Grid();
let tile = new Tile(
  {
    row: 0,
    column: 0,
  },
  2
);
grid.add(tile);
console.log(grid);
```



最终的结果为：

![img](https://style.youkeda.com/img/course/f10/3/4.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)![img](https://style.youkeda.com/img/course/f10/3/5.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

最终的结果如下，我们在 1 行 1 列，加入一个`Tile`对象。

##### UML 图

在软件设计中，我们通常用 UML 来表示上面对象的关系，我们来看看图示：

![img](https://style.youkeda.com/img/course/f10/3/7.svg)

> 我们使用**虚线**表示使用关系 在每个类中，我们可以看到类**属性和方法**

大家要习惯将`UML`图和代码实现映射起来，以后只要看到图就知道代码怎么实现了。

#### 3.2 2048 对象渲染

在上节中，我们已经完成了整个对象模型的搭建，本节课我们将完成`Grid`的渲染。

同样，我们增加一个`Render`对象用于页面渲染。我们先来看看UML图：
![img](https://style.youkeda.com/img/course/f10/3/1.svg)

##### Render

我们来按照图示，实现一下`Render`的代码：

```js
//render.js
function Render() {}

// 渲染整个grid
Render.prototype.render = function(grid) {
  for (let row = 0; row < grid.size; row++) {
    for (let column = 0; column < grid.size; column++) {
      // 如果grid中某个cell不为空，则渲染这个cell
      if (grid.cells[row][column]) {
        this.renderTile(grid.cells[row][column]);
      }
    }
  }
};

// 渲染单个tile
Render.prototype.renderTile = function(tile) {};
```

##### RenderTile

紧接着我们思考下应该如何渲染每一个Tile，这部分逻辑其实很简单，都是基础的DOM操作，代码如下：

```js
//render.js
function Render() {
  this.tileContainer = document.querySelector('.tile-container');
}

// 渲染单个tile
Render.prototype.renderTile = function(tile) {
  // 创建一个tile-inner
  const tileInner = document.createElement('div');
  tileInner.setAttribute('class', 'tile-inner');
  tileInner.innerHTML = tile.value;

  // 创建一个tile
  const tileDom = document.createElement('div');
  let classList = [
    'tile',
    `tile-${tile.value}`,
    `tile-position-${tile.row + 1}-${tile.column + 1}`
  ];
  tileDom.setAttribute('class', classList.join(' '));
  tileDom.appendChild(tileInner);
  this.tileContainer.appendChild(tileDom);
};
```

> 我们在`Render`对象初始化的地方，创建了`tileContainer`，这样我们只需要取一次，之后多次使用，有利于节省代码运算，这是个小技巧喔。
>
> 我们利用动态`class`，给新建的`Tile`节点设置样式（包括**值**，**位置**）。

演示一下（我们先将之前内置的 HTML 节点注释掉，以免影响）：

![img](https://style.youkeda.com/img/course/f10/3/8.png?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

我们正确渲染了上一节在`Grid`中添加的两个方格。

#### 3.3 2048 随机初始化

在上一节中，我们已经完成`Tile`和`Grid`的渲染，但是我们是内容值的一行一列和4行4列方格的渲染。

在实际游戏中，最开始出现的方格是随机的，那我们应该如何随机渲染节点呢？

我们在来看看最开始的需求：

> 游戏开始能随机出现2Tile，每个的值90%可能为2，10%可能为4

我们思路应该是先获取`Grid`所有的空闲方格，然后利用随机数，随机获取其中一个方格，创建`Tile`对象，并且设置Value值。

##### 所有可用（空闲）方格

因此我们在`Grid`新增获取所有空闲方格的方法，代码如下：

```js
// grid.js
// 获取所有可用方格的位置
Grid.prototype.availableCells = function() {
	const availableCells = [];
	for(let row=0;row < this.cells.length; row++) {
		for(let column=0;column < this.cells[row].length;column++){
			avaliableCells.push({row,column});
		}
	}
	return availableCells;
};
```

##### 随机某个可用（空闲方格）

紧接着，我们加入随机获取某一个空闲节点的方法，代码如下：

```js
// grid.js
// 随机获取某个可用方格的位置
Grid.prototype.randomAvailableCell = function() {
	//获取到所有的空闲方格
	const cells = this.availableCells();
	if(cells.length > 0) {
		//利用Math.random() 随机获取其中某一个
		return cells[Math.floor.random()*cells.length];
	}
};
```

##### index.js 利用随机空闲位置创建节点

```js
let grid = new Grid();
let render = new Render();
for (let i = 0; i < 2; i++) {
  // 90%概率为2，10%为4
  const value = Math.random() < 0.9 ? 2 : 4;
  // 随机一个方格的位置
  const position = grid.randomAvailableCell();
  // 添加到grid中
  grid.add(new Tile(position, value));
}
render.render(grid);
```

最终，会发现每次运行，都会随机出现两个方格，方格中的数组概率也满足要求。

##### 总结

到现在为止，我们也写了不少了代码了，我们总结下

1. 写代码一定要利用好**方法函数**，在函数中加好**注释**，一方面可以让我们思路变得清晰，二方面非常易于以后阅读和查询问题。
2. 必要的**分割 JS 文件**是一种良好的编程习惯，相同职责的代码放在一起。比如在上面我们提供的随机获取某个空方格的方法，就属于`grid`的职责范畴，所以放在`grid.js`文件里面。
3. 这种分割代码方式，也体现一个人的**架构思维**。大家现在可能无法体会架构的好处，不着急，慢慢来，做完整个项目就有感觉了。

### <4> 2048 移动处理

#### 4.1 键盘监听

在上节课，我们完成了方格初始化后随机展示两个元素，本节课我们将继续完成方格移动的效果。

##### 重构- Manager

在项目越来越复杂时，我们发现`index.js`作为一个入口文件，已经承担了整个游戏控制器的作用，为了让我们的`index.js`责任更加纯粹，我们抽离一个新的`Manager`类来承担整个游戏控制器的作用。最终的UML图如下所示：

![img](https://style.youkeda.com/img/course/f10/4/1.svg)

对应的`manager.js`代码如下：


```js
//manager.js
function Manager(size = 4) {
  this.size = size;
  this.grid = new Grid(size);
  this.render = new Render();
  this.start();
}

Manager.prototype.start = function () {
  for (let i = 0; i < 2; i++) {
    // 90%概率为2，10%为4
    const value = Math.random() < 0.9 ? 2 : 4;
    // 随机一个方格的位置
    const position = this.grid.randomAvailableCell();
    // 添加到grid中
    this.grid.add(new Tile(position, value));
  }
  this.render.render(this.grid);
};
```

> 在**Manager**中，我们默认初始化一个 grid，一个 render，作为其属性，方便之后多次使用。

##### 键盘监听

通过之前的课程学习，MDN 文档查询，我们知道监听键盘的方法如下：

```js
window.addEventListener('keyup', function (e) {
  console.log(e.keyCode);
});
```

通过打印`e.keyCode`我们可以分为知道上下左右键对应的`keyCode`是多少，最终的结果为：

```js
38 => 上
37 => 左
40 => 下
39 => 右
```

当然大家监听`keydown`也可以，表面上这两个事件并没有多大区别。

#### 4.2 监听回调控制

##### lister.js

对于游戏控制器`Manager`而言，和`Render`渲染器类似，我们需要增加一个监听器`Listner`，对应的代码如下：

```js
function Listener() {
  window.addEventListener('keyup', function (e) {
    switch (e.keyCode) {
      case 38:
        console.log('向上');
        break;
      case 37:
        console.log('向左');
        break;
      case 39:
        console.log('向右');
        break;
      case 40:
        console.log('向下');
        break;
    }
  });
}
```

##### 事件回调

为了让`Listener`响应键盘事件以后，能回传到`Manager`进行操作控制，我们需要给`Listner`传递一个回调函数，优化一下上面的代码如下：

```js
//listener.js
function Listener({ move: moveFn }) {
  window.addEventListener('keyup', function (e) {
    switch (e.keyCode) {
      case 38:
        moveFn('向左');
        break;
      case 37:
        moveFn('向上');
        break;
      case 39:
        moveFn('向下');
        break;
      case 40:
        moveFn('向右');
        break;
    }
  });
}
```

在`Manager`中修改如下：

```js
//manager.js

this.listener = new Listener({
  move: function (direction) {
    console.log(direction);
  },
});
```

> 大家看看这就是一个非常典型的**回调函数**的用法，我们可以通过传递`moveFn`到`Listener`，当`Listener`触发键盘事件以后，回调`Manager`

#### 4.3 方向向量化

##### 向量化

在上一节中，我们已经在`Manager`中，拿到了键盘监听的方向，对大家而言上下左右文字很容易理解，但是计算机却不是这样的。

方向，计算机世界中一般用向量来表示。什么意思？

对于任意一个方格，假设其位置为：`row: 1; column: 1`(第 2 行第 2 列)，依次往**上下左右**移动以后，新的`row, column`分别是什么呢？

```js
左 => row: 1, column: 0  // 列数索引 -1, 也就是column -1
右 => row: 1, column: 2  // 列数索引 +1, 也就是column +1
上 => row: 0, column: 1  // 行数索引 -1, 也就是row -1
下 => row: 2, column: 1  // 行数索引 +1, 也就是row +1
```

由上面的结果和原始位置的对比，可以知道，不同方向对应的向量分别为:

```js
左 => {row: 0, column: -1}
右 => {row: 0, column: 1}
上 => {row: -1, column: 0}
下 => {row: 1, column: 0}
```

以向左移动为例：

```js
// 原始位置 + 向量 = 现在位置
// {row: 1, column: 1} + {row: 0, column: -1} = {row: 1, column: 0}
```

符合我们的预期，因此我们将`Listener`的回调参数修改一下:

```js
//listener.js
function Listener({ move: moveFn }) {
  window.addEventListener('keyup', function (e) {
    switch (e.keyCode) {
      case 38:
        moveFn({ row: -1, column: 0 });
        break;
      case 37:
        moveFn({ row: 0, column: -1 });
        break;
      case 39:
        moveFn({ row: 0, column: 1 });
        break;
      case 40:
        moveFn({ row: 1, column: 0 });
        break;
    }
  });
}
```

重点理解上面的**向量推导过程**。

#### 4.4 移动位置计算

##### Tile移动

OK，前面我们已经把所有的基础打扎实了。本小节，我们将进入整个项目最复杂，最核心，也可以说对数学要求最高的章节---Tile移动。

在看课程方案之前，大家思考一个问题：

我们得到向量以后，应该如何计算方块移动的目标位置？

##### 案例分析

我们先来分析一个案例，如下图所示：

![img](https://style.youkeda.com/img/course/f10/4/2.jpeg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

大家仔细阅读一下上面的文字说明。

我们总结下如下两条规则（在不考虑方块合并的情况下）：

> 规则1: 同一排或同一列的方块移动顺序跟随具体的方向，比如上图中，向上移动 2先移动，4后移动；向下移动 4先移动，2后移动。
>
> 规则2:每个方格都是移动到该方向的最后一个空白位置

##### 代码实现-遍历顺序

首先为了让每个方格都能移动，我们肯定需要遍历游戏中的16个方格。同时根据上面规则1，我们知道遍历是有一定顺序的。

我们设置一个方法，根据方向返回遍历路径，代码如下：

```js
//manager.js

Manager.prototype.getPaths = function (direction) {
  let rowPath = [];
  let columnPath = [];
  return { rowPath, columnPath };
};
```

该方法将返回`rowPath`, `columnPath`分别表示**行遍历顺序**和**列遍历顺序**。

#### 小知识

这里有一个小知识, 如下代码

```js
{
  rowPath, columnPath;
}

// 等同于

{
  rowPath: rowPath,
  columnPath: columnPath
}
```

> 在书写 Map 的时候，如果 **key** 和 **value 变量名称** 相同，则可以省略冒号。

回归代码，我们首先加入**正常的左上到右下**的遍历顺序，代码如下：

```js
Manager.prototype.getPaths = function (direction) {
  let rowPath = [];
  let columnPath = [];
  for (let i = 0; i < this.size; i++) {
    rowPath.push(i);
    columnPath.push(i);
  }
  return {
    rowPath,
    columnPath,
  };
};
```

> 当方向为**向右**的时候，遍历方向应该从右到左，`columnPath`遍历方向应该**反向**。 当方向为**向下**的时候, 遍历方向应该从下到上，`rowPath`遍历方向应该**反向**。

优化一下代码如下：

```js
Manager.prototype.getPaths = function (direction) {
  let rowPath = [];
  let columnPath = [];
  for (let i = 0; i < this.size; i++) {
    rowPath.push(i);
    columnPath.push(i);
  }

  // 向右的时候
  if (direction.column === 1) {
    columnPath = columnPath.reverse();
  }

  // 向下的时候
  if (direction.row === 1) {
    rowPath = rowPath.reverse();
  }
  return {
    rowPath,
    columnPath,
  };
};
```

> reverse() 方法，可以让数组里面顺序进行颠倒

##### 代码实现-找寻目标位置

紧接着我们需要寻找方块移动的目标地址，根据规则2，每个方格移动到此方向不能移动位置，代码应该怎么写呢？如下：

```js
// 寻找移动方向目标位置
Manager.prototype.getNearestAvaibleAim = function (aim, direction) {
  // 位置 + 方向向量的计算公式
  function addVector(position, direction) {
    return {
      row: position.row + direction.row,
      column: position.column + direction.column,
    };
  }
  aim = addVector(aim, direction);

  // 获取grid中某个位置的元素
  let next = this.grid.get(aim);

  // 如果next元素存在（也就是此目标位置已经有Tile），或者是超出游戏边界，则跳出循环。目的：就是找到最后一个空白且不超过边界的方格
  while (!this.grid.outOfRange(aim) && !next) {
    aim = addVector(aim, direction);
    next = this.grid.get(aim);
  }

  // 这时候的aim总是多计算了一步，因此我们还原一下
  aim = {
    row: aim.row - direction.row,
    column: aim.column - direction.column,
  };

  return {
    aim,
    next,
  };
};
```

上面代码逻辑可能比较绕，大家慢慢来，**多看看注释，多理解几遍**。

核心逻辑是如下，通过循环，找寻最后一个空白位置：

```js
// 如果next元素存在（也就是此目标位置已经有Tile，
// 或者是超出游戏边界，则跳出循环。
// 目的：就是找到最后一个空白且不超过边界的方格
while (!this.grid.outOfRange(aim) && !next) {
  aim = addVector(aim, direction);
  next = this.grid.get(aim);
}
```

在这里面我们需要在`Grid`新增了两个方法:

```js
// grid.js

// 获取某个位置的Tile
Grid.prototype.get = function (position) {
  if (this.outOfRange(position)) {
    return null;
  }
  return this.cells[position.row][position.column];
};

// 判断某个位置是否超出边界
Grid.prototype.outOfRange = function (position) {
  return (
    position.row < 0 ||
    position.row >= this.size ||
    position.column < 0 ||
    position.column >= this.size
  );
};
```

这两个方法都比较简单，我就不多介绍了。

最终完整的代码如**右侧**（因为我们暂未完成移动，所以还没有效果，大家先总体看看新增的几个方法）。

#### 4.5 Tile 移动

##### Tile移动处理

紧接着我们完成方块的移动，具体思路如下：

1. 根据方向获取遍历顺序，跟随顺序进行遍历
2. 遍历时候，如果此位置上有TIle，则进行移动
3. 根据当前TIle的位置和方向，获取目标移动位置
4. 进行TIle移动
5. 只要有一个节点产生移动，则重新调用渲染器渲染grid

```js
// manager.js
Manager.prototype.listenerFn = function(direction) {
  // 定义一个变量，判断是否引起移动
  let moved = false;

  const { rowPath, columnPath } = this.getPaths(direction);
  for (let i = 0; i < rowPath.length; i++) {
    for (let j = 0; j < columnPath.length; j++) {
      const position = { row: rowPath[i], column: columnPath[j] };
      const tile = this.grid.get(position);
      if (tile) {
        // 当此位置有Tile的时候才进行移动
        // 移动时，首先获取目标移动位置
        const { aim, next } = this.getNearestAvaibleAim(position, direction);
        this.moveTile(tile, aim);
        moved = true;
      }
    }
  }

  // 移动以后进行重新渲染
  if (moved) {
    this.render.render(this.grid);
  }
};
```

那 `moveTile` 怎么处理呢？

我们知道`Render`渲染器渲染时，扫描`Grid`中所有的`Tile`，动态生成 class。因此我们只需要改变`Grid`中`Tile`的元素位置，页面当然重新渲染。思路如下：

1. `Tile`对应的`Grid`原始位置设置为 null
2. 更新`Tile`的 position
3. 将更新后的`Tile`设置到`Grid`新的位置

```js
// manager.js

// 移动Tile，先将grid中老位置删除，在添加新位置
Manager.prototype.moveTile = function(tile, aim) {
  this.grid.cells[tile.row][tile.column] = null;
  tile.updatePosition(aim);
  this.grid.cells[aim.row][aim.column] = tile;
};
```

我们继续在`Tile`中新增**更新位置**的方法，代码如下：

```js
// tile.js

// 更新Tile的位置
Tile.prototype.updatePosition = function(position) {
  this.row = position.row;
  this.column = position.column;
};
```

##### 监听联调

最后一步，在`Listener`监听回调中调用`listenerFn`方法，代码如下：

```js
let self = this;
this.listener = new Listener({
  move: function(direction) {
    self.listenerFn(direction);
  }
});
```

注意：

为什么必须要在前面定义`let self = this`？

> 这涉及到**JS 作用域**，因为回调函数 `function(direction)` 是由`Listener`调用的，因此`this`会指向`Listener`，并不是`Manager`。在这种情况下，如果使用`this.listenerFn`将无法找到`listenerFn`方法，因此我们需要在方法调用之前（`this`还未改变之前）将`this`先保存到`self`。

##### Render

最后我们在 Render 里面，每次渲染之前，先清空所有的`Tile`。通过之前的学习，我们知道直接使用`innerHTML = ''`可以解决，我们加入代码：

```js
// render.js

// 渲染整个grid, 在之前先清空所有的Tile
Render.prototype.render = function(grid) {
  this.empty();
  ...
};

Render.prototype.empty = function() {
  this.tileContainer.innerHTML = '';
};
```

大家可以运行一下右侧的代码，在**不考虑合并**情况下，已经完成`Tile`移动，本节课比较难，就不给大家布置作业咯。

##### 总结

最终的类图如下所示：

![img](https://style.youkeda.com/img/course/f10/4/3.svg)

大家可以阅读以下这个类图，对整体逻辑有更清晰的认识，我们总结下本章节的特点和重点：

1. 本节课我们继续增加了`Manager`和`Listener`，分别用于游戏管理和事件监听，继续使用**职责**进行 JS 代码的拆分。
2. 本节课我们重点和难点在于**目标移动位置**的确认，这部分对数学知识要求较高，大家一定要先理解思路，再实现代码。
3. 大家有没有发现`Render`的强大之处，只要你将新的`Grid`传入，它便能根据约定完成渲染。这就是抽离不同文件的好处，专业术语叫做**封装**。

> 对调用者而言，我们不需要了解`Render`的实现详情，我们只需要知道传递一个`Grid`他就能完成页面的渲染。

### <5> 2048合并处理

#### 5.1 合并处理

##### Tile 合并规则

我们继续在上一节的基础上，考虑方格合并问题，那在上面场景下，才能产生方格合并呢？

规则只有一个：方格移动到不能移动为止，并且下一个位置的value值和该value值一样

这就是上一节我们找寻最终目标位置方法，为什么返回两个数据的原因，我们来看看代码：

```js
// 寻找移动方向目标位置
Manager.prototype.getNearestAvaibleAim = function(aim, direction) {
  //...
  return {
    aim,
    next
  };
};
```

> 这里的`aim`是目标移动位置，`next`目标移动位置下一个 Tile。

##### Tile 合并代码

理解这个原理，剩下就容易了，我们继续完善一下`Listener`代码，如下：

```js
// 移动核心逻辑
Manager.prototype.listenerFn = function(direction) {
  // 定义一个变量，判断是否引起移动
  let moved = false;

  const { rowPath, columnPath } = this.getPaths(direction);
  for (let i = 0; i < rowPath.length; i++) {
    for (let j = 0; j < columnPath.length; j++) {
      const position = { row: rowPath[i], column: columnPath[j] };
      const tile = this.grid.get(position);
      if (tile) {
        // 当此位置有Tile的时候才进行移动
        const { aim, next } = this.getNearestAvaibleAim(position, direction);

        // 区分合并和移动，当next值和tile值相同的时候才进行合并
        if (next && next.value === tile.value) {
          // 合并位置是next的位置，合并的value是tile.value * 2
          const merged = new Tile(
            {
              row: next.row,
              column: next.column
            },
            tile.value * 2
          );
          //将合并以后节点，加入grid
          this.grid.add(merged);
          //在grid中删除原始的节点
          this.grid.remove(tile);
          moved = true;
        } else {
          this.moveTile(tile, aim);
          moved = true;
        }
      }
    }
  }

  // 移动以后进行重新渲染
  if (moved) {
    this.render.render(this.grid);
  }
};
```

在上面代码中，我们新增`Grid`的`remove`方法，用于删除某个`Tile`，逻辑很简单，代码如下：

```js
// grid.js
Grid.prototype.remove = function(tile) {
  this.cells[tile.row][tile.column] = null;
};
```

大家随机刷新页面，直到出现两个 2，然后尝试合并一下两个元素，效果很完美。

#### 5.2 完善游戏步骤

##### TIle合并后置逻辑

当`Tile`合并或移动之后，游戏还得继续，因此每次移动之后，我们让游戏随机再次生成一个`Tile`。

随机生成`Tile`的代码，在初始化的时候已经实现过了，我们需要将这段代码抽离称一个函数，代码如下：

```js
//manager.js

// 随机添加一个节点
Manager.prototype.addRandomTile = function() {
  const position = this.grid.randomAvailableCell();
  if (position) {
    // 90%概率为2，10%为4
    const value = Math.random() < 0.9 ? 2 : 4;
    // 随机一个方格的位置
    const position = this.grid.randomAvailableCell();
    // 添加到grid中
    this.grid.add(new Tile(position, value));
  }
};
```

修改调用区域代码，如下：

```js
// manager.js
Manager.prototype.start = function() {
  for (let i = 0; i < 2; i++) {
    this.addRandomTile();
  }
  this.render.render(this.grid);
};

// 移动核心逻辑
Manager.prototype.listenerFn = function(direction) {
  // ...
  if (moved) {
    this.addRandomTile();
    this.render.render(this.grid);
  }
};
```



整个游戏已经初具模型了，大家可以自己玩一玩，恭喜大家，到现在为止，我们已经完成 80%的功能。 接下来，我们将完善**积分系统**，完善**移动合并动画**，完善**本地存储历史记录**功能。
