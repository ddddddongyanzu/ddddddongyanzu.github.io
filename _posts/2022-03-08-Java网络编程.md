---
Layout: post
desc: java网络编程
title: java网络编程
tag: study
---

## Java 网络编程

### <1> HTTP协议原理

#### 1.1 协议

通过网页，就能打开网页`https://www.douban.com/` 就可以访问网页等主页

##### 协议定义

​	协议，网络协议的简称，网页协议是通信计算机双方必须共同遵从的一组协议。

##### HTTP/HTTPS 协议

目前的两种协议，HTTP和HTTPS。区别如下

`	端口区别（80｜443）数据传输区别（明文传输｜加密传输）真假网站识别（很容易被复制｜使用证书很难被复制）门槛（不需要证书｜需要Gworg机构颁发证书，需要一定成本）安全性区别（很容易劫持，跳转到其他网站｜加密安全，很难劫持，交易数据加密）`

#### 1.2 URL

这个页面的地址比较复杂。地址栏输入的地址，叫做`URL(Uniform Resource Locator)`

```html
https://www.douban.com/gallery/topic/116390/?from=hot_topic_note&sort=new
```

格式说明:

- 协议类型与域名以 `://`（固定写法）分隔。
- 路径 （英文常称为path）以单斜杠`/`开头，中间每层的分隔符也是单斜杠`/`。
- 参数:

​			路径与参数之间用`？`分隔。

​			多个参数之间用`&`分隔

​			参数用"参数名=参数值" (key = value ) 的格式表示

端口号：

​			域名后面的 :4000 :8000 :443 : 80 这些端口

### <2> 简单API调用

#### 2.1 Get请求

例如"中国科学技术大学"的网址（`https://www.ustc.edu.cn/`):

​	`Java`通过在`pom.xml`依赖中安装一个库`Okhttp3`以实现简单、快速的实现`HTTP`调用。

`pom.xml文件中的依赖为`

```xml
<!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp -->
<dependency>
 <groupId>com.squareup.okhttp3</groupId>
 <artifactId>okhttp</artifactId>
 <version>4.1.0</version>
</dependency>
```

唯一的`<dependencies>`标签中, 包括多个<dependency>标签，每个标签表示一个依赖库.



使用`Okhttp3`完成页面请求，需要三大步骤:

1. 实例化`OkhttpClient`。使用`okHttpClient okHttpClient = new OkHttpClient();`

2. 执行调用。

- 在执行调用之前，需要实例化一个`Request`对象，作用是定义请求的各种参数

`Request request = new Request.Builder().url(url).build();`

- 然后构造调用对象

`Call call =okHttpClient.newCall(request);`

- 最后执行调用，如果调用失败可能抛异常，所以抓取异常。`call。execute()`就是调用代码.

3. `Call.execute()`返回的其实是一个可执行的结果对象，调用对象的方法既可以获取返回的字符串内容；

`call.execute().body().string();`



以上都是固定写法，一般都会将其固定步骤封装在一个getContent()方法里，容易复用和理解.



由于`call.execute().body().string();`可以取得服务器返回的具体内容。

在`console`中有大量的文本内容，这是给浏览器识别的内容，包括了许多无效的内容。所以很多时候，我们使用程序调用API，获得到需要的数据。



API : Application Programming Interface , 应用程序接口，API一般是指一些预先定义的函数，目的是为开发人员快速访问某一程序而不需要了解和访问源码，或理解它内部工作机制的细节。



简单地讲，API可以快速调用某个程序。在计算机中叫做接口

调用API ；

比如查询某个地方的天气

```
http://www.weather.com.cn/data/sk/101210106.html
```

把这个 URL 贴到浏览器，可以看到查询返回结果为：



```json
{
  "weatherinfo": {
    "city": "浣欐澀",
    "cityid": "101210106",
    "temp": "24",
    "WD": "鍖楅",
    "WS": "灏忎簬3绾�",
    "SD": "77%",
    "AP": "1000.7hPa",
    "njd": "鏆傛棤瀹炲喌",
    "WSE": "<3",
    "time": "17:50",
    "sm": "3.6",
    "isRadar": "0",
    "Radar": ""
  }
}
```

返回的内容没有大量多余的字符，`API`返回的内容统称为`数据`

代码用法:



```java
public class GetPage {

  /**

   * 根据输入的url，读取页面内容并返回
     */
    public String getContent(String url) {
					OkHttpClient okHttpClient = new OkHttpClient();
					Request request = new Request.Builder().url(url).build();
					Call call = okHttpClient.newCall(request);
		// 返回结果字符串
		String result = null;
		try {
  			result = call.execute().body().toString();	
					} catch (IOException e) {
  					e.printStackTrace();
								}
				return result;} 
```
```java
public static void main(String[] args) {
    GetPage getPage = new GetPage();
    String url = "https://www.fastmock.site/mock/3d95acf3f26358ef032d8a23bfdead99/api/musicRankings";
    String content = getPage.getContent(url);
		System.out.println("API调用结果");
		System.out.println(content);  }
}
```
#### 2.2 POST表单数据

post()方法

`Okhttp3`库也支持`post`操作。前面学习的调用`API`属于`get`操作。不同的是，`POST`操作时，数据不是放在`URL`中的，而是放在表单中提交的。

所以需要构建一个`FormBody`表单对象，用于放置表单对象，用于放置表单数据。

```java
Builder builder = new FormBody.Builder();
// 设置数据，第一个参数是数据名，第二个参数是数据值
builder.add("", "");
FormBody formBody = builder.build();

Request request = new Request.Builder().url(url).post(formBody).build();
```

与`Get`请求差别如上。在发送表单数据的过程，封装`postContent()`方法，方便重用。





```java
public class FormPoster {

  public String postContent(String url, Map<String, String> formData) {
    // okHttpClient 实例
    OkHttpClient okHttpClient = new OkHttpClient();
    //post方式提交的数据
    FormBody.Builder builder = new FormBody.Builder();
    // 放入表单数据
    for (String key : formData.keySet()) {
      builder.add(key, formData.get(key));
    }
    // 构建 FormBody 对象
    FormBody formBody = builder.build();
    // 指定 post 方式提交FormBody
    Request request = new Request.Builder()
            .url(url)
            .post(formBody)
            // addHeader("Referer", ...) 这个知识点在后面的章节中学到，目前不要纠结
            .addHeader("Referer", "https://www.taobao.com")
            .build();
		// 使用client去请求
		Call call = okHttpClient.newCall(request);
		// 返回结果字符串
		String result = null;
		try {
  	// 获得返回结果
  	result = call.execute().body().string();
		} catch (IOException e) {
  	// 抓取异常
  	System.out.println("request " + url + " error . ");
  	e.printStackTrace();
		}
		return result;  }


```
```java
public static void main(String[] args) {
    String url = "http://tcc.taobao.com/cc/json/mobile_tel_segment.html";
Map<String, String> formData = new HashMap();
formData.put("tel","18370136568");

FormPoster poster = new FormPoster();
String content = poster.postContent(url, formData);
  
System.out.println("API调用结果");
System.out.println(content);  }
}
```
#### 2.3 POST JSON 数据

除了提交表单数据，也经常用到提交`JSON`数据。

跟表单数据提交方法一样，也是调用`post();`方法，只是参数不再使用`FormBody`对象，而是使用`RequestBody`

1. 将数据转化成 `JSON`格式的字符串，调用`JSON.toJSONString()`方法即可
2. 创建`RequestBody`实例，需要指定的提交类型是`application/json;charset=utf-8`

3. 构建 `Request`实例对象时，调用`.post(requestBody)`即表示使用`JSON`的方法提交数据。



```java
public class JsonPoster {

  private static final MediaType JSON_TYPE = MediaType.parse("application/json;charset=utf-8");

  /**

   * 向指定的 url 提交数据，以 json 的方式
     */
  public String postContent(String url, Map<String, String> datas) {
	// okHttpClient 实例
	OkHttpClient okHttpClient = new OkHttpClient();

	// 数据对象转换成 json 格式字符串
	String param = JSON.toJSONString(datas);
	//post方式提交的数据
	RequestBody requestBody = RequestBody.create(JSON_TYPE,param);

	Request request = new Request.Builder().url(url).post(requestBody).build();

	// 使用client去请求
	Call call = okHttpClient.newCall(request);
	// 返回结果字符串
	String result = null;
	try {
  // 获得返回结果
  result = call.execute().body().string();
	} catch (IOException e) {
  // 抓取异常
  System.out.println("request " + url + " error . ");
  e.printStackTrace();	
	}
	return result;  }
```




```java
public static void main(String[] args) {
    JsonPoster jsonPoster = new JsonPoster();
    String url = "https://www.fastmock.site/mock/3d95acf3f26358ef032d8a23bfdead99/api/posts\n" +
            "\n";
    Map<String, String> datas = new HashMap();
    datas.put("num","20190101");
    datas.put("name","王陆");
    datas.put("gender","男");
    datas.put("faculty","灵剑派");
    datas.put("discipline","无相剑骨");
    datas.put("class","一年一班");
    datas.put("startYear","2019");
		String content = jsonPoster.postContent(url,datas);

		System.out.println("API调用结果");
		System.out.println(content);  }
}
```

### <3> Request Response 对象

#### 3.1 Response -网页

为了获得响应的状态的状态码，可以使用`call.execute().code();`

通常即需要响应内容，也需要响应码的话，不能执行两次请求，一般使用

`import okhttp3.Response`

```java
// 执行请求
Response rep = call.execute();
// 获取响应状态码
int code = rep.code();
// 获取响应内容
String content = rep.body().string();
```

#### 3.2 Response -非文本文件

`Java`使用`okhttp3`库除了可以获取网页状态码和返回的文本内容，还可以请求到`图片`、`excel`等各种文件

图片文件的内容不是可以直接阅读的字符文本，只是二进制编码，需要软件解析图片的二进制编码数据，才能还原成图像显示。

使用`response.body().bytes();`获取返回的内容

```java
package com.youkeda.test.http;

import java.io.IOException;
import okhttp3.Call;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

public class ExcelAsker {

  /**
   * 根据输入的url，读取页面内容并返回
   */
  public void getFile(String url) {
    // okHttpClient 实例
    OkHttpClient okHttpClient = new OkHttpClient();
    // 定义一个request
    Request request = new Request.Builder().url(url).build();
    try {
      // 执行请求
      Response response = okHttpClient.newCall(request).execute();
      byte[] bytes = response.body().bytes();
      System.out.println("excel 大小为： " +  bytes.length + " 字节");
    } catch (IOException e) {
      // 抓取异常
      System.out.println("request " + url + " error . ");
      e.printStackTrace();
    }
  }

  public static void main(String[] args) {
    String url = "https://style.youkeda.com/img/ham/course/py2/china-city-list.xlsx";
    ExcelAsker asker = new ExcelAsker();
    asker.getFile(url);
  }
}
```

#### 3.3 Response -JSON

对于经常调用`API` 的我们来说，很多`API`返回的文本内容是`JSON`格式的。

`JSON`是一段文本，也就是`Java`的字符串,是难以进行解析具体内容的，必须转换成`Java`的对象

前面已经使用过`fastjson`库把参数对象转换成`JSON`格式字符串，当然也可以把`JSON`转换成`Java`对象，方便后面分析。

```java
JSON.parseObject(String content , Map.class);
```

代码如下

```java
package com.youkeda.test.http;


import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.alibaba.fastjson.JSON;
import okhttp3.Call;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

public class ApiAsker {

  /**
   * 根据输入的url，读取页面内容并返回
   */
  public String getContent(String url) {
    // okHttpClient 实例
    OkHttpClient okHttpClient = new OkHttpClient();
    // 定义一个request
    Request request = new Request.Builder().url(url).build();
    // 使用client去请求
    Call call = okHttpClient.newCall(request);
    // 返回结果字符串
    String result = null;
    try {
      // 执行请求
      Response response = call.execute();
      // 获取响应内容
      result = response.body().string();
    } catch (IOException e) {
      // 抓取异常
      System.out.println("request " + url + " error . ");
      e.printStackTrace();
    }
    return result;
  }

  public static void main(String[] args) {
    String url = "https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&cr=1&flag_qc=0&p=1&n=30&w=西海情歌&format=json";
    ApiAsker asker = new ApiAsker();
    String content = asker.getContent(url);

    System.out.println("查询结果文本：" + content);
    Map contentObj = JSON.parseObject(content,Map.class);
    System.out.println("JSON 格式字符串转换为 Map 对象");
  }
}
```

#### 3.4 解析JSON对象

对于解析调用的`API`结果，只需要多次取出嵌套的`Map`对象即可。

Map contentObj = JSON.parseObject(content , Map.class);

Map dataObj = (Map)contentObj.get("data");

String city = (String)dataObj.get("city");

因为`Map`可以存储任何对象，所以`Map`中`get()`到的对象必须指定其实际的类型：`(Map)、(String)`

```json
{
  "code": 0,
  "data": {
    "ip": "117.89.35.58",
    "country": "中国",
    "area": "",
    "region": "江苏",
    "city": "南京",
    "county": "XX",
    "isp": "电信",
    "country_id": "CN",
    "area_id": "",
    "region_id": "320000",
    "city_id": "320100",
    "county_id": "xx",
    "isp_id": "100017"
  }
}
```

代码省略

```java
Map contentObj = JSON.parseObject(content, Map.class);
Map dataObj = (Map)contentObj.get("data");
String city = (String)dataObj.get("city"); //解析出南京
```

### <4> headers

#### 4 反爬虫(User-Agent/Referer/Host)

有些时候，有些`API`请求无法成功，这个时候就需要将`Java`程序请求模拟成一个真实的浏览器访问。

```java
Request request = new Request.Builder()
    .url(url)
    .addHeader("User-Agent", "...")  //用于请求Http不成功的情况
 		.addHeader("Referer","...") //用于解决程序访问图片失败情况
  	.addHeader("Host","...") //实现虚拟主机的作用
    .build();
```

### <5> 下载文件图片

#### 5.1 下载文件

在第3章第2节我们学习了如何请求图片、excel等文件，此类二进制文件无法把内容输出在 `console` 进行查看的，所以请求结果必须写入文件。

本节我们就来一起学习如何写文件。在 `Java` 中写文件必须经历三个步骤：

```
创建文件对象
   ↓
写入内容
   ↓
关闭写入操作
```

打开和关闭的步骤，是为了确保同一个文件同时只能被一个程序写，否则内容会错乱。

##### 写入文本文件

在程序中写入字符串内容的语句：

```java
import java.io.File;
import java.io.FileWriter;

// 文件对象
File file = new File("foo.txt");

// 写入内容
FileWriter fileWritter = new FileWriter(file.getName());
fileWritter.write(content);

// 关闭
fileWritter.close();
```

> `File` 是文件类，`FileWriter` 是用来给文件写入内容的类。再次强调，写入文件类必须执行关闭操作。

可以看到，`foo.txt` 文件已经生成了。点击可以查看我们刚刚写入的字符内容。

##### 写入二进制文件

当然，写入的内容不限定是文本，excel等二进制文件也可以。

第3章第2节的作业中，我们请求了一个 excel 文件（网址 `https://style.youkeda.com/img/ham/course/py2/china-city-list.xlsx`），文件的数据类型是 `byte[]`。

假设文件数据的变量是 `byte[] data`，那么写入本地文件的代码如下：

```java
import java.io.File;
import java.io.FileOutputStream;

// 文件对象
File file = new File("china-city-list.xlsx");

// 写文件
FileOutputStream fos = new FileOutputStream(file);
fos.write(data);

// 必须刷新并关闭
fos.flush();
fos.close();
```

> 与写入文本内容不同，写入二进制内容，需要用 `FileOutputStream` 。再次强调，必须执行刷新、关闭操作。

请求完毕并且已经已经正确生成了 `china-city-list.xlsx`

#### 5.2 下载图片

下载图片与下载其它文件别无二致。而且图片都是二进制文件，不像其它类型的文件还要考虑是否文本文件。

#### 5.3 解析excel

前面我们已经学了如何下载文件，下载后点击文本文件、图片，都可以直接查看其内容，另一种常见的文件是 `excel` 文件，但正常情况下需要 `office` 软件才能读取。

实际上，`Java` 很强大，已经有库可以操作　`excel` 文件了。

##### 依赖库

easyexcel 是阿里巴巴出品的快速、简单操作　`excel` 文件的库。使用前必须在 `pom.xml` 文件中加入对库的依赖。。

```xml
<dependency>
  <groupId>com.alibaba</groupId>
  <artifactId>easyexcel</artifactId>
  <version>3.1.1</version>
</dependency>
```

##### 调用库

大家都知道，`excel` 文件是多 `sheet` 模式的，每个 `sheet` 实际上是一个表格，表格又分为行和列。

所以解析数据的路径一定是：`sheet -> 行 -> 列`

> 牢记计算机中，第一个单元格的位置是 `0` 。`第一个sheet`、`第一行`、`第一列`的位置是 `0,0,0`

我们在第一节的作业中已经下载了 `xzq_201907.xlsx` 文件，以此为例，解析其内容。

```java
import com.alibaba.excel.EasyExcel;
import java.util.Map;
import java.util.List;

// 读取第一个sheet
List<Map<Integer, String>> sheetDatas = EasyExcel.read("xzq_201907.xlsx").sheet(0).doReadSync();
// List 中每个元素表示一行
for (Map<Integer, String> rowData : sheetDatas) {
  // Map 中用序号指代每一列
  for (Integer index : rowData.keySet()) {
    // 列值
    String columnValue = rowData.get(index);
  }
}
```

解析文件的第一个步骤是读取文件内容，调用 `EasyExcel.read()` 方法，传入文件名称。然后这里解析的 **第一个** 工作表，所以调用 `sheet()` 方法，传入参数 **0** 。最后的 `doReadSync()` 表示同步方式读取文件内容，返回一个读取到的内容集合 `List` 。这是一个连贯的写法。

返回的 `List` 集合中，系统用 `Map` 类表示一行数据（因为系统不知道 `excel` 对应什么具体的对象，其实 `Map` 可以当做一种通用的对象）

下图帮助大家理解 *excel* 内容与 *Java* 集合之间的关系。

![示意图](https://style.youkeda.com/img/ham/course/py2/j14-5-3-1.svg)

> 大家对照图示与代码，理解每个语句的作用和含义，掌握步骤即可。其实也不用特别背诵，当开发需要用的时候把本节课的内容复习即可。关键还是学会使用。

> 大家可以把`xzq_201907.xlsx`文件的链接贴到浏览器地址栏中，下载到本地打开看内容，与程序的输出结果进行对照哦。

##### 小知识点

`System.out.print()` 输出后不自动换行，等遍历完一行数据（即一个Map对象）后，使用 `System.out.println()` 输出一个空行，更加直观。

##### 自动转换为类

在不能提前确定 `excel` 文件每一列的含义时，或者复杂场景下 `excel` 文件的列经常变化，用 `Map` 表示每一列的数据比较好。

但是如果知道 `excel` 文件每一列的含义，用**自定义类**来表示，会更加直观。

```java
import com.alibaba.excel.EasyExcel;
import java.util.List;

// 读取第一个sheet
List<DemoData> sheetDatas = EasyExcel.read("xzq_201907.xlsx").head(DemoData.class).sheet(0).doReadSync();
```

注意这里多调用了一个方法：`.head(DemoData.class)`，`DemoData` 就是自定义的类，表示**一行**数据，类的每个属性都表示**一列**的值。

> Map 更灵活，自定义类更直观易理解。一般列数不太多（不超过 10 个）、不会变化，用自定义类

返回值为 `List<DemoData>` 就表示把**每一行**都转换为一个 `DemoData` 的**实例**对象，放入 `List` 集合中。

```java
// 属性定义的顺序必须与列顺序保持一致
public class DemoData {
  private String code1;
  private String city1;
  private String code2;
  private String city2;
  private String code3;
  private String city3;
}
```

下图帮助大家理解 *excel* 内容与 *自定义类* 之间的关系。

![示意图](https://style.youkeda.com/img/ham/course/py2/j14-5-3-2.svg)

code1 是**第一个**属性，映射 excel 文件**第一列**的值。这是为了让大家易懂，在属性名上加了数字，实际上，即使属性名是 `code10000` ，只要放在最前面，就映射**第一列**的值。

> 注意 excel 表的列与自定义类的属性，是按顺序一一对应的，不是按名称哦。

##### 总结

无论转换为自定义的类还是 `Map`，`EasyExcel.XXXXXX.doReadSync()` 最终返回的都是一个集合 `List` 。大家一定要理解的是，集合中的每一个元素，即每一个实例对象（无论是自定义类还是 Map），都表示**一行**数据。

大家在学习的过程中，不能只看代码。而是要用 **Microsoft Excel** 软件把文件打开，仔细对比文件内容与 `console` 输出结果，务必要理解文件中每一行、每一列、每个单元格的值，跟 java 类（无论是自定义类还是 `Map`）之间的关系是什么。

> 学编程会越来越多的面对抽象而复杂的问题，大家的思维必须能够从具体（文件）跨越到抽象（java 类）。

### <6> cookie & session

#### 6.1 cookie

前面我们学习 `Okhttp3` 库可以调用`API`、抓取网页、下载文件。但是这些操作都是不要求登录的，如果 `API`、网页、文件等内容要求登录才能访问，就需要学习新的 cookie 相关的知识了。

下面以豆瓣为例，使用 `Java` 程序读取“我的豆瓣”页面内容，在此过程中熟悉运用 `cookie` 。

所谓 *cookie* ，是存储在客户端浏览器中的一段文本内容。以 `key=value` （数据名称、数据值）的格式存储一条数据；多条数据之间用分号 *;* （英文半角）分开。由于各种浏览器都对 *cookie* 大小和数量有限制，所以 *cookie* 目前的核心功能是存储登录数据；额外可以存储一些小数据，比如 `是否登录=true;昵称=张三` 这样的内容不大的数据。

> InternetExplorer 限制 cookie 为每个域名 50 个，上限 4095 个字节。Firefox 每个域名 cookie 限制为 50 个，上限 4097 个字节。每种浏览器略有异同，但肯定都有限制。

##### 1.前期准备

在浏览器输入 `https://www.douban.com/mine` 打开“我的豆瓣”页面。这个页面是必须登录的。

![豆瓣登录](https://style.youkeda.com/img/ham/course/py2/py2-6-1-3.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

登录完成以后，可以正确看到“我的豆瓣”页面了。

![我的豆瓣](https://style.youkeda.com/img/ham/course/py2/py2-6-1-4.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

> 注意：登录信息是存放在 `cookie` 里的

所以，必须先找到登录后的 `cookie`，这是完成 `Java` 程序的重要的前提条件。

##### 2.找到 `cookie`

打开谷歌浏览器的开发者工具（**使用谷歌浏览器**），切换到 **Network** 菜单项，如下图所示第一步：

> 对谷歌开发者工具不熟悉的，可以点击查看 [使用教程](https://www.cnblogs.com/yaoyaojing/p/9530728.html)

![豆瓣点赞登录](https://style.youkeda.com/img/ham/course/py2/py2-6-1-5.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

**如果没有 mine ，就选第一个跟浏览器地址栏相同的 URL 请求**

按照图中所示的四个步骤，把 `cookie` 的值（`Cookie:` 后的内容哦，不包括 `Cookie:`）拷贝下来，放入一个 `cookie.txt` 文件中。

> cookie 的内容很长，而且看不懂。因为 cookie 中除了登录信息，还能放其它信息，大多是加密过的。但没关系，这些信息是给计算机看的。

我们需要编码把 `cookie` 信息字符串转换为 `Map` 类型的数据。

##### 3.编码实现

实际上，程序我们前面练习过，就是使用 `Okhttp3` 库完成 `get` 请求而已。

> 会用到前面的知识，特别是第 **4** 章第 **1**、**2** 节的内容，不熟悉的同学复习一下。

上图中可以看到，浏览器在发送请求的时候，自动带上了 `Host`、`User-Agent` 内容哦。

这样，所需的数据都已识别完毕，我们先看一下演示程序。系统提供了一个工具类，用于从 `cookie.txt` 文件读取内容。

大家可以看到，`Cookie` 也是存放在 `header`中。

#### 6.2 session

上节课使用了谷歌浏览器的开发者工具抓取到了登录的 `cookie` ，然后使用程序完成登录。

但 `cookie` 的弊端是，`cookie` 是存放在客户端浏览器的，而且是临时的，登录后还想以登录状态与服务器通讯，就比较麻烦。

这就需要在程序中使用 `Session` 对象来解决这个问题。下面我们通过模拟登录时光网来学会如何应用 `Session` 对象。

##### 1.时光网登录

浏览器中输入`http://www.mtime.com/` 打开时光网，点击右上角的**登录**按钮；

如果没有看到输入框，可以点击角落电脑图标切换：

![时光网1](https://style.youkeda.com/img/ham/course/py2/j14-6-2-5.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

弹出登录对话框。

![时光网1](https://style.youkeda.com/img/ham/course/py2/j14-6-2-2.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

或者直接 [点此打开](https://passport.mtime.com/login)注册与登录页面，并点击“会员登录”

![时光网2](https://style.youkeda.com/img/ham/course/py2/j14-6-2-4.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

> 如果没有注册的，先注册，再退出登录，并重复此步骤。
>
> > 如果遇到电脑无法注册时光网的情况，麻烦下载时光网APP，进行注册。

##### 2.收集信息

然后打开谷歌浏览器的开发者工具，如图所示，**Preserve log** 必须勾选。

> 对谷歌开发者工具不熟悉的，可以点击查看 [使用教程](https://www.cnblogs.com/yaoyaojing/p/9530728.html)

###### 关键点

输入用户名和密码后，在右侧抓取到的网络请求中，找到登录请求 *API* ：

```
https://front-gateway.mtime.com/user/user/login.api
```

![时光网3](https://style.youkeda.com/img/ham/course/py2/j14-6-2-3.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

##### 新版浏览器可能有一点不同

在“标头”后面多了一个“载荷”（Payload）的小菜单。

![时光网3](https://style.youkeda.com/img/ham/course/py2/j14-6-2-6.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

切换到小菜单可以看到密码：

![时光网3](https://style.youkeda.com/img/ham/course/py2/j14-6-2-7.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

时光网改版了，所以谷歌浏览器的开发者工具里，输入框输入**login**进行过滤哦。

> 由于改版，视频中有些细节是旧的，例如登录页面是旧版的。但是没关系，操作过程是一样的。

需要收集的关键信息包括：

1. 登录地址
2. 执行方式（GET/POST）
3. HOST
4. Referer
5. User-Agent
6. 表单数据，数据名称和数据值

> 由于每个网站登录相关的信息都不一样，所以必须在手动登录的过程中收集信息。大家学会这个方法，就可以模拟其它网站登录。

##### 3.编码实现

这样，所需的信息都已收集完毕，我们先看一下演示程序：

代码演示



###### 提醒

```java
  // 用 CookieJar 实现 cookie 的存储，便于登录后请求其它 URL 可以复用
  private static final OkHttpClient okHttpClient = new OkHttpClient.Builder()
      .cookieJar(new CookieJar() {
        private final HashMap<String, List<Cookie>> cookieStore = new HashMap<>();

        @Override
        public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
          cookieStore.put("mtime.com", cookies);
          System.out.println("[saveFromResponse]url.host()=" + url.host());
        }

        @Override
        public List<Cookie> loadForRequest(HttpUrl url) {
          System.out.println("[loadForRequest]url.host()=" + url.host());
          List<Cookie> cookies = cookieStore.get("mtime.com");
          return cookies != null ? cookies : new ArrayList<>();
        }
      })
      .build();
```

- `CookieJar` 是接口（`interface`），而不是类（`class`）。演示代码中：

  ```java
  new CookieJar() {......}
  ```

  是匿名类。关于匿名类，匿名类的概念感兴趣自行阅读资料。

#### 6.3 复用session

上节课我们完成了模拟登录。模拟登录的目的，还是为了能够调用必须登录的API、或请求必须登录的网页等。

其实，为我们只需要在上节课登录成功的基础上，使用 `session` 对象再次发出请求即可完成这些必须登录的请求。

我们先来看案例演示：

请求“个人设置”页面（`http://my.mtime.com/personal/personInfo`）：

##### 实现

不知道大家注意没有，在上一节中，我们把 `OkHttpClient` 对象进行重构，不再定义为 `postContent()` 方法的变量。

而是改为类变量：`private static final OkHttpClient okHttpClient` ，目的就是在整个类中，使用同一个 `okHttpClient` 执行 `HTTP` 请求，提升效率。重构在本节课就派上用场了。

请看代码演示：

代码演示



分析执行两次请求的过程，实际上过程是类似的，区别是 `Request` 不同，所以，又做了一次重构，把真正执行的过程封装成一个方法：`doExcute` ，被其它 `postContent()` 和 `getContent()` 方法调用。

> 这么做就是抽象的过程，目的是减少重复代码，提高可阅读性和可维护性。重构会伴随我们整个编程的生涯。请大家认真体会这个过程，还可以动手试一下，如果不重构，代码会是什么样的？

##### 小知识点

- `static` 表示类变量，意味着无论 `new` 出多少个 `PageLoginer` 对象，`PageLoginer.okHttpClient` 都只有一个。
- `final` 表示 `okHttpClient` 一旦第一次 `new` 出对象后，不能再次 `new`

### <7> 实战-SMTP与邮件

#### 7.1 SMTP

在生活中，邮件无处不在。

##### E-Mail

大家是不是也经常订阅一些新闻邮件，比如：

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/1.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

突然收到一些邮件广告，比如：

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/2.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

还有 github issue 回答提醒，比如：

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/3.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

大家是否都在想象某一天自己都能实现一个定时、定期发送邮件的程序？

好，今天我们就来学习下如何利用 Java 代码发送邮件。

在写代码之前，我们先来了解一些基础的概念和协议。

##### SMTP 协议

SMTP 是一个简单的基于文本的邮件传输协议，全称为（Simple Mail Transfer Protocol - 简单邮件传输协议）。在这个协议上我们可以指定一条邮件消息和一个或多个邮件接收者，然后进行邮件输出。

可能大家觉得还是比较抽象。

我们先回顾下在之前的 HTTP 章节，我们了解了普通的网络请求。一个网络地址 https://www.youkeda.com/ 代表的是优课达官网，并且可以通过浏览器访问，这个网络地址由 `HTTPS` 协议和 `www.youkeda.com` 网络地址组成。

同样的道理 SMTP 协议再加上一个服务器地址是不是就组成一个邮件访问方式。所有邮件服务商都有自己的邮件服务器地址

比如：

- QQ 邮箱： smtp.qq.com
- 163 邮箱: smtp.163.com

通过地址和协议，我们便具有`发送邮件`的基础通道。使用 Java 或其它编程语言，可以使用 `SMTP` 完成邮件的发送，不必打开网页登录邮箱发送邮件了。

#### 7.2 JavaMail邮件发送

##### SMTP 应用

这节课是重中之重，在本节课中，我们将实现如何使用代码，利用自己的 QQ 邮箱发送邮件。在上一节中，我们大致了解的 SMTP 协议，在使用 QQ 邮箱发送邮件时，我们需要先进入 QQ 邮箱开启 SMTP 支持。

##### 开启 QQ 邮箱设置

1. 打开 QQ 邮箱网页版
2. 在 QQ 邮箱头部找到邮箱设置，切换到账户下面，如图

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/4.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

1. 往下面翻，开启和 SMTP 有关的服务，如图前两项

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/5.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

1. 开启过程中可能会有各种验证，最终会得到授权码，如图

![图片](https://style.youkeda.com/img/ham/course/j3/j3-8/6.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

> 一定要保存授权码啊

###### 注意

- 授权码**没有空格**，只是 QQ 邮箱为了分段显示而已。
- 授权码**不是**邮箱的登录密码哦，不要混淆了。

##### JavaMail

在 Java 中我们可以调用 JavaMail 调用发送和接收邮件，我们首先配置 maven 依赖，如 pom 文件中加入

```xml
<dependency>
 <groupId>javax.mail</groupId>
 <artifactId>mail</artifactId>
 <version>1.4</version>
</dependency>
```

然后如下发送代码。代码属于固定用法，只需要修改邮箱相关的配置即可。

```java
import java.security.Security;
import java.util.Properties;
import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class MailClient {
  public static void main(String[] args) {
    try {
      final String SSL_FACTORY = "javax.net.ssl.SSLSocketFactory";

      //配置邮箱信息
      Properties props = System.getProperties();
      //邮件服务器
      props.setProperty("mail.smtp.host", "smtp.qq.com");
      props.setProperty("mail.smtp.socketFactory.class", SSL_FACTORY);
      props.setProperty("mail.smtp.socketFactory.fallback", "false");
      //邮件服务器端口
      props.setProperty("mail.smtp.port", "465");
      props.setProperty("mail.smtp.socketFactory.port", "465");
      //鉴权信息
      props.setProperty("mail.smtp.auth", "true");
      //建立邮件会话
      Session session = Session.getDefaultInstance(props, new Authenticator() {
        //身份认证
        protected PasswordAuthentication getPasswordAuthentication() {
          //1.账户 授权码
          return new PasswordAuthentication("xxxxxxx@qq.com", "xxxx");
        }
      });
      //建立邮件对象
      MimeMessage message = new MimeMessage(session);
      //设置邮件的发件人
      message.setFrom(new InternetAddress("xxxxxxx@qq.com"));
      //2.设置邮件的收件人
      message.setRecipients(Message.RecipientType.TO, "xxxxxxx@qq.com");
      //设置邮件的主题
      message.setSubject("通过javamail发出！！！");
      //文本部分
      message.setContent("文本邮件测试", "text/html;charset=UTF-8");
      message.saveChanges();
      //发送邮件
      Transport.send(message);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

> 注意：演示视频是旧版本的，要去掉 `import com.sun.net.ssl.internal.ssl.Provider;` 和 `Security.addProvider(new Provider());` 代码

代码运行是失败的，因为授权码错误了。

必须填入自己的邮箱及**正确的****授权码**。

##### 特别说明

1. 注释 1 中账户和授权码**改为**你的 QQ 号和刚才申请保存的授权码
2. 注释 2 中 message.setRecipients 可以设置多个收件人信息
   - 用逗号分割多个收件人`xxxx@qq.com,xxxx@126.com`
3. 所有 xxxx 都改为自己的邮箱地址，否则你看不到邮件内容哦。

<iframe src="https://apps.youkeda.com/chat?courseId=j14" frameborder="0" class="w-full h-full absolute inset-0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" data-v-34ccd054="" style="box-sizing: border-box; border-width: 0px; border-style: solid; border-color: rgb(229, 231, 235); --tw-shadow:0 0 #0000; --tw-ring-inset:var(--tw-empty, ); --tw-ring-offset-width:0px; --tw-ring-offset-color:#fff; --tw-ring-color:rgba(59, 130, 246, 0.5); --tw-ring-offset-shadow:0 0 #0000; --tw-ring-shadow:0 0 #0000; display: block; vertical-align: middle; height: 708px; position: absolute; inset: 0px; width: 860px;"></iframe>

### <8> 实战-天气预报

#### 8.1 查询城市代号

在查找天气情况时，我们首先要确认我们需要查询的城市编号，简单获取城市编号有两种方式

##### 文件查询城市代号

手动下载城市代码的 `excel` 文件到本地电脑：[china-city-list.csv](https://style.youkeda.com/img/ham/course/j3/china-city-list.csv)

在 `excel` 文件中，搜寻你所在的城市，获取第一列中的城市代号

比如：`余杭`（`杭州`） 第一列的 `CN101210106` 城市编号为 `101210106`

这是已经收集好的城市代码。来源主要有两种方式：

###### 1. 天气官网查询获取城市代号

- 在天气官网 [http://www.weather.com.cn](http://www.weather.com.cn/) 输入你想要的城市

  ![查询城市](https://style.youkeda.com/img/ham/course/j3/j3-9/1.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

- 然后跳转到的页面，从连接地址中提取如下图红框所示

  ![提取城市代号](https://style.youkeda.com/img/ham/course/j3/j3-9/2.png?x-oss-process=image/resize,w_1024/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

###### 2. 从天气官网搜索地址 API 获取城市代号

api 地址为：[http://toy1.weather.com.cn/search?cityname=%E4%BD%99%E6%9D%AD](http://toy1.weather.com.cn/search?cityname=余杭)

其中 [%E4%BD%99%E6%9D%AD](http://toy1.weather.com.cn/search?cityname=余杭) 是`余杭`的 Encode 码，大家可以在浏览器中打开查看。

当然搜索出来的结果并不是唯一的，需要二次确认。

搜索出来乱码问题，是由于浏览器没有正确识别字符编码。

大家找寻自己想要查询的城市代号

#### 8.2 查询城市天气

在上一节中，我们查到 **杭州** － **余杭** 区代号是 **101210106**

这一节我们将调用 *API* 查询 ***\*余杭\**** 区的天气。

中国天气官网查询实时天气的 *API* 为：http://www.weather.com.cn/data/sk/101210106.html

> 解读一下，其中的 101210106 就是余杭区代码。

如果要查询其它城市，需要使用上一节的方法，查到城市代码，然后把这个网址中的这段数字进行替换。

把这个 *API* 贴到浏览器，可以看到查询返回结果为：

```json
{
  "weatherinfo": {
    "city": "浣欐澀",
    "cityid": "101210106",
    "temp": "24",
    "WD": "鍖楅",
    "WS": "灏忎簬3绾�",
    "SD": "77%",
    "AP": "1000.7hPa",
    "njd": "鏆傛棤瀹炲喌",
    "WSE": "<3",
    "time": "17:50",
    "sm": "3.6",
    "isRadar": "0",
    "Radar": ""
  }
}
```

之所以在浏览器中查看结果显示乱码，是由于浏览器没有正确识别字符编码。但是用程序获取就不会了。

利用前面所学知识，使用 *OkHttp* 调用此 *API* 获取结果，打印出来是：

```json
{
  "weatherinfo": {
    "city": "余杭",         // 城市
    "cityid": "101210106",  // 城市代码
    "temp": "24",           // 温度
    "WD": "北风",           // 风向
    "WS": "小于3级",        // 风力等级
    "SD": "77%",           // 湿度
    "AP": "1000.7hPa",     // 气压
    "njd": "暂无实况",      //实况
    "WSE": "<3",
    "time": "17:50",
    "sm": "3.6",
    "isRadar": "0",
    "Radar": ""
  }
}
```

我们可以看到，这是一个 *Json* 数据结构的字符串，比如温度（`temp`）为 **24** ，单位是摄氏度。

从这个结构中，可以方便的获取天气的详细信息。

8.3 天气邮件推送

1. 把上一节中的天气信息，按你喜欢的方式进行组装
2. 利用发送邮件的方式推送给自己

发送邮件完毕后，在 console 打印：“Send complete” 信息。

> 如果完成的比较顺利，可以完成如下附加题

优化邮件内容支持 HTML 渲染，可以查看资料 JavaMail 中 MineMessage 如何传递 HTML 内容
