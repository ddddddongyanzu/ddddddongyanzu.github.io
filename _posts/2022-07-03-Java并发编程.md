---
Layout: post
desc: java并发编程
title:  java并发编程
tag:  study
---

## Java并发编程

### <1> Lambda表达式

#### 1.1 简介

​	Java 8 是Java 语言史上的一个重要里程碑，更新了许多新特性，包括**Lambda** 、流和函数式编程等等。这些特性可以使代码更简洁，易阅读、易维护。Java程序员必须掌握这些新特性，必须与时俱进。



> 使用Java8新特性开发的新代码



先看一个小例子



有一批水果（仅演示起见省略了类的定义），

```java
List<Fruit> fruits = Arrays.asList(
				new Fruit("香蕉"),
  			new Fruit("苹果"),
				new Fruit("梨子"),
				new Fruit("西瓜"),
				new Fruit("荔枝")
);
```

进行遍历。打印水果的名字：

```java
//使用旧特性	
for( int i = 0 ; i< fruits.size() ; i++ ) {
  Fruit f = fruits.get(i);
  System.out.println(f.getName());
}
```

此时使用新特性

```java
fruits.forEach(f -> {
System.out.println(f.getName());
});
```

从演示上来看，两种遍历循环的方式是等价的，功能相同。但使用新特性的代码更简洁紧凑。



`f ->  {}`，这就是Lambda表达式。

#### 1.2 无类型参数

**Lambda** 表达式的基本结构是：

`f -> {}`

> f 为参数变量 ， -> 为语法符号 ， {} 为语句块
>
> 参数变量是可以自定义的，不是固定的

**Lambda**表达式在功能上等同于一个匿名方法：

```java
public void unknow(f) {
	System.out.println(f.getName());
}
```

> 相当于public void 修饰符都省略了



##### 类型识别

`f`变量的类型是什么呢？类型是系统根据上下文自动识别的。



回顾上一节代码

```java
List<Fruit> fruits = Arrays.asList(......);

fruits.forEach(f -> {
  System.out.println(f.getName());
});
```

`forEach()`方法表示循环遍历`fruits`集合，每次循环时`f`变量指代当前遍历到的元素



由于`fruits`变量的类型使用泛型语法定义为`List<Fruit>`,表示集合中的元素的类型是`Fruit`。

所以，`f`变量的类型自然是`Fruit`,就可以调用`Fruit`类的方法了。



> forEach() 方法是Java集合的循环遍历的方法，暂时先记住这种用法

所以，Lambda 表达式要配合上下文、跟其他方法配合使用，而不是一个独立的语句。这么写的就是错误的：

```java
public static void main(String[] args) {
  args[0] -> {
    System.out.println(args[0]);
  }
}
```

##### 实战案例

我们下面的代码给大家演示一下Collections中sort()方法的排序功能，可以使用Lambda表达式进行代码优化：

```java
List<Student> students = new ArrayList<Student>();
students.add(new Student(111, "bbbb", "london"));
students.add(new Student(131, "aaaa", "nyc"));
students.add(new Student(121, "cccc", "jaipur"));

// 实现升序排序
Collections.sort(students, (student1, student2) -> {
  // 第一个参数的学号 vs 第二个参数的学号
  return student1.getRollNo() - student2.getRollNo();
});

students.forEach(s -> System.out.println(s));
```

代码更加简洁了！请看演示：

> Collections.sort() 方法第二个参数是实现匿名类的new Comparator() {} ， 为什么能使用 Lambda 优化呢？留在后面的章节了解

**Lambda**表达式又有了一些新的写法：

##### 多参数

箭头（->）前表示参数变量，有多个参数的时候，必须使用小括号包裹:`()`

```java
(student1, student2) -> {}
```

##### 无参数

箭头（->）前表示参数变量，**没有参数** 的时候，必须使用小括号：

```java
() -> {}
```

##### 单条执行语句

箭头（->）后的执行语句 **只有一条** 时，可以不加大括号 `{}`包裹

```java
s -> System.out.println(s);
```

大家在写代码时，无论几条语句，都 **推荐** 加上大括号 `{}`，这样代码块的边界明确。



#### 1.3 有类型参数

大多数情况下，使用Lambda表达式的目的是为了代码尽量简洁

，所以尽量省略了参数变量的类型。



如果代码比较复杂，而为了易阅读，易维护，也可以为参数变量制定类型。



```java
fruits.forEach((Fruit f) - > {
	System.out.println(f.getName());
});
```

注意：

​	即使只有一个参数，也必须使用小括号`{}`包裹，不然会出错。



#### 1.4 引用外部变量

**Lambda**表达式`{}`内的执行语句，除了能引用参数变量以外，还可以应用外部的变量。



**以下的写法错误的（从lambda表达式引用的本地变量必须是最终变量或实际上的最终变量）**

```java
List<Fruit> fruits = Arrays.asList(....);
String message = "水果名称：";

fruits.forEach( f -> {
	System.out.println(message + f.getName());
});
message = "";
```



##### 规范一

因为使用Lambda表达式有规范：引用的 局部变量 不允许被修改。



> 即使写在表达式后面也不行

下面代码修改了局部变量也是错误的:

```java
String message;

fruits.forEach(f -> {
  message = "水果名称：";
});
```

> 我们在《Java面向对象》中已经写过`final`关键字，Lambda表达式引用的 局部变量 即使不声明为 `final `,也要具备`final`的特性，变量值初始化后不允许被修改。



##### 下面演示



演示代码中，在表达式外实际值赋值一次的写法是允许的。

```java
String message;
message = "水果名称：";
```

##### 规范二



使用Lambda表达式还有一点需要注意：参数不能与 局部变量 同名 ， 下列写法是错误的：

```java
String f = "水果名称：";
fruits.forEach(f -> {});
```

#### 1.5 双冒号 (::) 操作符

​	java 8 支持了一种新的语法：双冒号 `"::"`，这是一种Lambda 写法，是与 Lambda 表达式相关的一个重要特性。



前面例子中，只有一条执行语句的Lambda 表达式：

```java
List<String> names = Arrays.asList("zhangSan", "LiSi", "WangWu");

names.forEach(n -> {
  System.out.println(n);
});
```

可以进一步简化为：

```java
names.forEach(System.out::println);
```

> 前面已经讲过 `forEach()`的作用是遍历集合

这段代码的重点是使用`::`时，系统每次遍历取得的元素(`n`)，会 自然 作为 参数传递给`System.out.println()`方法打印输出：



`System.out.println`等同于`n->{System.out.println;}`

`::`的语法干脆省略了参数变量，所以读这段代码需要相互关照、并且需要适当的自己脑补。

##### 语法含义

![j5-1-5-1](/Users/dongyanzu/Desktop/j5-1-5-1.svg)



双冒号`::`语法，当然也是不能独立使用的，需要配合特定的方法（后面的章节会介绍的内容）。



##### 不同用法：

用法1: 静态方法调用

下列演示，使用`::`语法调用静态方法：



本案例中，使用`LambdaTest::print`代替`f -> LambdaTest.print(f)`，简化了代码。

用法2: 条用非静态方法



非静态方法怎么调用呢？



`print()`方法不再识别为`static`,于是需要实力变量来调用。



`fruits.forEach(new Lambdatest()::print);`



只是简写了：

```java
LambdaTest lt = new LambdaTest();
fruits.forEach(lt:print);
```

效果是一样的。



实际上，本章开头的案例中,`System.out.println`语句就是调用非静态方法`println()`，因为`System.out`指代的是一个实例对象。只是这个实例对象比较复杂，不是本节重点，这里不需要纠结。



用法3： 多参数

本章第二届课的案例：

```java
Collections.sort(studens.(student1,student2) -> {
	//第一个参数的学号 vs 第二个参数的学号
	return student1.getRollNo() - student2.getRollNo();
}
```

就碰到了多参数的情况，如果把比较多过程定义成一个方法：

```java
private static int compute(Student s1 , Student s2 ) {
		。。。 。。。
		。。。 。。。
}
```

那么，排序过程就可以简写为：

`Collections.sort(students , SortTest::compute);`

注意，系统会**自动**获取上下文的参数，并按照上下文定义的顺序传递给制定的方法。**所谓顺序**就是Lambda表达式`{}中的顺序。`

> 与变量名无关哦。s1，s2 命名只是方便理解

用法4:父类方法



我们在《Java》面向对象中了解，`super`关键字的作用是在子类中引用父类的属性或者方法，那么同样，`::`语法也可以用`super`关键字调用父类的非静态方法。



### <2> Stream API

#### 2.1 简介



Java8 的新特性：`stream` （中文称之为：流）也是很常见且常用的，主要优点是提升开发效率，使代码更干净、简洁（上一章的Lambda表达式中已经有大致了解了）



本章的内容会有些抽象，大家要边学、边动手、边对比、边认真思考。

`Stream` 的主要作用是对集合(`Collection`) 中的数据进行各种操作，增强了集合对象的集合。



大家需要先了解两件事：



##### 一 、不要混淆



与我们在《Spring Web 全栈》第二张第四节中学习的用于操作文件的`InputSteam`完全不同，是完全不同的概念。不要混淆概念了。



##### 二 、 Lambda 表达式

`Stream`经常与 `Lambda`表达式配合使用，所以第一章的内容大家可以经常复习。



#### 2.2 流迭代



在Java中，`Stream`是一个接口（`interface`），当然也有多个实现类，但Java是面向接口编程的，我们暂时不用关心具体有哪些实现类，先学会使用`Stream API`

> 在接口中提供了操作数据的方法，通常我们叫做`API`



##### 创建流



创建的流的方式常见的有多种：



##### 一 、直接创建

```java
import java.util.stream.Stream

Stream<Stream> stream = Stream.of("苹果","哈密瓜","香蕉","西瓜","火龙果");

```

##### 二、由数组转化

```java
 Stream[] fruitArray =  new String[] {"苹果","哈密瓜","香蕉","西瓜","火龙果"};

 Strean<String> stream = Stream.of(fruitArray);
```

> 这两种方式本质是一样的，第一种方式其实就是字符串数组。

##### 三、由集合转化

```java
List<String> fruits  = new ArrayList<>{};
fruits.add("苹果");
fruits.add("哈密瓜");
fruits.add("香蕉");
fruits.add("西瓜");
fruits.add("火龙果");
Stream<String> stream = fruits.stream();
```

在前面的课程中，相信大家已经对数组和集合之间的转换已经比较熟悉了，所以创建流的过程，大家应该也得心应手了。

> 无论是哪种方式创建，一定要清楚地知道：由于源数据（集合或数组）的数据是有序的，所以流中的元素也是有序排队的。

##### 迭代流

在上一章中，我们知道集合类提供了`forEach()`方法可以遍历集合中的元素，很巧的是，`Stream` 提供的迭代方法也叫做`forEach()`

```java
Stream<String> stream = Stream.of("苹果"，"哈密瓜","香蕉","西瓜","火龙果");
Stream.forEach(System.out::println);
```

> 可能是 for + each 这两个词能形象地描述遍历、迭代的含义吧。

注意：为了能够让系统自动识别Lambda表达式的参数类型，也必须使用泛型语法指定`Stream`中对象的类型。



`Stream API` 有很多，功能十分强大，迭代流只是最基础的应用。

##### 注意

集合类的`forEach()`方法与流的`forEach()`方法无关，仅仅是方法名相同而已，不要混淆哦。



#### 2.3 流数据过滤

湖北省襄阳市红旗区向向阳小学正在评选优秀学生，要求是期末考试平均分不低于80分且无违规记录，才有资格参与评选。



小学生的模型是：

```java
/*
* Pupil 模型
*/
public class Pupil {
		//姓名
		private String name;
		//平均分
		private int averageScore;
		//违规次数
		private int violationcount;
		
}
```

有一批小学生的记录：

|  name  | 平均分 | 违规次数 |
| :----: | ------ | -------- |
|  司音  | 75     | 1        |
|  白浅  | 80     | 0        |
| 荀飞盏 | 95     | 8        |
|  墨渊  | 79     | 0        |
|  夜华  | 90     | 0        |
| 霓漫天 | 81     | 0        |

##### 问题

如何统计哪些小学生有参与评选的资源呢？



##### 传统实现



一般的代码是这样的：

```java
List<Pupil> pupils = new ArrayList<>();
// 这里假设小学生数据对象已经存入了

// 有资格的小学生集合
List<Pupil> qualified = new ArrayList<>();
for (Pupil pupil : pupils) {
    // 统计是否满足条件
    if (pupil.getAverageScore() >= 80 && pupil.getViolationCount() < 1) {
        qualified.add(pupil);
    }
}

// 打印符合条件的小学生姓名
for (Pupil pupil : qualified) {
    System.out.println(pupil.getName());
}
```

##### 新特性实现

本节使用 Java8 新特性完成统计

```java
List<Pupil> pupils = new ArrayList<>();
//这里假设小学生数据对象已经存入了
pupils.stream()
  .filter(pupil->pupil.getAverageScore() > = 80 && pupil.getViolationCount() < 1)
  .forEach(pupil -> {System.out.println(pupil.getName())});
```

打印集合中的元素，我们都比较熟悉了。重点是统计的过程，使用了两个`Stream`的新`api`:



##### filter( )方法



从方法名为们可以理解其功能：对流中的数据对象进行过滤。

![j5-2-3-2](/Users/dongyanzu/Desktop/j5-2-3-2.svg)

方法参数是一个Lambda表达式，箭头后面是条件语句，判断数据需要符合的条件。



也就是说，使用Lambda表达式告诉过滤器，需要哪些 符合 条件的数据 （把不符合条件的数据过滤掉）

> 注意：这里的Lambda表达式略有不同
>
> >箭头后的过滤条件语句（非可执行的语句）。传统代码中，条件语句写在{}中的，所以新特性条件语句可以用() 而不能用{}
> >
> >>等同于pupil -> ((pupil.getAverageScore() > 80) && (pupil.getViolationcount() < 1 ))

#### 2.4 流的设计思想（一）



我们不仅要会使用`Stream API`还要了解一些`Stream`基本原理和基本思想。



数据流的操作过程，可以看作一个管道，管道由多个结点组成，每个节点都完成一个操作，



数据流输入这个管道，按照 顺序 经过各个节点。上节课的案例中，最后完成输出到console。

![j5-2-4-1](/Users/dongyanzu/Desktop/j5-2-4-1.svg)

> 上节的案例中`.filter().forEach()`组成了一个管道，每个方法都是管道的一个结点。方法调用的顺序构成了管道的结点顺序。

上小节只有两个节点，但实际上可以有更多的节点，在后面会持续介绍。



#### 2.5 流数据映射



`对于一组数字`

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 7, 63, 2, 3, 5);
```

计算每个数字的平方数并输出。

##### 解答

使用 `Stream API` 就很简便了：

```java
numbers.stream()
	.map(num -> {return num * num;})
	.forEach(System.out::println);
```

这里用到的是`map()`方法。

![j5-2-5-2](/Users/dongyanzu/Desktop/j5-2-5-2.svg)

`map()`方法通常称作映射，其作用就是用新的元素替换掉流中原来相同位置的元素。相当于每个对象都经历一次转换。



##### 映射到新数据



`map()`方法的参数是一个Lambda表达式，在语句块中对流中的每个数据对象进行计算、处理、最后用`return`语句返回的对象，就是转换后的对象。

![j5-2-5-1](/Users/dongyanzu/Desktop/j5-2-5-1.svg)



##### 优点



映射后的对象类型，可以与流中原始的对象类型不一致



在流中，可以用字符串替代原来的整数，这就极大的提供了 灵活性、扩展性，让流的后继操作可以更方便。



##### 特例写法



少数情况下，如果替代语句简单，系统能自动识别需要返回的值，代码可以简写为：

`.map(num -> num * num)`

但是最初还是应该写完整的语句，熟练后再简写也不迟。



#### 2.6 流数据排序

对于数据的处理，排序是很常见的操作。在上一章第二节中，我们学会了Lambda表达式优化语句：

```java
List<Student> students = new ArrayList<Student>();
students.add(new Student(111, "bbbb", "london"));
students.add(new Student(131, "aaaa", "nyc"));
students.add(new Student(121, "cccc", "jaipur"));

// 实现升序排序
Collections.sort(students, (student1, student2) -> {
  // 第一个参数的学号 > 第二个参数的学号
  return student1.getRollNo() - student2.getRollNo();
});

students.forEach(s -> System.out.println(s));
```

使用`Stream API` 就更简便了：

```java
students.stream()
    // 实现升序排序
    .sorted((student1, student2) -> {
        return student1.getRollNo() - student2.getRollNo();
    })
    .forEach(System.out::println);
```



`sorted()`顾名思义，就是完成排序的方法。把排序规则写成一个Lambda表达式传给此方法即可。



> 核心的排序规则和Lambda表达式是一样的。



##### 参数排序



无论是Lambda表达式写法，还是Stream API 写法 ，参数`(student1 , student2 )`中的`student1`和`student2`分别指代第几个元素呢？



答案是： student1 指代后一个元素，student2 指代前一个元素。

> 第一次遍历时，student1 指代第二个名称为 aaaa 学生，student2 指代第一个名称为bbbb的学生。



少数情况下，如果排序计算语句简单、系统能够自动识别需要返回值，代码可以简写为：

```java
.sorted( (student1,student2) -> student1.getRollNo()-student2.getRollNo() );
```

但是作为初学者，还是推荐写完整的

```java
.sorted(...,...) -> {
	... ...
	return ... ...;
}
```

##### 小知识点



无论是集合排序`Collections.sort()`还是流排序`sorted()`,都需要返回一个数值，返回的数值与排序升降有什么关系呢？



本节案例中，前两个学生的学号相减`131-111=20`为什么返回`20`就表示升序呢？



因为，返回 非整数 表示两个相比较的元素 需要 交换位置，返回正数则不需要。

`131-111 = 20 `表示前两个学生不需要改变在集合中的位置顺序。

那么后两个学生进行比较`121-131=-10`返回负数，于是名称为`aaaa`的学生需要与名称为`cccc`的学生交换位置，改变顺序，完成了由小到大的升序排序。



那么如何进行降序排序呢？



同理 使用 `studen2.getRollNo() - student1.getRollNo()` 集合前两个学生`111-131 = -20`，此时返回的结果为非正数，所以两者交换位置



后两个学生进行比较`111-121=-10` 返回了负数，所以两者交换顺序，最终变成了 `131->121->111`的集合顺序，完成降序排序。

#### 2.7 流数据摘取

对于一组数字：

```java
List<Integer> numbers = Arrays.asList(3.2.2.7.63,2,3,5);
```

找出最大的前3个数字。

##### 答案

我们可以想到使用使序就能知道哪个数字最大



在此基础上，`Stream API` 提供了摘取接口，很容易完成：

```java
numbers.stream()
.sort((n1,n2) -> n2 - n1)
.limit(3)
.forEach(System.out::println);
```

`limit()`方法的作用是返回流的前`n`个元素，当然`n`不能为负数。

> 不能摘取任意位置哦，只能是流开头的。

##### 扩展的小问题

如果`sorted()` 与 `limit()`的调用顺序搞反了，会发生什么情况呢？

> 直接返回流的前三个元素，sort未生效

#### 2.8 流的设计思想（二）

对比普通的Java代码，`Stream`的显著特点是：编程的重点，不再是对象的运用，而是数据的计算。



如果使用普通的Java代码，重点是使用数据比完成各种各样的逻辑，加上语法代码也比较多，导致整个代码比较繁复。



使用了`Stream API`，系统会自动完成很多操作，加上大幅度简化了语法，开发者的注意力的重点就变为捋清楚数据计算的步骤，不用太关心变量类型，变量赋值、对象转换等。编程的重点更加清晰。



Stream的这种变化，特征是：函数式风格。即弱化了面向兑现过的严格，完整的语法，中心变为通过函数完成数据计算。

![j5-2-8-1](/Users/dongyanzu/Desktop/j5-2-8-1.svg)

不仅要学会运用`Stream API`，更要思考和理解`Stream`的特点。

### <3> 并行数据

#### 3.1 流合并（一）

上一章学习的常用`Stream API`，包括filter、map、sorted 都统称为 聚合操作。



顾名思义，聚合操作就是把集合中的对象做整体性的计算，但上一章学习的内容可能对这个概念感受不深。本章内容会加深 对聚合 的理解。 



> 一般来说，计算、操作、处理这几个词都是表达对同一个意思，都是比较宽泛的含义。尤其是计算，不要以为仅仅加减乘除。



对 1-10 的十个正整数求和：

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
```

普通的使用`for`循环完成计算的代码实现是：

```java
int sum = 0;
for (int i : numbers) {
    sum += i;
}

System.out.println("sum : " + sum);
```

而使用 *Stream API* 完成计算的代码实现是：

```java
import java.util.Arrays;

int sum = numbers.stream()
    .reduce((a, b) -> a + b)
    .get();

System.out.println("1-10求和 : " + sum);
```

`reduce()`方法的返回值是一个比较复杂的对象，需要调用`get()`方法返回最终的整数值。

> 同理，`get()`方法返回值的类型，也是系统自动根据流中元素类型推定的。

`reduce()`方法的参数就稍微有点复杂了（重点理解）：

- `a`仔第一次执行计算语句`a+b`时，指代流的第一个元素；然后充当缓存作用以存放本次计算结果。此后执行计算语句时，`a` 的值就是上一次的计算结果并继续充当缓存存放本次计算结果。

- `b`参数第一次执行计算语句时指代流的第二个元素。此后依次指代流的每个元素。

- > 注意：a，b两个参数的作用是由位置决定的，变量名时任意的。

结合下图理解：

![j5-3-1-1](/Users/dongyanzu/Desktop/j5-3-1-1.svg)

`reduce()`方法的第一个参数（本例的`a`) 有多重作用，并且系统时自动完成参数（本例的`a,b`) 赋值的，所以仍然体现了`Stream`编程的重点仍然是 计算（本例的`a+b`).



#### 3.2 流合并（二）

上一章学了使用`reduce()`方法计算整数值，但实际上,`reduce()`方法也是可以操作对象的。



对于上节中的数据

````java
List<Student> students = new ArrayList<>();
students.add(new Student("赵祯",92));
students.add(new Student("曹丹姝",60));
... ...
... ...  
````

计算三年二班的学生的分数，并在Console中打印本班级学生平均分。



如果需求比较复杂，可能简单的整数就不够了，就要使用`Student`对象：

```java
Student result = students.stream();
	.reduce(
		(a,b) -> {
			a.setMidtermScore(a.getMidtermScore() + b.getMictermScore());
			return a;
		}
	)
	.get();
System.out.println(result.getName() + "-" + result .getMidtermScore());	
```

Console 的输出结果是：

```
赵祯 -777
```

这是bug，如果计算后，再在网页上显示每位同学的分数，赵祯同学的分数就错误的显示成 777 分。



出现bug的主要原因是，第一个`Student`对象由于充当了缓存角色，正确性被破坏了。



##### 解决办法

`reduce()`提供了另一种参数形式，可以自己`new`一个对象充当缓存角色，而不是使用流中的原始对象。

```java
Student result = students.stream()
    .reduce(new Student("", 0),
        (a, b) -> {
            a.setMidtermScore(a.getMidtermScore() + b.getMidtermScore());
            return a;
        }
    );

System.out.println(result.getName() + " - " + result.getMidtermScore());
```

`reduce()`方法的参数变为了两个：

- 第一个参数，是作为缓存角色的对象
- 第二个参数，是Lambda表达式，完成计算，格式是一样的。
- - 那么`a`变量不再指代流中的第一个元素了，专门指代缓存角色的对象，即方法第一个参数对象。
  - `b`变量依次指代流的每个元素，包括第一个元素
  - `a`,`b`职责非常清晰了。

对照下图理解`a`,`b`参数的功能变化：

![j5-3-2-1](/Users/dongyanzu/Desktop/j5-3-2-1.svg)

`reduce()`方法的返回值同时发生了变化，返回作为缓存角色的对象，即第一个参数。

> 不用再调用一次`get()`方法了。

流中的原始对象没有被破坏，在一个没有姓名的缓存对象中存放计算结果。没有bug了。



##### 小结

从`reduce()`的学习可以感受到，对于整个Java流到设计，由于系统会自动做很多事情，所以在学习和理解时，知识点是比较隐晦的，逻辑也有点复杂。



但是一旦理解后，写代码就爽快很多，编程的焦点更加明确了。



可以说，特点是"约定大于代码"。Java把规范定好了，开发者只要专注于开发计算逻辑。



那么隐晦、复杂的`Stream API` 多看、多练、多复习。

技术的学习没什么捷径。



#### 3.3 流收集

`forEach()`方法和`reduce()`方法都是流的终点。本节再来学习一种属于终点的流操作：收集。



在实际工作中，整体功能如果比较复杂的话，使用流对于集合进行计算后，可能并不想输出和合并，而是把结果元素放在一个新的集合中待进一步使用。

>例如，新的集合可以传递给Thymeleaf模版等等。



对于一组数字：

```java
List<Integer> numbers = Arrays.asList(3,2,2,7,63,2,3,5);
```

找出最大的前`3`个数字放入一个新的集合中，用`-`组合成字符串打印。

```java
import java.util.stream.Collectors;

List<String> numResult = numbers.stream()
	.sorted((n1,n2) -> n2-n1)
  .limit(3)
  .map(a->"" + a) //将流中数据类型int 转化为 String
  .collect(Collectors.toList());

String string = String.join("-",numResult);
System.out.println("字符串是：" + string);
```

`collect()`方法的作用就是收集元素，但元素收集存放到哪去呢？`Collectors.toList()`是一个静态方法，作为参数告诉`collect()`方法存入一个`List`集合，所以`collect()`方法的返回值类型是`List`。

>`java.util.stream.Collectors`是流工具包中提供的收集器。

为了能够把最终结果转换为字符串打印，调用了`map()`方法把流中原来的整数映射为字符串(""+a) ，所以`collect()`方法的返回值类型就是`List<String>`，而不是`List<Integer>`

> `String.join() `的用法在《Java面向对象》中学过了

`collect(Collectors.toList())` 几乎是一个标准用法了。



#### 3.4 并行流

`Stream API`设计中，很像是一个管道。

![j5-2-4-1 (1)](/Users/dongyanzu/Desktop/j5-2-4-1 (1).svg)

管道的显著特点是，每个节点是依次执行的，下一个节点必须等待上一个节点执行完毕。这种执行方式，通常叫做 串行。

> 无论多少个节点都能排成一个队伍

##### 性能问题

**如果计算过程越来越复杂、数据量越来越大，串行工作模式性能会越来越低。我们学习过程中所举的案例，数据量没那么大，这是为了便于理解。由于目前已经进入大数据时代，在实际工作中的数据，可能会数据量大、计算过程复杂。**



串行工作模式的性能很难被优化。因为这种模式无法发挥 多核CPU的优势。

> 只有一个队伍，核再多也只能等待。



##### 解决办法

为了充分发挥 多核CPU的优势，可以把 串行 计算模式，改为 并行计算模式。



当然， 并行 计算模式不能简单的把一个队伍变成三五个队伍。



所谓并行，就是利用多线程，变成同时执行。多线程可以充分发掘多核CPU的优势。





##### 小案例

对500000～1中的所有偶数，求平方值后进行自然排序。比较一个 串行 和 并行 的性能差异。



使用并行流的代码很简单，不再调用`Stream()`方法，改为调用`parallelStream()`方法即可。其它的计算方法是一样的。



`parallelStream()`以并行的方法执行任务，同时也支持流的收集，合并等计算。结合下图理解与串行运算等不同：

![j5-3-4-1](/Users/dongyanzu/Desktop/j5-3-4-1.svg)

> 并行流的计算过程被Java封装了，使用起来很简单。目前需要熟练应用即可。当然，如果任务拆分等过程和细节有兴趣，可以研究Stream API 源码

多运行几次，会看到每次耗时耗秒数都不完全相同，总体来说，还是 并行 计算模式耗时更短。

> 我们在《Java面向对象》第八章学习过`Duration.between()`方法计算两个时间的差值。duration.toMillis()输出毫秒数。

##### 不适合使用并行计算的场景

流中的每个数据元素之间，有逻辑依赖关系的时候，不适合使用并行计算。



上面视频中的例子可以看到，数字输出的顺序不是期待中的`1 2 3 4 5`，而是无需的，而且多运行几次，顺序都可能不一样。



这是因为并行计算使用了多线程，每个线程独立输出数字，而线程的输出时机，是由 CPU 动态决定的，无法确定。



所以逻辑上要求数字必须按书写的前后顺序（数字之间有逻辑顺序）输出时，就不能使用并行计算。



#### 3.5 并行流的性能意外

实际上，并行 计算模式的性能 不是任何情况下都优于 串行 计算模式。



场景的原因有两种：



##### 一、硬件太差

CPU 核数很低，特别是单核情况下，并行 计算模式不一定更好。因为多线程也要等待CPU资源，不能很好的发挥多线程的优势。



##### 二、任务简单

数据量小，任务简单的情况下，并行计算模式不一定更好，因为多线程的管理也是会消耗CPU，内存等资源等，可能比任务本身的开销更大。



例如，500000～1中的过滤出偶数



从结果可以看到，虽然感觉五十万个数字也不少了，但是任务过于简单，串行计算模式还是耗时更少。



##### 选择

我们需要先理解，串行 和 并行 两种模式的差别，然后根据实际情况选择使用。



由于实际情况中，硬件、需求复杂度等各种因素比较复杂，所以实际上没有确定的选择方案。



一般来说，执行任务超过一个消失的情况下，考虑使用 并行 模式优化性能。



任务执行时间较短，又没有特别要求，使用 串行 模式也问题不大。



对任务有实时性要求，希望立即得到计算结果，最好时比较一下两种模式，比如个运行100次比较哪种模式最好，



> 使用 并行 要特别注意是否会造成数据之间是和否有逻辑关系，出BUG就不好了。



### <4> 常见的设计模式

#### 4.1 设计模式的作用

我们在学习过程中可能听说过 **设计模式** （Design pattern）这个词。可能会感觉有些高深。



设计模式本身并不是 Java 特有的，是有着丰富经验的优秀的程序员前辈们总结出来的最佳实践，经过时间沉淀，形成的一套解决问题的方法。

> python 、C++ 都有设计模式

通常，一个设计模式专注于解决一类问题，不会有万能的设计模式解决所有问题。



##### 设计模式的历史

谈到设计模式，一定要知道四人帮



*在1994年，由 Erich Gamma、Richard Helm 、Ralph Johnson 和John Vlissides 四人合著出版了一本名为《Design Patterns -Elements of Reusable Object - Oriented Software》（设计模式-可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念，*



四位作者合称 GOF （四人帮，全拼 Gang of Four）



##### 为什么要学习设计模式

所以，学习设计模式有助于提升代码质量（崇勇代码、易阅读、易维护、可靠性、扩展性等方面），也有助于提升程序员的设计能力。

> 也要注意区分每种设计适用的场景。

设计模式是从普通程序员向高级程序员迈进的重要起点。大家也要在学习过程中不断地思考和体会：解决一个问题和解决一类问题的方法、有什么不同。



设计模式可以说博大精深，但也不是每种设计模式都能经常用到。本章会学习最常用的几个设计模式。



#### 4.2 单例模式

在现实生活中，经常会遇到 唯一 的现象。例如：一个班级只有一名班主任。



经过这么长时间的学习，我们肯定很容易定义出 班主任 和 班级 两个类：



班主任类的简单定义：

```java
public class ClassMaster {
	private String id;
	// 班主任名称
	private String name;
	private String gender;
}
```

在班级中创建班主任实例对象：

```java
public class Classes {

	public static void main(String[] args) {
		// 创建班主任实例
		ClassMaster classMaster = new ClassMaster();
		// 创建班主任实例2
		ClassMaster classMaster2 = new ClassMaster();
	}
}
```

##### 问题

在`Classes`中可以创建多个`ClassMaster`实例。这就违背了要求，没有做到 班主任 类只有 一个实例对象。



##### 解决

单例模式就是为了解决这种问题：保证一个类仅有一个实例。



要做到这一点，核心办法就是把构造函数设为私有的。



```java
public class ClassMaster {
	private String id;
	//班主任名称
	private String name;
	private String gender;
	private ClassMaster() {
	
	}
}
```

把构造函数设为 `private ` ， 就意味着，除了`ClassMaster`自己，其它任何类都不能实例化`ClassMaster`对象。



***就是`ClassMaster`自己可以实例化自己***



##### 特殊的实例化

```java
public class ClassMaster {
	private String id;
	//班主任名称
	private String name;
	private String gender;
	
	//唯一实例
	private static ClassMaster instance = new ClassMaster();
	
	private ClassMaster() {
	
	}
}
```

在`ClassMaster`类中定义一个`ClassMaster`类型的变量，赋值为`new`出来的实例。

> 要注意：必须使用`static`修饰符，否则会造成死递归的严重的错误。

也就是说，不允许其它类实例化`ClassMaster`（私有化构造方法）、只有自己能实例化一个唯一的自己（private static），所以可以保证`ClassMaster`的实例时全局唯一的。



这种可以保证只有一个实例对象的方式，就是 单例 设计模式。



##### 访问实例

类`new`出一个实例的目的，是要给其它类使用的。所以还需要增加一个方法，允许其它类访问这个单例的实例。

```java
public class ClassMaster {
  private String id;
  // 班主任名称
  private String name;
  private String gender;

  // 唯一实例
  private static ClassMaster instance = new ClassMaster();

  private ClassMaster() {
  }

  // 外部类可以通过这个方法访问唯一的实例
  public static ClassMaster getInstance() {
    return instance;
  }
}
```

可以看到下图，更直观地展现了单例模式：

![j5-4-2-1](/Users/dongyanzu/Desktop/j5-4-2-1.svg)

由演示，虽然访问多次班主任，但构造函数只执行了一次。



##### Spring 中的单例



不仅是功能逻辑要求只有一个实例，有时从技术角度出发为了节省系统资源的时候，也会用到单例模式。



在《Spring Web 全栈》中为们已经了解到，类变量使用`@Autowired`注解，能够实现自动注入实例对象。



实际上，任何自动注入实例对象，默认只有一个实例对象，是单例的。例如：可能多个`Service`和`Control`等都需要用到用户服务，那么这些类中都会定义：

```java
@Autowired
private UserService userService;
```

Spring 会保证只生成一个`UserServiceImpl`实例，注入到多个`Serivice` 或 `Control`中，不会为每个`Serivice`或`Control`分别`new`出多个`UserServiceImpl`实现类的实例。



虽然我们写`Service`服务的时候没有像写`ClassMaster`代码一样使用私有的构造方法，但Spring 也应用了 单例 的思想来减少不必要的消耗。



> Spring 的代码就比较复杂了，有兴趣的话可以深入研究

 ##### 总结



单例模式不仅仅是一段代码，它更是一种思想。



我们可以编码来实现：Spring 作为框架在履行管理职责的过程中，也用到、实现了这个思想。



虽然具体实现编码由不同，但大家都用这种思想解决了一类问题。



甚至不同的编程语言，也可以应用这种思想。那么大家只要了解了`Java`的设计模式，以后学习其它编程语言，会更容易融会贯通。



#### 4.3 简单工厂模式

另一个很常见的设计模式是简单工厂。现实生活中的“工厂”是生产产品的地方，而程序中的“工厂”是生产实例对象的地方。



当我们想吃西瓜的时候，就很简单的了，用程序表达就是：

`Watermelon melon = new Watermelon();`

但是情况变复杂，参观、水果超市、甜品店都想根据客人的口味提供送水果的服务时，同伪代码可能是这么写：



```java
public class Restaurant {
	public static void main(String[] args ) {
		 if (custom.getFavor() == "sweet") {
      WaterMelon w = new WaterMelon();
    } else if (custom.getFavor() == "sour") {
      Lemon l = new Lemon();
    } else if (custom.getFavor() == "smelly") {
      Durian d = new Durian();
    }
	}
}
```

以及

```java
public class DessertShop {
	public static void main(String[] args ) {
		 if (custom.getFavor() == "sweet") {
      WaterMelon w = new WaterMelon();
    } else if (custom.getFavor() == "sour") {
      Lemon l = new Lemon();
    } else if (custom.getFavor() == "smelly") {
      Durian d = new Durian();
    }
	}
}
```

##### 问题

这样方式实现“根据不同条件创建不同对象”需求，其核心问题是：

1. 代码重复：每个需要提供多种水果店商店都要写这么一大段相同的逻辑代码，如果要增加或删除一个条件，那就是灾难。
2. 耦合紧密：当西瓜过季了，甜水果需要由西瓜改为凤梨时，餐馆、水果超市、甜品店等都需要改。如果由几百个店铺卖水果，那就是灾难。

> 所谓耦合，指的是某个类的代码，包含了其他类的逻辑细节，包含得越多，耦合越紧密，也越容易相互影响。甜水果需要由西瓜改为凤梨时，影响了所有的水果店，就是耦合紧密，耦合度高。

##### 解决办法

简单工厂可以解决这个问题。



所谓工厂，顾名思义就是生产产品的。程序中的工厂，是生产实例对象的。



实现简单工厂，需要两个步骤：

1. 从具体的产品类抽象出接口。记住Java强调面向接口编程。意味着工厂应该生产一种产品，不应该生产某一个产品。
2. 把生产实例对象的过程，收拢到工厂类中实现。

为了更好地理解，先看类图：

![j5-4-3-2](/Users/dongyanzu/Desktop/j5-4-3-2.svg)



最核心的工厂实现，其实也比较简单：

```java
public class FruitFactory {
	public static Fruit getFruit(Customer customer) {
		Fruit fruit = null;
		if("sweet".equals(customer.getFlavor())) {
				fruit = new Watermelon();
		} else if("acid".equals(customer.getFlavor())) {
				fruit = new Lemon();
		} else if ("smelly".equals(customer.getFla)) {
				fruit = new Durian();
		}
		return fruit;
	}
}
```

工厂仍然要实现功能，完成“根据不同条件创建不同对象”需求。



工厂的主要优点在于 职责明确。餐馆、甜品店等需要水果店地方只需要告诉工厂顾客的口味，获得工厂生产的水果，但不需要知道具体是什么水果。餐馆和甜品店的责任是上菜，生产的责任交给工厂。



##### 命名

一般来说，工厂类命名为`XXXXFactory`，以`Factory`作为后缀可以提高辨识度，易于理解这个类的作用。



工厂类中的方法，依据实际情况而定，并没有特别的约定。方法名、输入参数、返回值，都是要根据实际需求确定的。



> 方法名是自由命名的，如果没有特别好的创意，建议选用`get`,`create`,`make`,或`build`作为前缀



##### 重点



理解简单工厂设计模式，重点还是要理解这种思想，以及适用的场景。



使用简单工厂完成功能开发时，重点就是要明确 什么条件 下创建 什么实例对象 的需求逻辑。



##### 抽象类的应用

不同牌子的轿车，接口中定义了getBrand()方法。所以每个轿车的实现类，都要书写：

```java
	private String brand;
	public String getBrand() {return brand;}
	public void setBrand(String brand) {this.brand = brand;}
```

这时候就违背了不要写重复代码的基本原则。为了解决这个问题，一种比较简单的方法就是使用抽象类。



在接口`Car`与实现类之间，加一个`AbstractCar`，轿车类不再直接实现接口，而是继承`AbstractCar`，那么：

```java
private String brand;
// 包括 getter setter 方法，这里为了简单起见省略
```

于是避免了每个轿车的实现类重复定义`brand`属性：

- 抽象类存放公共属性和方法
- 每个实现类存放各种特有的属性和方法

#### 4.4 抽象工厂模式

简单工厂更适合创建一种对象。但有时候会遇到复杂的问题，需要创建一个系列，多种产品的时候，简单工厂模式就不太适用了。 



例如餐馆、水果超市、甜品店除了提供水果外，可能还提供饮料。上节我们已经学会实现了 水果工厂，再增加一个 饮料工厂即可。



用伪代码可能是这么写：

```java
public class restaurant {
	public static void main(String[] args) {
    Fruit a1 = FruitFactory.get("sweet");
    Juice a2 = JuiceFactory.get("carbonic_acid");
  }
}
```

##### 问题

由于 水果 和 饮料 是搭配的，属于零食系列，比如五金店里就不会卖水果、饮料等零食，所以对于餐馆，就需要知道哪些工厂需要搭配，这就导致餐馆与多个工厂耦合太密，不利于扩展。



##### 解决办法



对于一批、多种类型的对象需要创建的场景，使用抽象工厂模式会更好。



简单工厂的主要把多个产品抽象，使用一个工厂统一创建；那么抽象工厂的主要作用是把多个工厂也进一步 **抽象**。



为了更好地理解，先看类图：



![j5-4-4-1](/Users/dongyanzu/Desktop/j5-4-4-1.svg)

乍一看似乎很复杂，类很多。但仔细分析一下，实际上就是进一步抽象出了工厂接口（`SnacksFactory`)，然后多了一个`SnacksFactorybuilder`。



##### 1. 工厂接口



工厂接口（`SnackFactory`）即规定工厂应该提供什么样的产品，所以包含了所有工厂的方法：



```java
public interface SnackFactory {
	// 取得水果
	public Fruit getFruit(Customer customer);
	
	// 取得饮料
	public Drink getDrink(Customer customer);
	
}
```

但有一个问题，水果工厂是不提供饮料，但水果工厂实现工厂接口后，有必须实现`getDrink()`方法，这时候直接`null`即可。



```java
public class FruitFactory implements SnacksFactory {
	public Fruit getFruit(Customer customer) {
	     Fruit fruit = null;
        if ("sweet".equals(customer.getFlavor())) {
            fruit = new Watermelon();
        } else if ("acid".equals(customer.getFlavor())) {
            fruit = new Lemon();
        } else if ("smelly".equals(customer.getFlavor())) {
            fruit = new Durian();
        }

        return fruit;
	}
	public Drink getDrink(Customer customer) {
        return null;
    }
}
```

> 水果工厂不真正实现`getDrink()`方法，只是基于接口的需要，给一个没有实际作用的方法实现。

##### 2 工厂的工厂

`SnackFactoryBuilder`称之为 生产工厂的工厂，工厂用来生产产品实例，`SnacksFactoryBuilder`用来生成工作实例。



```java
public class SnackFactoryBuilder {
		public SnackFactory buildFactory(String choice) {
			if(choice.equalsIgnoreCase("fruit")) {
				return new FruitFactory();
			} else if (choice.equalsIgnoreCase("drink")) {
				return new DrinkFactory();
			}
			return null;
		}
}
```

从简单工厂到抽象工厂，完成了对产品的抽象的对工厂的抽象。



那么能不能弄一个生产工厂的工厂的工厂呢？答案是否定的，太过复杂的代码不易维护，不如用两套抽象工厂了。



##### 扩展知识点

注意，与简单工厂不同的是：



`SnacksFactoryBuilder`的`buildFactory()`方法并不是`static`的。



因为复杂场景尽量不要使用类（static）方法，实例对象可以继续被继承，扩展性较好，应该优先使用实例方法。



> 《Java语言入门》中把 static 方法称之为静态方法，没有static 的方法叫对象方法。实际上，静态方法=类方法，对象方法=实例方法，只是叫法不同而已。

#### 4.5 工厂模式结合Spring工程



上节提到内容中不提倡在工厂中定义`static`方法的另一个原因是：



在使用`Spring`框架的时候，可以为`SnacksFactoryBuilder`加上`@Component`注解，可以让框架管理实例：



```java
@Component
public class SnacksFactoryBuilder {
    public SnacksFactory buildFactory(String choice) {

    }
```

> 简单工厂模式的工厂类也可以像这样去去掉static 、加注解

相应的，任何需要使用工厂的地方，只需要使用`@Autowired`注解让框架自动注入实例即可，非常方便：



```java
@Service
public class XxxxxServiceImpl implements XxxxxService {

    @Autowired
    private SnacksFactoryBuilder snacksFactoryBuilder;
}
```

这样可以让工厂模式的代码与`Spring`互为一体，扩展性更好，更易于维护。

#### 4.6 观察者模式



在《Java网络编程》的最后，我们曾经做过一个"实战天气报告"项目，抓去了天气信息并发送邮件到指定的邮箱。



但这个天气项目只能为自己服务，难以扩展，比如天气信息不能发多个不同的邮箱（tom邮箱、126邮箱、新浪邮箱）、不能发短信等。



按照互联网信息共享等思想，能为很多人服务就更好了。



##### 基本思路

​	提供一个天气服务器，谁想了解天气信息，从这个服务端订阅就好了；当天气发生了变化，自动通知每个客户端。



这种 订阅/通知 的场景，很适合 观察者模式 来实现。



##### 1. 观察什么



观察者模式 等核心是要知道观察什么，什么对象发生变化了需要发出通知？



在天气项目中，显然，天气信息是核心，天气发生变化了，需要通知大家都知道。所以，我们先抽象出天气信息对象。



```java
import java.util.Observable

public class WeatherData extends Observable {


	//城市
	private String cityName;
	
	//时间
	private String time;
	
	//温度
	private String temp;

   // 打印天气信息
    public String toString() {
        return cityName + "，" + LocalDate.now().toString() + " " + time + "，气温：" + temp + "摄氏度。";
    }

    public String getCityName() {
        return cityName;
    }

    public String getTime() {
        return time;
    }

    public String getTemp() {
        return temp;
    }

}
```



我们可以把《Java网络编程》第 8 章第代码拿出来对比一下。



重写了toString方法返回的就是天气内容信息。



大家可能注意到，天气信息类`WeatherData`继承了`Observable`类，该类是 Java 提供的，继承了就表示是核心的、需要被观察到累。



> 记住这个写法： extends Observable



这个设计与以前模型设计的不同的是，一个`WeatherData`代表一个城市的天气，初始化完毕以后就不能改了。所以去掉所有属性的`setter`方法。



`WeatherData` 是 被观察着。



##### 2. 数据变化后发起通知



时间和气温是监听的重点信息，所以增加一个新的方法（上面的暂时省略，会看的比较清楚）来专门处理。



```java
import java.util.Observable;

public class WeatherData extends Observable {
    /**
     * 一个城市的气温在某个时刻发生了变化
     */
    public void changeTemp(String time, String temp) {
        if(time == null || temp == null) {
            // 输入数据为空是有问题的，不处理
            return;
        }

        // 与原数据不同，说明发生了变化
        if(!time.equals(this.time) || !temp.equals(this.temp)) {
            // 标记变化
            super.setChanged();
            this.time = time;
            this.temp = temp;
            // 发出通知，参数是额外的信息
            super.notifyObservers("温度变化已通知");
        }
    }
}
```

在`changeTemp()`中，如果天气数据与原来不同，则会标记变化并发出通知。



父类`Observable`提供的方法`setChange()`就是标记被观察者对象发送了变化。



父类`Observable`提供的方法`notifyObservers()`就是发出通知：如果需要发送额外（不在被观察者对象里的）信息，在参数中传入信息对象，可以是 任意对象 ，需要自己根据具体的需求场景而定。



> 本例子只是简单演示发送了一个字符串消息“温度变化已通知”，千万不要以为只能发送字符串
>
> > 如果不想发送额外信息，可以写为
> >
> > super.notifyObservers(null)



##### 3. 谁接收通知



需要了解天气的类，就是接收通知的类，通常叫做观察者。

> 观察者观察数据的变化

观察者需要实现`Obsever`接口，也是 Java 提供的，实现此接口表示作为观察者。



```java
import java.util.Observable;
import java.util.Observer;

public class WeatherObserver implements Observer {
    private String name;

    @Override
    public void update(Observable o, Object arg) {
        System.out.print(this.name + "观察到天气变化为：");
        System.out.print(o.toString());
        System.out.println(" " + arg);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

作为观察者，实现`Observer`接口后，要自己实现`uodate()`方法，方法签名是接口中定义好的，属于固定写法。



- 第一个参数就是被观察者对象，被观察者对象都需要继承自Observable
- 第二个参数就是额外的信息，具体说就是调用`super.notifyObservers()`是传入的参数对象；传入什么对象，arg的值就是什么对象。



>如果不想发送额外信息，写为super.notifyObservers(null),那么这里arg值就是 null ，注意避免空指针异常。

update()方法的作用就是接口通知。实际上，系统在`super.notifyObservers()`发出通知后，及条用所有观察者的`update()`方法，完成通知的过程。



##### 4. 运行一下



当天气变化时，只需要调用`changeTemp()`方法即可改变天气数据。



```java
public class WeatherTest {
    public static void main(String[] args) {
        // 在天气变化后发邮件的观察者
        WeatherObserver w1 = new WeatherObserver();
        w1.setName("天气邮件观察者");

        // 在天气变化后发短信的观察者
        WeatherObserver w2 = new WeatherObserver();
        w2.setName("天气短信观察者");

        // 城市天气数据
        WeatherData weatherData = new WeatherData("余杭");
        // 添加观察者
        weatherData.addObserver(w1);
        weatherData.addObserver(w2);

        // 气温变化
        weatherData.changeTemp("11:08", "32.8");
        // 气温变化
        weatherData.changeTemp("14:46", "29.3");
    }
}
```

观察者可以有多个。观察者对象与被观察者对象谁先 `new` 出来都可以，但是必须先调用`addObserber()`方法把观察者对象实例添加到被观察者（天气数据）实例中，然后再调用自定义的`changeTemp()`方法变更天气，才能触发自动通知。



##### 总结

实现观察者模式，实际上也不是很难，因为 Java 系统已经提供了借口，会自动完成通知的过程。



这里主要学习使用 `Observable`父类和`Observer`接口提供的几个方法。

![j5-4-5-1](/Users/dongyanzu/Desktop/j5-4-5-1.svg)



跟工厂模式不同的是，观察者模式主要描述的是类的行为，而不是如何创建。



跟工厂模式的思想相同的是，观察者模式让 观察者 和 被观察者 双方的 耦合度 降到最低 （称之为 解耦 ）。

> 观察者不需要知道数据变化后需要通知给谁，发出通知即可；而且不需要知道谁收到通知了谁没收到，由系统保证。

观察者模式让工程师专注于业务逻辑的实现，在具体的业务场景中，让观察者双方的实例产生联系，对类来说，是没有耦合的；系统完成的通知过程，是与具体业务需求无关的。

> 系统不需要知道是天气通知场景，亦或是厨师做好了饭通知顾客用餐的场景，系统只是完成纯粹的通知逻辑。



### <5> 并发编程



#### 5.1 为什么需要多线程

不知道大家在中学的时候，有没有读过一篇课文--华罗庚的《统筹方法》。华罗庚以生活中常见的烧开水泡茶为例，让人们了解到通过统筹方法可以把一项任务的工序进行合理安排，从而节约时间。



普通工序：

洗水壶 -> 烧开水 -> 洗茶壶 -> 洗茶杯 -> 取茶叶 -> 泡茶

这样线型的工序。



统筹方法工序：

![Screen Shot 2022-04-07 at 9.10.21 PM](/Users/dongyanzu/Library/Application Support/typora-user-images/Screen Shot 2022-04-07 at 9.10.21 PM.png)

统筹方法工序能够优化的原因，核心是 烧水 任务耗时较长，在等待 烧水 的过程中，可以去做其它事情，从而缩短泡茶的整体时间，提升了整体效率。



这个现实生活中的案例，映射到计算机程序，可以理解为：



`泡茶的人等同于计算机的 CPU ，计算机的 CPU 可以通过优化执行流程顺序从而提升程序的整体运行效果。`



计算机中，每个软件运行一次，即启动了一个进程，相当于整个泡茶的过程，是一个进程；而每个统筹方法工序，是一个个线程，统筹方法工序的工作模式，称为多线程。



> 普通工序按顺序执行，称之为单线程。相当于一个进程中只有一个线程。



又比如，我们已经学过Spring ， 启动一个Spring Boot 项目，就是启动了一个进程，而一个个用户访问首页的过程，都是一个个线程。Spring Boot 项目的工作模式是多线程的。



如果没有多线程的话，一个个用户只能按照顺序访问首页，程序响应了张三的请求，才能响应李四的请求。越往后的用户越慢，这是无法接受的。



```java
在互联网时代，我们就非常有必要学习多线程编程，才有可能优化程序，提升效率。
```

#### 5.2 继承 Thread 类



Java 作为一个强大的编程语言，为多线程编程提供了内置的支持。



我们通过一个小案例来看看使用Java如何使用多线程编程。



##### 需求



张三和李四到银行取钱，银行有多台ATM机，所以也是多线程工作模式。



##### 实现



##### 1. 线程类

可以继承 java 到`Thread`类实现线程类。



> Thread 的完整类名是 java.lang.Thread 。 `java.lang`包里的所有类都可以省略import

```java
public class Person extends Thread {

	@Override
	public void run() {
			try {
			  System.out.println(getName() + "开始取钱");
			  Thread.sleep(200);
			} catch(InterruptedException e) {
				e.printStackTrace();
			}
				System.out.println(getName() + "取钱完毕");
	}
}
```

继承`Thread`类后，需要重写父类的`run()`方法，注意必须是修饰为``public void`，方法是没有参数的。



> 加上`@Override`注解，会让系统自动检查`public void run()`方法定义有没有写错

线程类的作用就是完成一段相对独立的任务。银行上班提供服务是进程，某用户取钱的小任务是线程。



这里用`Thread.sleep(200)`模拟取钱的过程。`sleep()`方法（注意是静态方法）的作用是线程睡眠、暂时不再继续执行，交出CPU，让CPU去执行其他的任务。`sleep()`方法的参数是毫秒数，200表示200毫秒，超过这段时间后再继续执行程序。相当于让程序休息200毫秒就完成取钱了。



##### 2. 运行线程

线程需要调用`start()`方法才能启动。

```java
public class Bank {
	public static void main(String[] args) {
		Person thread1 = new Person();
		thread1.setName("张三");
		
		Person thread2 = new Person();
		thread2.setName("李四");
		
		thread1.start();
		thread2.start();
	}
}
```

类图可能看的更清楚：



![img](https://style.youkeda.com/img/ham/course/j5/j5-5-2-1.svg)

`Thread`父类中有`name`属性，但`private`的，所以可以调用`setName()`方法为线程设置名字，通过`getName()`就知道是哪个线程在运行。



> 当然，根据具体的需求，线程类也可以增加更多其他属性。只要不遗漏`run()`方法。

我们需要了解的是，线程类的`run()`方法是系统调用`start()`后自动执行的，编程时不需要调用`run()`方法。但永远无法知道系统在什么时刻调用，是立即调用，还是延迟一小段时间调用，都由系统自动决定，无法干预。



运行后，console 中的输出结果：

```java
张三 开始取钱

李四 开始取钱

张三 取钱完毕

李四 取钱完毕



李四 开始取钱

张三 开始取钱

李四 取钱完毕

张三 取钱完毕
```

> 多运行几次，可能每次都不完全一样



不仅不能确定系统睡眠时刻调用`run()`方法，也不能确定调用顺序一定是代码中`start()`方法的书写顺序。



我们需要记住这个特性，但不要纠结，多线程的执行时机是很复杂的，甚至和CPU硬件本身有关系，现阶段不用纠结原理。





#### 5.3 Runnable 接口

继承 Thread 类定义多线程程序后，缺点就比较明显了，无法再继承其它类，因为Java是单继承的，只允许继承一个类，者会导致程序的可扩展性大大降低。



所以定义多线程程序，优先采用第二种方式：实现`Java.lang.Runnable`接口。



> 尽量优先采用面向接口编程的方案。

`Runnable`接口中只有一个待实现的`run()`方法、要自己补充属性了。



无论是`Thread`类还是`Runnable`接口，`run()`方法都是系统 适时 自动 执行的，大家只是在方法体内实现业务功能即可。



> Thread.sleep() 这个静态方法仍然可以用，记得参数是毫秒数。



实现了`Runnable`接口的线程类，还需要包装在`Thread`类的实例中运行：

```java
public class Bank {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.setName("张三");
        Thread thread1 = new Thread(person1);

        Person person2 = new Person();
        person2.setName("李四");
        Thread thread2 = new Thread(person2);

        thread1.start();
        thread2.start();
    }
}
```

`Thread`实例(`new Thread(person1)`)相当于调度器，触发线程任务执行，线程类的实例（`new Person()`）就相当于任务。任务不能自己启动的，需要被调度。



通过类图可以看得更清楚：

![j5-5-3-1](/Users/dongyanzu/Desktop/j5-5-3-1.svg)

同样的，多运行几次，输出顺序可能不完全相同，与代码书写顺序不一定一致。



##### 重点



需要思考和体会`Thread`类与`Runnable`接口的各自作用与区别。



#### 5.4 线程安全



春运期间的火车票总是很紧张，江西省南昌市火车站有4个售票窗口，G2328次 列车只剩30张车票了。用程序模拟一下抢票的过程。



根据需求，分析应该有三个类：火车站、售票窗口、票。



但与前两节的场景不同的是，火车票的总数是优先的，无论多少窗口售票，都是从总的30张票中扣减。



##### 车票类



车票类的主要作用是控制车票的总数。每售卖一次，票数减1.



```java
public class Ticker {
	private int count = 30;
	
	public void sell() {
		count--;
			 System.out.println(Thread.currentThread().getName());
			 
	}
  public int getCount() {
    	return count;
  }
}
```

##### 售票窗口类



售票窗口就是线程类，以线程的方法售票。售票简单来说就是循环减一即可。当然，在票数为 0 的时候不能再售卖了。



这里假的当打印票据需要点时间，售卖一张票休息100毫秒。



```java
public class TickerWindow implements Runnable {
	private Ticket ticket;
	
	public TicketWindow(Ticket ticket) {
			this.ticket = ticket;
	}
	
	@Override
	public void run() {
			while (ticket.getCount() > 0) {
				try {
					Thread.sleep(100);
					ticket.sell();				}
			} catch (InterruptedException e) {
					e.printStackTrace();
			}
	}
}
```



##### 火车站类

火车站类有四个窗口，所以启动四个线程。



```java
public class TrainStation {
	public static void main(String[] args) {
		Ticket ticket = new Ticket();
		
		for (int i=1;i<=4;i++) {
			TicketWindow office = new TicketWindow(ticket);
			Thread thread = new Thread(office);
			thread.setName("售票窗口"+i);
			thread.start();
		}
	}
}
```



##### 新知识点



这里有个新的用法：`Thread.currentThread().getName()`



`Thread.currentThread()`返回当前正在运行的线程的实例对象，因为一个车票的实例，是运行在多个线程中的，需要知道具体在哪个窗口售卖车票，就可以使用这个方法。



再调用线程的`getName()`方法可以取得当前线程实例的名称。这个名称可以使用`setName()`方法指定一个名称，如果没有指定，系统会默认指定一个名称。

> 类图就不画了，这个比较简单。

运行一下试试：

在本地自己电脑上运行，CPU核数越多，问题越明显。



问题一：余量是错乱的，甚至可能余量相同

```java
售票窗口2:卖出一张，还剩28张票。
售票窗口1:卖出一张，还剩29张票。
售票窗口4:卖出一张，还剩26张票。
售票窗口3:卖出一张，还剩26张票。
售票窗口2:卖出一张，还剩25张票。
```

问题二：余量是负数

```java
售票窗口2:卖出一张，还剩-1张票。
售票窗口3:卖出一张，还剩-3张票。
售票窗口1:卖出一张，还剩-3张票。
```

前面提到了，线程的调用时机是很复杂的，是可以同时执行的，特别是多核CPU的情况下，多个线程同时（也叫并行）执行的概率很高。



![j5-5-4-2](/Users/dongyanzu/Desktop/j5-5-4-2.svg)



这种 多个线程 运行 同一个实例对象（`ticket`）的情况下，修改了一个变量（调用`sell()`方法同时执行`count--`语句），后果是不可预料的。所以会出现余量打印错乱甚至相同的情况。



##### 问题一的解决方案



多个线程操作 同一个资源 的时候，发生了冲突的现象，就叫做 线程不安全。



在Java中，可以用`Synchronized`关键字来解决余量错乱的问题。

`Synchronized`加载方法上，紧跟着`public`：

```java
public class Ticket {

		public synchronized void sell() {
		
			count--;
			System.out.println(Thread.currentThread().getName());
		}
}
```

> `synchronized`不能作用于变量名（java保留关键字）



`synchronized`也叫线程 同步锁 ，表示此方法是锁定的，同一时刻只能由一个线程执行此方法。

![j5-5-4-1](/Users/dongyanzu/Desktop/j5-5-4-1.svg)



先判断`sell()`方法有没有被上锁：

- 如果上锁，说明有其他线程正在调用`sell()`方法，必须等其他进程对`sell()`方法调用结束后才可以执行`sell()`方法；
- 如果没有上锁，则执行`sell()`方法。开始执行时对此方法加锁，不允许其他线程执行，方法执行完毕后解锁。



`synchronized`相当于保护了关键方法，不允许同时执行，必须一个个执行。



> 一个个执行不是按编码对顺序执行。由于系统自动决定在解锁后由哪个线程执行方法，也不是很复杂的。这种多个线程等待的过程也叫做竞争。



该方法改进后，Console 的输出可以看到，售票的顺序已经正常了，但仍然会出现负数。



##### 问题二的解决方案



当然车票余量为1的时候，四个线程可能同时判断`ticket.getCOunt()>0`调节成立，所以，真正执行`sell()`的时候，继续减1，出现负数。



所以，对于`sell()`方法来说，必须保证逻辑完整性，不能依赖其它类的条件判断，自己就不判断了。



```java
public class Ticket {
    public synchronized void sell() {
        if (count > 0) {
            count--;
        }
        System.out.println(Thread.currentThread().getName() + "：还剩下 " + count + " 张票");
    }
}
```

此次改进后正常。



#### 5.5 synchronized 使用场景



上节使用了`synchronized`关键字解决了车票余量错乱、以及余量可能相同的问题。从抽象概念上来说，使用`synchronized`的方法意味着满足了两个线程安全的特性：



1. 原子性： 方法全部执行并且执行的过程不会给任何因素打断。
2. 可见行： 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

但是`synchronized`为了实现这两个特性，也是要付出代价的：性能可能不高。因为方法加锁，同时只有一个线程竞争成功能继续执行，其它很多线程时持续等待、响应慢点。所以`synchronized`不能滥用，比较适合的场景时：

1. 写操作的场景。例如用户修改个人信息、点赞、收藏、下单等。
2. 尽量精确锁住最小的代码块，把最关键的写操作抽象成独立的方法加锁。不建议给大段的方法加锁。

#### 5.6 悲观锁和乐观锁



上一节降到，`synchronized`可能由于线程等待而导致性能问题，那么我们尝试换一种思路

`java.util.concurrent`是java系统提供的并发编程包，尝试使用`java.util.concurrent.atomic.AtomicInteger`让车票余量能够安全的递减。



```java
import java.util.concurrent.atomic.AtomicInteger;

public class Ticket {
    private AtomicInteger count = new AtomicInteger(30);

    public void sell() {
        int newCount = 0;
        if (count.get() > 0) {
            newCount = count.decrementAndGet();
        }
        System.out.println(Thread.currentThread().getName() + "：还剩下 " + newCount + " 张票");
    }

    public int getCount() {
        return count.get();
    }
}
```

##### 解决的问题



从输出结果可以看到，`sell()`不再加锁，解决了车票余量重复的问题。



`AtomicInteger`虽然是一个类，但等同于一个整数（就像Integer是int的对象）。调用`new AtoomicInteger()`构造函数实例化对象的时候，可以指定任意的整数值。

> new AtomicInteger(30) 意思是设定实例的整数值为 30

不同的是，`AtomicInteger`提供了不使用`synchronized`就恁恶搞保证数据操作原子性的方法。例如`decrementAndGet()`方法：



```
decrementAndGet() {
		//取得当前值
		
		//减一
		
		//return 新值
}
```

`decrementAndGet()`方法是三个操作的集合，多线程情况下也不会出现数值重复的错误，证明着三个操作是密不可分的、线程间没有互相干扰打断，保证了数据的正确性。这就是类名 Atomic - 原子性的含义。



线程间都是基于最新的结果进行减一的运算，所以不会重复，这样是 可见性 的体现。



> `count.decrementAndGet()`代替了使用`synchronized`时整数`count--`

##### 没有解决的问题



从输出结果可以看到，仍然可能出现负数，而且`Console`打印的顺序也可能错误。这是因为条件判断语句、操作语句、打印信息语句组合起来，就不具备原子性了，因为`sell()`不加锁，多条语句执行时就可能被其它线程打断了。



所以必须给`sell()`整体加`synchronized`才能保证多条语句整体的原子性



```
public synchronized void sell() {

}
```

>对比两种实现，进一步体会线程安全的 原子性 和 可见性 特征及其作用范围。



##### 另一个原子性的案例



春蕾中学新生入学报名（也叫注册）的时候，会自动获得一个学号。新生注册可能是网上注册、或者校园现场新生接待处的窗口排队注册，其实相当于多线程并发情况下，要保证学号不能重复。



同样的，可以使用`AtomicInteger`实现。先看一下核心代码

```java
import java.util.concurrent.atomic.AtomicInteger;

public class Register implements Runnable {
    private static AtomicInteger count = new AtomicInteger(0);

    private Student student;

    public Register(Student student) {
        this.student = student;
    }

    @Override
    public void run() {
        student.setId(count.incrementAndGet());
        System.out.println("姓名：" + student.getName() + "，学号：" + student.getId());
    }
}
```

类图如下：

![j5-5-5-1](/Users/dongyanzu/Desktop/j5-5-5-1.svg)



运行一下：

`incrementAndGet()`也是不使用`synchronized`就能保证数据操作原子性的方法：



```
incrementAndGet() {
		//取得当前值
		
		//加一
		
		//return 新值
}
```

在Console输出：

输出顺序其实没有关系，学号的确做到了没有重复，在多线程情况下没有重复或跳过数字的情况。



##### AtomicInteger 特点



从 Java 官方文档 可以看到 `incrementAndGet()`和`decrementAndGet()`都没有加`synchronized`关键字：



这就意味着，虽然递增、递减也是多个步骤，但多线程场景下，其它线程不会等待。只是在 数据变化 的时候，会判断一下 是否有 其它线程 修改了数据，如果有就根据最新的值进行修改。

这就是这节讲的主题：乐观锁。



##### 乐观锁和悲观锁



乐观锁其实是不上锁，总是保证基于最新的数据进行更新。由于没有上锁，就提高了性能。不上锁的思想是乐观的，所以称之为乐观锁。`AtomicInteger`类的`incrementAndGet()`和`decrementAndGet()`方法就是典型的乐观锁实现。



相对的，`synchronized`关键字是把整个方法执行前九上锁，假设其它线程*一定会修改*数据，所以提前防范。上锁的思想是悲观的，所以称之为悲观锁。

> 乐观锁和悲观锁是面试过程中出现概率很高的知识点。

对比这节中的两个案例我们可以总结出两者的区别：



##### 乐观锁



不适用于多条数据需要修改、以及多个操作的整体顺序要求很严格的场景，乐观锁适用于读数据比重更大的场景；反之，



##### 悲观锁



适合写数据比重更大的应用场景，一般来说写数据的整体消耗时间更长些，是可以接受的。



##### 一种思想



乐观锁/悲观锁实际上是一种思想，不是 Java 领域特有的概念。在其它领域，例如数据库系统中也有乐观锁/悲观锁的概念，这里就不赘述了。



了解 Java中的乐观锁/悲观锁，那么对其它领域的乐观锁/悲观锁也是一通百通的。



#### 5.7 并发容器（一）



春蕾中学新生入学的时候，先报名注册，会自动获得一个学号。新生注册可能是网上注册，或者校园现场新生接待处的窗口排队注册。



每位新生报名成功后，会受到欢迎消息：

```java
你好XXX，欢迎来到春蕾中学大家庭
```

##### 分析

跟上一节一样，相当于多线程并发情况下，要保证学号不能重复。不一样的是，多了后继任务：在取得学号以后，打印欢迎消息。



多个任务有前后的顺序，但后继的任务不必等待所有前置的任务全部完成后再执行，而是每个前置任务完成后，自动执行对应的后置任务。

> 可以想象，如果等最后一个新生报名完毕，再统一打印欢迎消息，会非常没有时效性，太慢了，体验肯定不好。



这种场景下，适合用`java8`新的`CompletableFuture`特性来解决，会更好。



##### CompleteableFuture 应用

`CompletableFuture`是一个异步任务编排、调度框架，以更优雅的方式实现组合式异步编程。



在本章第1，2节中学习了Java最基本的多线程编程，当然也是`CompletableFuture`的基础。但基本的多线程的编程不利于任务的管理（包括编排、调度等），在Java8时代，使用新的`CompltableFuture`技术就可以让多线程并发编程更优雅。



> 在方法调用的时候（就是所谓任务），需要等待返回取得返回值是同步，不等待而继续执行程序代码就是异步。采用异步方式，能够支持多个任务并行执行，这种机制称为并发。

先看类图，类与类之间的关系发生了变化：

![j5-5-6-2](/Users/dongyanzu/Desktop/j5-5-6-2.svg)



##### 1. Register 类重构



一个重大变化是，用于获取学号的`Register`类不必实现多线程接口了。



```java
import java.uril.concurrent.atomic.AtomicInteger


public class Register {
	private static AtomicInteger count = new AtomicInteger(0);
	
	//注册学号
	public Student regId(Student student) {
		student.setId(count.incrementAndGet());
		return student;
	}
}
```

所以，不必实现`run()`方法，改为`regId()`完成注册。



##### 2. 并行注册



```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class StudentIDTest {
  public static void main(String[] args) {
    // 构建学生集合
    List<Student> studentList = new ArrayList<>();
    for (int i = 1; i <= 10; i++) {
      Student s = new Student();
      s.setName("学生" + i);
      studentList.add(s);
    }

    Register reg = new Register();

    studentList.forEach(s -> {
      CompletableFuture.supplyAsync(
          // 每个学生都注册学号
          () -> reg.regId(s)
        )
        // 学号注册完毕后，打印欢迎消息
        .thenAccept(student -> {
          System.out.println("你好 " + student.getName() + ", 欢迎来到春蕾中学大家庭");
        });
    });

    System.out.println("mission complate");
  }
}
```

> Java8 时代使用 Lambda 表达式的代码随处可见，不熟悉注意前面复习

`CompletableFuture.supplyAsync()`方法运行一个异步任务，并且返回结果，所以`regId()`方法必须有返回值。



`Register`虽然没有实现`Runnable`接口，但系统会自然优化：把作为`supplyAsnc()`方法参数的整个`() -> reg.regId(s)`表达式语句包装在另一个对象中；这个对象也是JDK内置的，它实现了`Runnable`接口，在这个对象中执行表达式语句。



> 有兴趣可以深入研究JDK中的CompletableFuture的源码

所以实际上，`supplyAsync()`方法的作用是：在一个单独的线程中执行`reg.regId(s)`语句，本质上就是多线程编程。



在注册完毕以后（使用`thenAccept()`方法完成后继的任务步骤。`thenAccept()`方法的参数(`student`)就是前置任务的返回结果，系统会在前一个任务完成后，自动执行`student->{}`后继任务。所以本质上，后继任务也是多线程方式执的。`thenAccept()`方法通常用于任务链的末尾。



> 一般情况下，不建议一个大任务的所有步骤都集中在`supplyAsync()`里实现，分步骤更好。



以上文字结合图示理解一下：

![j5-5-6-1](/Users/dongyanzu/Desktop/j5-5-6-1.svg)



从Console 的输出内容可以看到，主程序执行完毕输出了 mission complate ，以及异步打印了新生欢迎信息。



##### CompletableFuture vs Stream

是不是感觉`CompletableFuture`有点像第三章的`parallelStream()`？

它们其实都使用了多线程并发编程，都可以称为并发容器。不同的是：`Stream parallelStream()`侧重点事流的元素的计算操作；而`CompletableFuture`的任务比较宽泛。



#### 5.8 并发容器（二）

不是每个任务都只有两个步骤



春蕾中学新生入学的时候，先报名注册，再分配班级，然后才能收到欢迎消息。



这时候，增加了一个步骤，**CompletableFuture**有更优雅的方法实现吗？

答案肯定是有的。



##### 1. 多步骤任务

​	**1.1**班级分配类：

​	为了方便演示，学生随机分配到四个班级的其中一个。当然学生类增加一个`classId`属性：

```java
public class Student {
	private int id;
	private String name;
	private String classId;
}
```

然后完成班级分配者类：`Distributor`。方法`assignClasses()`完成班级分配。



采用`Random`的`nextInt()`方法，取得一个随机数，作为班级号。

  **1.2**任务执行

​	只需要调用`CompletableFuture`类的`thenApply()`方法即可，可信代码如下：

```java
CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  })
  .thenAccept(student -> {
     System.out.println("姓名：" + student.getName() + "，学号：" + student.getId() + "，班级号：" + student.getClassId());
  });
```

`supplyAsync()`用于开头，`thenAccept()`用于末尾，各自调用一次即可。中间有多个步骤，可以调用多次`thenApply()`。由于末尾也要用到`student`实例对象，所以位于中间的`thenApply()`方法，总是要`return`学生实例对象，否则下一个步骤就获取不到了。



结合图示理解一下：

![j5-5-7-1](/Users/dongyanzu/Desktop/j5-5-7-1.svg)



需要强调的是：

- 对于多个任务之间，是并行的，使用多线程同时执行多个任务；
- 而对于一个任务的多个步骤，是串行的，必须先执行完前一个步骤才能执行下一个步骤。



**CompletableFuture**不仅提供了异步任务编排，也通过不同的方法把步骤区分开，使代码更优雅，更易阅读和维护。



##### 2. 扩展知识点 ：返回值

`supplyAsync()`是静态方法，返回值是`CompletableFuture`实例对象，再调用`thenApply()`或`thenAccrpt()`实例方法，返回的也是`CompletableFuture`对象。



所以，虽然整条语句是连写的，其实也可以定义返回值。



```java
CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  })
  .thenAccept(student -> {
     System.out.println("姓名：" + student.getName() + "，学号：" + student.getId() + "，班级号：" + student.getClassId());
  });
```

返回的值仍然是`CompletableFuture`实例对象，所以定义变量类型就是`CompletableFuture`。但可以用泛型`CompletableFuture<>`表示其中包含的数据具体是什么类型。



因为本案例末尾调用了`thenAccept()`，其Lambda表达式没有`return `语句，表示`CompletableFuture`实例对象不包含数据，所以泛型写为`CompletableFuture<void>`.



> Void 的完整写法是`java.lang.Void`，是void关键字的包装类，表示没有类型，等同于null



##### 返回CompletableFuture类型



如果没有调用`thenAccept()`方法，以`thenApply()`或`supplyAsync()`结尾的话，例如代码：

```java
CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  });
```

引起`thenApply()`的Lambda表达式返回的是`Student`对象，所以`CompletableFuture`实例对象包含的是`Student`数据，于是泛型写为`CompletableFuture<Student>`

```java
CompletableFuture<Student> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  });
```

> 这几个方法返回的是`CompletableFuture`实例，但其中包含什么类型的数据取决于Lambda表达式返回值的类型，如果没有返回值，则用<Void>表示。

##### 3. 扩展知识点：main()方法的问题



目前为们的程序，都是通过`main()`方法执行的。如果学生人数比较多，例如2000个，所有注册线程的运行就没有那么快完毕了。



问题是，可能线程任务还没执行完毕。`main()`方法就执行完毕，导致程序运行结束退出了。



看到这里，大家可以在电脑上运行程序，执行2000个甚至10000个学生注册，观察出现的现象。



要解决这个问题，返回值就有用了。我们先把每个学生的入学任务实例对象(`CompletableFuture<Void>`) ， 收集起来（装入集合），然后等待所有的线程执行完毕。



```java
List<CompletableFuture> cfs = new ArrayList<>();
studentList.forEach(s -> {
  CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
    .thenApply(student -> {
        return dis.assignClasses(student);
    }).thenAccept(student -> {
        System.out.println("姓名：" + student.getName() + "，学号：" + student.getId() + "，班级号：" + student.getClassId());
    });

  cfs.add(cf);
});

try {
  // 等待所有的线程执行完毕
  CompletableFuture.allOf(cfs.toArray(new CompletableFuture[] {})).get();
} catch (Exception e) {
  e.printStackTrace();
}
```

`CompletableFuture.allOf()`是静态方法，作用就是所有的任务实例对象。因为`allOf()`方法只支持数组不支持集合，所以需要把集合转换成数据（`cfs.toArray(new CompletableFuture[]{})`)。当然，你可以一开始就定义数组收集任务实例对象，因为学生的个数可以通过`studentList.size()`取得。`allOf()`方法的返回值也是`CompletableFuture`实例对象。



再调用类方法`get()`，其作用就是等待所有的任务线程（`allOf()`收集的）都执行完毕，再继续执行（本案例`main()`方法后面没代码了，就退出程序）。



需要强调的是：



在SpringBoot等服务端运行`supplyAsync()`异步任务编排的时候，就没有必要使用`get()`方法等待所有线程任务执行完毕了。因为服务端往往是常驻程序，不像`main()`方法执行完毕就退出程序了。



##### 3. 再次理解同步与异步

`get()`方法造成了`main()`方法等待，所以是同步的；通过`CompletableFuture`编排的任务，不会造成`main()`方法等待，是异步的。



##### 额外知识点补充

##### 知识点1:安全的布尔值包装类

`Java.util.concurrent.atomic.AtomicInteger`能够以原子的方式操作整数，Java也提供了

`Java.util.conCurrent.atomic.AtomicBoolean`能够以原子的方式操作布尔值。



因为布尔值只有true/false两个值，AtomicBoolean使用起来就很简便了。



`AtomicBoolean`是`boolean`的包装类，`AtomicBoolean`的实例等同于一个布尔值。

- `new AtomicBoolean(true)`等同于true
- `new AtomicBoolean(false)`等同于false

取得布尔值



实例对象取得基础类型的布尔值，可以调用`get()`方法：

```java
AtomicBoolean ab = new AtomicBoolean(true);
boolean value = ab.get();
```

实例对象调用 `compareAndSet()`方法，就能以原子的方式修改值：

true改为false



`compareAndSet(true,false)`判断当前值为true时，修改为false，然后返回成功或失败。这是三个步骤哦。

- 修改成功后，方法返回`true`
- 如果当前值不是true，则不修改，返回值为`false`，表示操作失败

> `compareAndSet()`实际上就是保证了整个修改操作的三个步骤的原子性，不会因为多线程出现错乱。

false 改为 true



`compareAndSet(false,true)`判断当前值为 false 时，修改为true，然后返回成功或失败。



- 修改成功后，方法返回`true`。
- 如果当前值不是false，则不修改，返回值为`false`，表示操作失败



再次强调：`compareAndSet()`方法返回值表示修改操作成功或失败，跟方法参数值无关。



##### 知识点2：循环中断



在循环语句中(包括`for``while`等各种循环)，可以用`break`关键字中断，结束本次循环。



```java
public static void testBreak() {
	for (int i=0; i< 5;i++) {
		if( i==2 ) {
			System.out.println(i);
			break;
		}
	}
	System.out.println("break测试")
}
```

如果写一个`main()`方法运行，那么输出是：

```
2
break测试
```

因为 i = 2 等于2的时候，会执行`break;`整个for循环就结束了，继续运行`for(){}`之后的程序代码。

##### 需求

白鹿洞书院一间阅览室，只有5个座位，有20个学生，需要在阅览室上晚自习，每人各有一次机会抢到座位学习。学习完毕后离开座位，其它同学再抢。



##### 分析及思路

阅览室的5个座位，就需要用到`AtomicBoolean`。每个座位都是一个`AtomicBoolean`的实例对象：true表示有人坐了，false表示空闲。



最开始座位都是空闲的，那么所有座位值都是false，一旦有人抢到座位，就相当于调用`compareAndSet(false,true)`成功。相对的，`compareAndSet(true,false)`就表示人走了座位空闲了。



先看了一下类图：

![j5-5-7-p2-1](/Users/dongyanzu/Desktop/j5-5-7-p2-1.svg)



##### 知识点3:while 循环

除了`for`循环外，另一常用的循环是`while`循环。`while`循环语法更简单。



```java
public static void testWhileBreak() {
  int i = 1;
  while (i < 100) {
    if(i > 10) {
      break;
    }
    i++;
  }
}
```

`while()`小括号内表示循环条件，为true时，执行循环体（`{}`）内的语法。当然，`break;`生效时，仍然会中断循环，使循环结束。



如果写一个`main()`方法运行，那么输出就是：

```java
11
```

特别强调，使用`while()`要特别注意不能造成死循环，一定要控制好小括号内的循环条件，如果条件永远为true，那么就死循环了，死循环会造成程序的崩溃。



#### 5.9 线程池



使用`Runnable`接口开发多线程程序，更符合面向对象的习惯，但是随之而来的问题是，对象太多。



本章第五节为了方便，只演示了四位同学注册的场景，稍微回顾一下上节代码：

```java
public class StudentIDTest {
    public static void main(String[] args) {
for (int i = 1; i <= 4; i++) {
    Student s = new Student();
    s.setName("学生" + i);
    Register register = new Register(s);
    Thread thread = new Thread(register);
    thread.start();
}
    }
}
```

但实际上在现实中，入学人数肯定不是4个人这么少。如果有一千位同学入学，就意味着程序要额外`new Thread（register）`一千次。对象除了创建需要消耗计算机CPU、内存等资源、对象还会被销毁（系统自动做的），销毁也是要消耗资源的。



可能现在对四次和一千次的资源消耗没什么感觉，但实际场景中，淘宝之类的网站，每天的流量可能是即使、几百亿级别的。这样规模的资源消耗如果能节省，性能提升就非常可观了。



那么能不能做到一些优化，做到复用`Thread`对象，不必每次都创建新对象呢？



答案肯定是有的：Java 提供了 线程池 技术



##### 线程池基本概念



所谓 线程池 顾名思义，就像一个池子，里面装满了线程，随用随取。线程可以被 复用 ， 一个线程 ， 可以执行 A任务，也可以执行 B 任务，于是线程不再频繁创建和销毁。



> `new Thread(register)`意味着一个线程对象只能执行一个任务，而线程池让线程与任务分离，不再紧密绑定。

线程池的另一个重要概念是，线程池并不是无限大的（计算机CPU、内存等资源毕竟有限) ，所以线程池中存在的线程数也是有限的，这就意味着能同时运行的任务数是有限的，其它过剩的任务就需要排队。等其它任务完成后，有空闲的线程后，才能继续执行任务。



![threadpool](/Users/dongyanzu/Desktop/threadpool.jpeg)

##### 线程池创建



根据《阿里巴巴Java开发手册》 （业界著名的开发条约）



创建线程池的核心代码是：

```java
import org.apache.commons.lang3.concurrent.BasicThreadFactory;

import java.util.concurrent.*;

public class StudentIDTest {

  // 线程工厂
  private static final ThreadFactory namedThreadFactory = new BasicThreadFactory.Builder()
    .namingPattern("studentReg-pool-%d")
    .daemon(true)
    .build();

  // 等待队列
  private static final BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>(1024);

  // 线程池服务
  private static final ThreadPoolExecutor EXECUTOR_SERVICE = new ThreadPoolExecutor(
20,
200,
30,
TimeUnit.SECONDS,
workQueue,
namedThreadFactory,
new ThreadPoolExecutor.AbortPolicy()
      );

  public static void main(String[] args) {

  }
}
```

这里的`BasicThreadFactory`需要依赖一个库，这个库也是经常会使用的工具库：

```xml
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.10</version>
</dependency>
```

创建线程池的代码，基本上属于固定写法，有不懂的类和方法，也没关系，不要太纠结。



##### 一、创建线程工厂实例



我们在上一章了解了工厂模式，顾名思义，线程工厂就是用来生产线程池中的这些线程。



```java
new BasicThreadFactory.Builder()
		.namingPattern("studentReg-pool-%d")
		.daemon(true)
		.build();
```

唯一需要注意的是，`namingPattern()`方法是定义线程名字的格式，相当于线程名称模版，需要我们自己根据具体的业务需求把 ***studentReg*** 改掉。



`studentReg`表示当前线程运行的学生注册任务。我们自己选择合适的线程名称，不要所有任务都用`studentReg`。例如商品发布任务可以命名为`"offer-pool-%d"`自己能理解意思就好。



> 其它每个方法的具体作用就不要纠结了，有兴趣的话，可以自己找资料研究，不是当前的重点。
>
> > 多说一点多是，Builder（）不是方法，是构造函数，BasicThreadFactory类中有一个内部类Builder。
> >
> > > new BasicThreadFactory.Builder()创建了内部类的实例对象。



##### 二、创建线程等待队列实例



线程池没有空闲的线程时，其它的任务，就需要在队列中等待。



> 可以类比一下：春运期间坐火车的人太多，火车站候车大厅容量有限，很多乘客就在候车大厅外排队等候。

如果机器性能好，CPU 核数多（6，8核），内存大，队列可以大一些，`new LinkedBlockingQueue<Runnable>(2048)`。构造函数的参数表示能排队的任务个数。



如果机器性能好，CPU 核数少（1，2核）、内存大、队列就小一些：`new LinkedBlockingQueue<Runnable>(512)`



一般来说，`new LinkedBlockingQueue<Runnable>(1024)`也还可以。



##### 二、创建线程实例



`ThreadPoolExecutor`构造函数参数较多，七个参数按顺序说明如下：

| 参数序号 |                             解释                             |
| :------- | :----------------------------------------------------------: |
| 1        |       线程池初始化核心线程数量，一般是两位数，通常不大       |
| 2        | 线程池最大线程数，计算机性能强就大一些，否则小一些，通常不超过200 |
| 3        | 线程池中的线程数超过核心线程数时，如果一段时间后还没有任务指派，就回收了。想立即回收就填0，一般30 |
| 4        |       第三个参数的时间单位。30+TimeUit.SECONDS表示30秒       |
| 5        |                  等待队列实例，已经创建过了                  |
| 6        |                  线程工厂实例，已经创建过了                  |
| 7        | 任务太多，超过任务的容量时，用什么样的策略处理。一般用AbortPolicy表示拒绝，让主程序自己处理。 |

多线程编程特别需要注意的问题是：防止线程数过多把系统搞崩溃，所以用线程池可以做更加精确的控制，否则难以控制、无法保证稳定。



实际编程工作中，要想办法保证不要创建太多的任务，要有所控制，而不是只管创建任务扔进线程池。比如可以采用分页的思想、分批处理。一批只处理几十个、一二百个任务。还有考虑任务执行时间，能不能快速结束。不要让一台计算机堆积太多任务，保证线程等待队列能容纳。

>这些容量大小的各个参数值，在学习阶段，都不用纠结。例子中的够用了
>
>> 实际工作中，根据公司的服务器的状况，选择合适的数值，到时候公司经验丰富的同事请教、沟通即可。

创建的三段代码甚至可以copy，不过我们还是应该了解每个参数的含义，面试的时候肯定有用。



##### 使用线程池运行任务

参考任务：

![j5-5-5-1](/Users/dongyanzu/Desktop/j5-5-5-1.svg)



```java
public class StudentIDTest {
	public static void main(String[] args) {
		// 构建学生集合
		for(int i=1;i <= 2000; i++) {
			Student s = new Student();
			s.setName("学生"+i);
			Register register = new Register(s);
			//传入 Runnable 对象，运行任务
			EXECUTOR_SERVICE.execute(register);
		}
	}
}
```

只要执行线程对象的`execute()`方法，把实现了`Runnable`接口的实例对象传入即可。



##### 等待线程池执行



使用`main()`函数运行多线程程序，往往会遭遇一个问题：多线程还没有运行完，`main()`函数就退出了。

> 本示例运行时，看到的学生编号可能不足2000

因为`for`语句后面没有代码了，`main()`函数执行完毕，整个JVM就结束了。不会因为线程还没有执行完而等待。



> 线程数特别少的时候，执行较快，就没有问题。



这时为了让`main()`不立即退出，可以等待一段时间。

```java
for (int i = 1; i <= 2000; i++) {
  ... ...
  ... ...
}

try {
    Thread.sleep(3000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

本节示例比较简单，等待2～5 s就可以。



当然，如果是SpringBoot 项目中，就没有这个问题，因为SpringBoot项目是常驻程序，持续运行直到工程师主动关闭，就不需要等待多线程了。



#### 5.10 线程池和并发容器



我们先学习并发容器，又学习了线程池，那么多线程编程到底要用什么呢？



实际上，`CompletableFuture`内容也用到了线程池。

```java
CompletableFuture.supplyAsync {
	() -> reg.regId(s);
}
```

实际上是把任务放入内部的默认线程池里执行的。

> 有兴趣可以分析`CompletableFuture`源码

`CompletableFuture`也可以指定线程池来运行任务：

````java
CompletableFuture.supplyAsync {
	() -> reg.regId(s);
	EXECUTOR_SERVICE
}
````

`supplyAsync()`方法可以有第二个参数，传入我们构建好的线程池对象。那么任务就是用指定的线程池而不是默认的。



##### 技术升级



线程池也可以运行任务，但是不利于编排，知识把实现了`Runnable`接口的任务对象扔进线程池运行。



大家这时是不是隐约可以感觉到 Java 系统的升级进化历程：

```java
基础多线程
  ↓
线程池
  ↓
并发容器
```

如果一家企业技术升级比较慢，还处于 Java 6 时代，那么多线程编程用线程池就够了；如果一家企业技术升级比较快，已经使用 Java 8 ， 那么就要用并发容器了。



##### 指定线程池的场景



各位同学在学习阶段，一般来说，直接`supplyAsync( ()-> {})`就够了。在企业中，遇到任务并发度高、任务量大、任务执行慢的情况下，就需要指定线程池，严格控制线程任务。

> 实际工作中，多于公司经验丰富的同事请教、沟通、具体情况具体分析。

或者一开始使用`CompletableFuture`默认线程池，当发现任务执行慢、任务堆积的问题，就要考虑指定线程池，并调整线程池参数。



必须记住这个知识点，当出现问题时，能够尝试指定线程池，避免一头雾水，不知所措。



线程池的概念本身比较复杂，需要一些抽象的思维，加上本章的概念很多。但是个人的技术成长，不能一直停留在编码的阶段，原理和概念必须理解，才能在以后的面试和实际工作中游刃有余。



#### 6.1 豆瓣 FM 项目爬虫重构



在《实战豆瓣FM》项目中，坐了爬虫爬取歌单、歌曲等数据。



彼时项目有一饿问题。因为使用了`@PostConstruct`注解让爬虫在系统启动时启动

```java
@PostConstruct
public void init() {

}
```

会导致系统启动很慢，可能第一次完全没有数据的时候启动爬虫，慢一点能忍受；但是第二次爬取时，因为已经有数据了，启动慢就难以忍受。



此时我们就可以用 **CompletableFuture** 来解决



重构豆瓣 FM 爬虫代码。解决启动过慢的问题。

> 所谓重构，就是保证功能不变差、保证兼容性的情况下，让项目可读性、性能、维护性等方法更优秀。
