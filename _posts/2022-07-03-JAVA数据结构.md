---
Layout: post
desc: java数据结构基础
title:  java数据结构基础
tag:  study

---

## JAVA数据结构

### <1>复杂度



#### 1.1 大O记法



##### 计算机如何判断程序性能？

我们都知道，编程基本上是在和数据打交道，大多数程序基本在处理获取数据、查询数据、操作数据、返回数据相关的逻辑。



因此出现了数据结构和算法，这两者出现本质是为了解决如何能够更快，更省进行数据处理。



这里的更快，也就是程序运行时间更短，对应的指标我们称之为时间复杂度。



这里的更省，也就是程序运行所消耗的内存更少，对应的指标我们称之为空间复杂度。



##### 为什么需要复杂度

`《1》程序运行时间更短《2》消耗的内存更少`分别表明了开始运行和结束运行两个时间点差额和内存使用情况。

![1](/Users/dongyanzu/Desktop/1.svg)

通过这种计算方法可以判断性能，为什么还需要进行复杂度分析呢？主要有三个原因。

1. 测试结果大大依赖硬件条件

> 不同机器运行时间差别很大。

2. 测试结果需要事后才能计算

> 往往我们是在程序运行之后才能形成统计结果，但我们大多希望在伪代码阶段，便能预测程序的执行性能。

3. 测试结果受原始数据特性影响大

> 我们以排序为例，如果给出的数据已经是排好序的，那需要的时间几乎等于0，而如果给出的数据是完全打乱的，那需要的时间肯定非常长。

##### 总结

我们需要一个不用具体的测试数据和测试环境，这样就可以粗略地估计算法执行效率的方法。这个方法我们称作为复杂度，我们称作为大O记法。



#### 1.2 时间复杂度

-----暂时省略





#### 1.3 空间复杂度

##### 如何计算空间复杂度？



空间复杂度和时间复杂度一样，同样遵循大 O 记法。

时间复杂度是以步为基础单位，空间复杂度是以一个基础数据类型值当作基础数据。



O(1)

```java
int a = 0;
int j = 0;
```

O(n)

```java
int a[] = new int[n]
```

代码都比较简单，就不多做解释啦。

##### 优先考虑时间复杂度

在实际编程过程中，我们大多数情况**只会考虑时间复杂度**！！为什么呢？

因为我们默认计算机内存是足够大的，足够给我们使用的。 大家是否听说过**摩尔定律**。

> 当价格不变时，集成电路上可容纳的元器件的数目，约每隔 18-24 个月便会增加一倍，性能也将提升一倍。

换而言之，**每个 18-24 个月，同样大小的芯片里可存储的数据量将翻一倍**。 因此我们完全可以忽略内存空间不够的情况。

**除非**，注意除非大家以后参与嵌入式开发，参与单片机相关的编程开发，才需要注意空间问题。 **之后的讨论，都只会基于时间复杂度问题展开**。



#### 1.4 查找

##### 线性查找

遍历数组，取出数组中每个元素，与目标元素进行对比。暴力查找，方法很简单，但是很笨。

```java
//伪代码部分段
//目标数组
int[] arr = new int[] {2,3,4,5,8,4,9,0};

//目标元素
int target = 8;

//目标元素所在的下标
int index = -1;

for(int i = 0 ; i< arr.length; i++) {
	if(arr[i] == target) {
		index = i;
		break;
	}
}

System.out.println("index: " + index);

```

##### 性能优化-而二分法查找

我们按照线性查找，很显然我们知道查找方法的时间复杂度是:O(N);



做一个性能优化，对于**有序数组** 我们可以使用二分法查找。由于数组是有序的，我们可以先比对中间索引值，再来缩小查找的范围。

```java
public static int find(int[] array, int aim) {
    // 初始化left = 最左侧, right = 最右侧
    int left = 0;
    int right = array.length - 1;

    // 当left > right则表示遍历完成
    while (left <= right) {
        // 获取中间的值
        int middle = (left + right) / 2;
        int middleValue = array[middle];
        if (middleValue == aim) {
            // 已经找到目标
            return middle;
        } else if (middleValue < aim) {
            // 目标在middle的右侧，重置left
            left = middle + 1;
        } else {
            // 目标在middle的左侧，重置right
            right = middle - 1;
        }
    }
    return -1;
}
```

对于二分法查找而言，时间复杂度为 O(log(N)) 。



#### 1.5 二次问题

前一节我们体会到了`O(n)->O(log(N))`优化。

> 假设给定一个数字数组，数组里面每个数字介于 0 -10 之间，请找出里面重复的数字。

比如：

```java
数字数组为：[0, 8, 2, 3, 5, 6, 2, 2, 10, 8]

重复数字为：[8, 2]
```

##### 暴力破解

每次获取一个元素，依次判断这个元素和之后的元素是否有重复。

```java
public static ArrayList<Integer> repeat(int[] array) {
    ArrayList<Integer> result = new ArrayList<>();
    for(int i = 0; i < array.length; i++){
        // 以此判断i位置元素和后面j位置元素是否相等
        for(int j = i + 1; j < array.length; j++){
            if(array[i] == array[j]){
                // 如果之前result没有，则进行添加
                if(!result.contains(array[i])){
                    result.add(array[i]);
                }
            }
        }
    }
    return result;
}
```

该方法的时间复杂度，由于有两个`for`循环嵌套，所以是`O(N^2)`



##### 标记法（更优）

由于我们需要查找的是，0-10数字数组里面重复的数字。



我们可以通过申请一个数组，数组名称为`exists`,表示数字是否存在。数组的长度为11，并且数组里面的值默认都为 0 ，表示 0 -10 这 11 个数默认都不存在。



扫描数组中的数字，如果出现则对`exists`数组中的位置标记为1，此后从数组中扫描出来的数字中，如果有重复，则将记数改为2，此后在出现大于2的重复数字不需要再添加进去，所以需要判断标记位为1，才能添加进入`result`数组中。



```java
public static ArrayList<Integer> repeat(int[] array) {
    ArrayList<Integer> result = new ArrayList<>();
    int[] exists = new int[11];
    for (int i = 0; i < array.length; i++) {
        int value = array[i];
        // 只有当前位置已经为1，标示重复，并且输出，>1情况则不输出了
        if (exists[value] == 1) {
            result.add(value);
        }
        // 用exists标示记录
        exists[value]++;
    }
    return result;
}
```

该案例，很好解释了，通常我们会使用空间换取时间。



### <2> 数组

#### 2 数组

##### 数组存储

*数组的索引都是从0开始的。*

> 数组（Array） 是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。

线性数据结构：表示数组中数据都是按照前后这种线性顺序排列的。相同的数据类型：数组中的每个值的数据类型都相同。



##### 数组读取

每个数组都有对应的内存地址，我们将其称作为数组开始地址 ---start_address



数组在定义的时候，以及确定每个数组元素的数据类型了，也就是我们知道每个元素需要的内存空间大小，我们称为 --- item_size。



求第N个元素地址公式如下：

```java
// 第 N 个元素地址
start_adress + item_sieze * (N-1);
```

1. 时间复杂度

>数组的索引访问的时间复杂度是O(1)

2. 为什么数组索引从 0 开始？

> 内存地址的计算规则决定开始地址为start_adress + item_sieze * 0，在计算机中为了方便位置的计算，所以数组索引从 0 开始。

##### 面向对象的数组（包括数组元素的添加，删除，插入，替换）

```java
public class MyArr {
	// 用于存储数据的数组
  private int[] elements; //举例int类型数组
  //记录当前顺序表中的元素个数
  private int length;
  public MyArr(int capacity) {
    this.elements = new int[capacity];
    this.length = 0;
  }
  //获取数组长度的方法
  public int size() {
    return elements.length;
  }
  //往数组的末尾添加一个元素
  public void add(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length+1];
    //把原数组中的元素复制到新数组中
    for (int i =0 ; i <elements.length;i++) {
      newArr[i] = elements[i];
    }
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr ;
  }

  // 打印所有元素到控制台
  public void show() {
    System.out.println(Arrays.toString(elements));
  }
  // 删除元素
  public void delete(int index) {
   	check();
    //创建一个新的数组，长度为原数组的长度为-1
    int[] newArr = new int[elements.length-1];
    //复制原有的数据到新数组
    for(int i = 0 ; i < newArr.length ; i++) {
      //想要删除的元素前面的元素
      if(i < index ) {
        newArr[i] = elements[i];
      }
      //想要删除的元素后面的元素
      else{
        newArr[i] = elements[i+1];
      }
    }
    //新数组替换旧数组
    elements = newArr;
  }
  //取出指定位置的元素
  public int get(int index) {
    check(index);
    return elements[index];
  }
  //插入一个元素到指定位置
  public void insert(int index , int element) {
    check(index);
    //创建一个新的数组
    int[] newArr = new int[elements.length+1];
    //将原数组中的元素放入新数组中
    for(int i=0;i<elements.length;i++) {
      //目标之前的元素
      if(i < index) {
        newArr[i] = elements[i];
      }
      //目标之后的元素
      else{
        newArr[i+1] = elements[i];
      }
    }
    //插入新数组
    newArr[index] = element;
    //新旧数组替换
   	elements = newArr;
  }
  //替换指定位置的元素
  public void set(int index , int element) {
    //判断下标是否越界
    check(index);
    return elements[index] = element;
  }
  //判断线性表是否为空
  public boolean isEmpty() {
    return N==0;
  }
  //封装一个检查下标是否越界的方法
  public void check(int i) {
    if(index < 0 || index > elements.length-1) {
      throw new RuntimeException("下标越界");
    }
  }
}

public class TestMyArr {
  public static void main(String[] args) {
    MyArr myArr = new MyArr();
    //可以调用一系列 myArr 方法。
  }
}
```

*线性表的增删都需要对内存进行申请，增删操作会比较慢。*



### <3>链表

#### 3.1链表

##### 1  单链表

​	线性表的链式存储结构（简称链表）是指用一组人意的存储单元来依次存放线性表的结点，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。

单链表结点结构需要（data 数据域 和 next 指针域）。链表正是通过每个结点的链域将线性表的n个结点按其逻辑次序链接在一起的。由于 上述 链表中的每一个结点只含有一个链域，故将这种链表称为单链表。

``` java
//一个结点
public class Node {
  
  //结点内容
  public Object data //数据域   
  //下一个结点 
  public Node next； //指针域
  //空构造函数
  public Node() {
		this(null,null);
  }
  public Node(int data) {
    this.data = data;
  }
  //两个参数的构造函数
  public Node(int data , Node next) {
    this.data = data;
    this.next = next;
  }
}
	
	//单链表增删改查实现
	public class LinkList{
  	//单链表头指针
  	private Node head;
    //记录链表的长度
    private int length;
  	//单链表构造函数
  	public LinkList() {
    	//初始化头结点
    	this.head = new Node();
      //初始化长度
      this.length=0;
  	}
  	//将一个以及存在的带头结点的单链表置成空表
  	public void clear() {
    	head.next = null;
    	this.N = 0;
  	}
  	//判断带头结点的单链表是否为空
  	public boolean isEmpty() {
    	return head.next == null;
  	}
  	//求链表的长度
  	public int length(){
    	return length;
  	}
    //求带头结点的单链表中的第i个结点
  	public Object get(int i ){
    	//通过循环从头结点开始往后面罩，依次找i此，就可以找到
    	Node p = head.next;
    	while(int index = 0 ; index < i ; i++) {
      	p = p.next;
    	}
    	return p.data;
  	}
  	//按值查找
  	public int indexOf(Object x) {
			//从头结点开始便利，取出data与x比较，如果相同，则找到
    	Node p = head.next;
    	for(int i = 0;n.next!=null;i++) {
        n = n.next;
        if(n.data.equals(x)) {
          return i;
        }
      }
      	return -1;
  	} 
  	//插入元素
  	public void insert(Object x) {
      //找到最后一个结点
      Node s = head;
      while(n.next!=null) {
        n = n.next;
      }
	 		//创建一个新的结点，保存元素x
      Node newNode = new Node(data,null);
      //让最后一个结点指向新结点
    	n.next = newNode;
      length++;
 	 	}
    //向指定位置i插入元素，添加元素t
    public void inset(int i , Object x) {
      //找到i位置前一个结点
      Node pre = head;
      for (int index=0;index=i-1;i++) {
        pre = pre.next;
      }
      //找到i位置的结点
      Node curNode = pre.next;
      //创建新结点，并且新结点需要指向原来i位置的结点
      Node newNode = new Node(x , curNode);
      //原来i位置的结点指向新结点
      pre.next = newNode;
      //元素的个数+1
      length++;
    }
  	//删除带头结点的单链表中的第i个结点
 		public void remove(int i ){
    	//p得等于head,而不是head.next
    	Node p = head;
      //找到i位置的前一个结点
      Node pre = head;
      for (int index=0;index=i-1;i++) {
        pre = pre.next;
      }
      //找到i位置的结点
      Node curNode = pre.next;
      //找到i位置的下一个结点
      Node nextNode = curNode.next;
    	//前一个结点指向下一个结点
    	pre.next = nextNode;
      //元素个数-1
      length--;
      /**
      *如果需要返回删除的元素，则：
      *return curNode.data;
      */
    	}
    public void listOutput() {
      Node p = head.next;
      while( p != null ) {
        System.out.println(p.data);
        p = p.next;
      }
    }
	}

public class TestNode {
  
  public static void main(String[] args) {
    /**
    *生成链表
    */
    //创建结点
    Node n1 = new Node(1, null);
    Node n2 = new Node(2, null);
    Node n3 = new Node(3, null);
    //此时创建了三个只有数据域的结点
    n1.next = n2;
    n2.next = n3;
  }
}
```

##### 2 双链表



#### 3.2 栈

从数据的逻辑结构角度看，栈是线性结构的，也是线性表（一种操作受限的线性表《FILO》）。栈是限制在表的一端进行插入和删除运算的线性表。

通常称允许进行插入、删除的一端为栈顶，另一端为栈底。当表中没有元素则称为空栈。

```java
public class MyStack {

  //栈的底层我们使用数组来存储数据
  int[] elements;
  
  public MyStack() {
    elements = new int[0];
  }
  
  //压入元素
  public void push(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length + 1];
    //把原数组中的元素复制到新数组中
    for(int i = 0; i<elements.length; i++) {
      newArr[i] = elements[i];
    }
    //把添加到元素放入新数组中
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr;
  }
  //取出栈顶元素
  public int pop() {
    //取出数组的最后一个元素
    int element = elements[elements.length-1];
    //创建一个新的数组
    int[] newArr = new int[elements.length-1];
    //原数组中除了最后一个元素的其他元素都放入新的数组中
    for(int i = 0; i<elements.length-1;i++) {
      newArr[i] = elements[i];
    }
    //替换数组
    elements = newArr;
    //返回栈顶元素
    return elements;
  }
  //查看栈顶元素
  public int peek() {
    return elements[elements.length-1];
  }
  //判断栈是否为空
  public boolean isEmpty() {
    return elements.length == 0;
  }
}
```



#### 3.3 队列

队列也是一种操作受限的线性表。队列是限制在表的一端进行插入，而在表的另一端进行删除的线性表，通常称允许插入的一段称为队尾，允许进行删除的一端为队头。当表中没有元素时称为空队列。  

```java
public class MyQueue {
  
  int[] elements;
  
  public MyQueue() {
    elements  = new int[0];
  }
  //入队
  public void add(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length + 1];
    //把原数组中的元素复制到新数组中
    for(int i = 0; i<elements.length; i++) {
      newArr[i] = elements[i];
    }
    //把添加到元素放入新数组中
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr;
  }
  //出队
  public int poll() {
    //把数组中的第0个元素取出来
    int element = elements[0];
    //创建一个新的数组
    int[] newArr = new int[elements.length-1];
    //复制原数组中的元素到新数组中
    for(int i = 0; i<newArr.length;i++) {
      newArr[i] = elements[i+1];
    }
    //替换数组
    elements = newArr;
    return element;
  }
  public boolean isEmpty() {
    return elements.length == 0;
  }
}
```



#### 3.4散列表



#### 3.5 树和二叉树

### <4> 查找与排序

#### 4.1 查找

### <5> 链表

#### 5.1 基于节点的数据结构-链表

在之前数组存储过程中，我们知道**数组的存储必须使用连续的内存空间，并且会预留一部分空间方便扩展**。如果在电影院座位也这样政策，会出现什么情况？

![img](https://style.youkeda.com/img/course/a2/6/1-1.svg)

如上图所示，所有人都希望自己和朋友坐一起，并且为之后可能到来的朋友预留位置。大家可以发现，这样的做法会大大降低影院的入座率。

在内存中的话，同样会**大大降低内存的使用率**，这种事情肯定是不会被科学家所接受的。所以出现一种新的数据结构，叫做 --- **链表**。

##### 链表

从上面我们知道，链表的发明是对数组的一种补充。因此它的功能和数组非常类似，都是用于**存储一系列相同类型的数组**，并且都有**增删改查**等基本操作。

用一句话来总结

> 数组能做的所有事情，一般都可以用链表实现。

只是他们的存储方式不同，导致他们的实现逻辑也不同，同样时间复杂度也将不同。下面我们就具体分析一下链表的特性。

##### 节点

数组里面每个元素我们称之为**元素**，而链表中每个元素我们称之为**节点**。为什么呢？他们有什么区别？

我们举个例子看看节点的特性，如下图：

![img](https://style.youkeda.com/img/course/a2/6/2-1.svg)

从图中看出，每个节点都是由两部分组成 --- **节点内容和下一个节点地址**。元素和节点的差别就在这个**下一个节点地址**。

**为什么每个节点都需要存储下一个节点地址呢？**

> 在数组中，由于是连续内存空间存储，我们可以通过`start_address + item_size * i`计算出元素的位置。 而在链表中，存储空间是**分散存储**的，所以我们需要每个节点保存下一个节点的位置。 也就是可以通过节点 1 找到节点 2，节点 2 找到节点 3......依次遍历所有的节点信息。

从这个结构，可以看出链表对于数组最大的好处，**它可以将数据分散存储在内存中，达到内存最大利用率**。

#### 5.2 链表的读取与查找

##### 链表中索引内容读取

通过之前的介绍，我们对链表这种数据结构有了一定的认识，那**链表中根据索引读取内容应该如何操作呢**？

我们回顾下在数组中的如何进行数据的读取：

> 因为数组是连续内存空间存储的，我们通过 `start_address + item_size * i` 便能计算出索引地址，然后 1 步便完成内容的读取，时间复杂度是`O(1)`。

那链表中应该如何操作呢？比如我们要找到`9, 2, 4`链表中索引为`2`的存储内容？

当然计算机无法一步完成这个操作，因为链表在内存中是**分散**存储的，我们现在只有**第一个节点的地址**，因此需要依次遍历找到第 **3** 个节点的地址。

![img](https://style.youkeda.com/img/course/a2/6/2-2.svg)

逻辑比较简单，我就不展开讲解了。

**时间复杂度**

从上面图中我们看到，链表中的读取时间复杂度和索引值有关。最好的情况是读取第一个节点，只需要 **1 步**。最坏的情况是读取最后一个节点，需要 **N 步**。 因此链表的读取时间复杂度为`O(N)`，相比较数组性能会差一点。

##### 链表中遍历查找元素

我们再来看看如果想在链表中查找某个元素，时间复杂度是多少呢？

我们继续用`9, 2, 4`作为例子，如果我们想要在这个链表中，查找是否包含某个节点它的内容是`4`，那该如何操作呢？

> 我们同样需要利用第一个节点，依次往后面遍历，每次遍历到一个节点，比较这个节点内容是否为 4。

![img](https://style.youkeda.com/img/course/a2/6/2-3.svg)逻辑很简单，所需步数和读取索引值一样，最好的情况在第一个节点就查找到，只需要 **1 步**。最差的情况在最后一个节点才查到，需要 **N 步**。

所以时间复杂度为`O(N)`，查找元素的时间复杂度和数组是一样的。

#### 5.3 链表的插入

本节课我们来聊聊链表的插入，我们仍然以之前数组的案例为例子。

假设我们在为周末的事情做规划，现在暂定规划如下

```java
eat breakfast  // 吃早饭
shopping       // 购物
have lunch     // 吃午饭
have dinner    // 吃晚饭
```

如果用链表结构表示如下：

![img](https://style.youkeda.com/img/course/a2/6/3-1.svg)

##### 头部插入

现在突然想在**吃早饭**之前，加入一项**取快递（take express）**，那我们应该怎么插入呢？

![img](https://style.youkeda.com/img/course/a2/6/3-2.svg)

如上图所示，分为 2 部分执行

> 1. 新节点的 **next** 指向原来的 **root** 节点
> 2. **root** 指针指向新节点

时间复杂度很容易计算出来为`O(1)`。

##### 中间插入

如果我们想改在**购物**之后**取快递**，应该怎么处理呢？

![img](https://style.youkeda.com/img/course/a2/6/3-3.svg)

如上图所示，分为 2 部分执行

> 1. 新节点 **next** 指向原来前置节点的 **next**。
> 2. 原来前置节点的 **next**，指向新节点。

看起来好像也只需要`O(1)`就能完成插入，但是这样的插入有一个前置条件，也就是我们知道插入节点的**前置节点**。 否则，我们只能根据索引通过 **N 步**找到前置节点。

##### 尾部插入

如果我们想改在**吃晚饭**之后**看电影**，应该怎么处理呢？

![img](https://style.youkeda.com/img/course/a2/6/3-4.svg)

如上图所示，和中间插入的逻辑完全一样。只是中间插入的时候**前置节点的 next 是一个节点，而此处为 null**：

> 1. 新节点 **next** 指向原来前置节点的 **next**（此处为 null）。
> 2. 原来前置节点的 **next**，指向新节点。

同样，我们首先需要执行 **N 步**找到最后节点，再进行上面的插入操作。

##### 总结

通过上面的对比，我们可以总结如下

> 如果已经知道插入节点的**前置节点**，那么链表的插入时间复杂度为`O(1)` 普通情况（根据索引值插入节点），插入的时间复杂度为`O(N)`这个和数组是一样的。 但有趣的是，链表插入的**最好和最差的情况刚好和数组相反**，链表在头部插入和方便，但是数组开头插入确很麻烦。而数组在尾部插入很方便，但链表尾部插入要先扫描再插入。

#### 5.4 链表的删除

一旦大家掌握了链表的插入，剩下的链表的删除就简单多了。 同样，我们还是以周末规划作为我们的案例，再次看下这个链表结构。

```java
eat breakfast  // 吃早饭
shopping       // 购物
have lunch     // 吃午饭
have dinner    // 吃晚饭
```

如果用链表结构表示如下：

![img](https://style.youkeda.com/img/course/a2/6/3-1.svg)

我们还是分为链表头，中，尾部 3 个位置的删除为例。

##### 头部删除

周末我突然想多睡睡懒觉，我们想去除**吃早饭**，应该怎么操作呢？

![img](https://style.youkeda.com/img/course/a2/6/3-5.svg)

如上图所示，分为 2 部分执行

> 1. **root** 指针指向第二个节点
> 2. 原始 **root** 节点的 **next** 设置为 **Null**

时间复杂度很容易计算出来为`O(1)`。

##### 中间删除

我们想去掉**购物**安排，吃了早饭以后，休息一会就吃午饭。应该怎么操作呢？

![img](https://style.youkeda.com/img/course/a2/6/3-6.svg)

如上图所示，分为 2 部分执行

> 1. 待删除节点**前置**节点 **next** 指向待删除节点**后置**节点。
> 2. 待删除节点的 **next**，指向 **Null**。

看起来好像也只需要`O(1)`就能完成删除，但是这样的删除有一个前置条件，也就是我们知道插入节点的**前置节点**。 否则，我们只能根据索引通过 **N 步**找到前置节点。

##### 尾部删除

如果我们想去掉最后一项安排**吃晚饭**，应该怎么处理呢？

![img](https://style.youkeda.com/img/course/a2/6/3-7.svg)

如上图所示，和中间删除的逻辑完全一样。只是中间删除的时候**前置节点的 next 改为待删除节点的后置节点，而此处后置节点为 null**。

待删除节点原本的 **next** 为 **null**，所以不需要再赋值为空。 但是，我们仍然必须需要执行 **N 步**找到倒数第二个节点，再执行上面的删除操作。

##### 总结

其实删除操作，只是插入操作的反操作，原理还是比较容易理解，我们总结下链表删除的时间复杂度。

> 如果已经知道待删除节点的**前置节点**，那么链表的删除时间复杂度为`O(1)` 普通情况（根据索引值删除节点），因为需要新找到**前置节点**，所以的时间复杂度为`O(N)`

#### 5.5 链表vs数组

我们已经熟悉了**数组**和**链表**，很多同学问题就来了：

**那到底数据和链表性能上有什么区别？**

![img](https://style.youkeda.com/img/course/a2/6/5-1.svg)

我们放在一个表格里面看看

|              | 数组             | 链表               |
| ------------ | ---------------- | ------------------ |
| 存储         | **连续**内存存储 | **分散**a 内存存储 |
| 读取         | O(1)             | O(N)               |
| 插入         | O(N)             | O(N)               |
| 插入最好情况 | 数组末尾插入     | 链表开头插入       |
| 插入最坏情况 | 数组开头插入     | 链表末尾插入       |
| 删除         | O(N)             | O(N)               |
| 删除最好情况 | 数组末尾删除     | 链表开头删除       |
| 删除最坏情况 | 数组开头删除     | 链表末尾删除       |

看到这个表格，同学们肯定又有疑问了：

**链表除了在存储方面有优势，好像其他都不如数组啊？**

但是我要告诉大家，复杂场景下，表现并不是这样的，为什么，我们继续学习。

##### 复杂场景

在之前的例子中，我们仅仅是在简单操作的情况下。大家试想一个复杂一点点场景

> 我们手里有一堆手机号码，我们希望写一个算法删除无效的手机号码。 具体逻辑为：我们每次读取一个手机号码，判断这个手机号码是否是 **11** 位，并且满足一定的**正则表达式**要求。

那在这种场景下，我们应该用什么数据结构来存储这一堆手机号码呢？

我们想一想在这个场景下最关键的两个因素**遍历**和**删除**。

**遍历**

无论你使用数组或者链表进行存储，都需要经历 **N** 次遍历。这部分的开销无法减少。

**删除**

再试想一下删除的逻辑。

如果使用**数组**的话，每次删除我们都需要移动后面的所有元素，所以每次删除的时间复杂度都为`O(N)`。

而如果使用**链表**的话，就不存在这个问题。为什么？ 因为在遍历场景下，我们都可以拿到需要删除节点的前置节点。所以在这个场景下的每次删除时间复杂度是`O(1)`。

##### 总结

简单统计下，在这种场景下使用数组的操作的时间复杂度为`O(N^2)`。而使用链表的时间复杂度为`O(N)`。

从这个例子看出链表在**频繁插入和删除**情况下，有绝对的优势！在后面的课程我们我们还会发现更多链表的好处。

#### 5.6 链表经典算法题-多指针使用

**链表**是初级算法最喜欢涉及数据结构。基于**链表**的算法更是层出不穷，我们今天来讲一个经典场景 --- **多指针在链表算法中的应用**。

我们来看一道**剑指 offer**最经典的题目：

> 如何查找**单向链表**中倒数第 k 个节点。

解释下上面出现的新词语，**单向链表**：我们本节之前所讲的链表都是单向链表，双向链表我们将在下一节提到。

那这道题该如何解决呢？

我们来看一个实际的例子，假设我们链表中存储的内容如：`9, 2, 4, 5, 6, 8, 0, 3, 10`

![img](https://style.youkeda.com/img/course/a2/6/6-0.svg)

如图所示，当 `k` 的值是 3 和 6 的时候，题目结果为 `0` 和 `5`。

**单向链表**导致节点只知道自己后面的节点，那该如何取倒数第 k 个节点呢？

##### 暴力法

暴力法，大家肯定能想到的，我们可以通过两次循环获取到倒数第 k 个节点。

> 1. 第一次循环，获取到链表中所有节点的个数，假设为`n`。
> 2. 第二次循环，我们只需要推进 `n - k` 次即可。

代码如下

```java
// 找寻倒数第 k 个节点内容
public static int findK(Node node, int k) {
    // 第一步，计算链表的长度
    int size = 0;
    Node p = node;
    while (p != null) {
        p = p.getNext();
        size++;
    }

    // 第二步，推进 size - k 步
    Node c = node;
    int index = size - k;
    while (index > 0) {
        c = c.getNext();
        index--;
    }
    return c.getContent();
}
```

如果面试的时候，你只能提出这个**方法**肯定是不够的，在上面我们使用了两次遍历，那有什么办法**一次遍历**就完成目标呢？

##### 双指针法

我们可以使用**两个指针**完成这个任务，我们来看看具体的思路：

**第一步**

我们声明一个指针**先驱指针**，顾名思义目的是为了探索链表的边界。

![img](https://style.youkeda.com/img/course/a2/6/6-1.svg)

> 第一步，我们将**先驱指针**移动 k - 1 位。移动后我们开始声明一个新的指针**实际指针**，这个指针用来寻找倒数第 k 个节点。

**第二步**

同时移动两个指针

![img](https://style.youkeda.com/img/course/a2/6/6-2.svg)

> 如图所示，我们同时移动**先驱指针和实际指针**。

**第三步**

确定结束条件：当**先驱指针**执行到链表结尾位置，这时候**实际指针**刚好指向倒数第 k 个位置。

![img](https://style.youkeda.com/img/course/a2/6/6-3.svg)

第一次接触双指针法，是不是发现很惊艳，后面我们的几个作业都需要利用这个思想，大家要灵活应用喔。

#### 5.7 双向链表

我们回顾一下上一节中的两道题

**第一题**

> 如何查找**单向链表**中倒数第 k 个节点？

当时大家肯定在想，如果**每个节点**都指向它的**前置节点**，那么这道题目就比较容易了。我们可以从链表尾部依次往前移动，找到第 k 个节点即可。

**第二题**

> 如何查找**单向链表**中心节点？

大家试想一下，同样如果**每个节点**都指向它的**前置节点**，那么这道题目该怎么解决？

> 我们利用**前后**两个指针，依次**往中心推进**，当两个指针**相遇或者相错**的那一刻，便可以找到中心节点。

类似这种题目，稍微改变一下我们链表节点结构，就能很容易求解！而刚才所说的这种结构链表，我们叫做**双向链表**，如下图所示

![img](https://style.youkeda.com/img/course/a2/6/7-1.svg)

我们来看看这种新的链表的特点。

> 1. 对于每个节点，由三部分组成，`prev`（指向前一个节点），`next`（指向后一个节点），`content`（节点内容）。
> 2. 对于**双向链表**，为了方便遍历，我们需要同时保留**第一个**节点和**最后一个**节点。

##### LinkedList

在之前我们自己实现过`YKDLinkedList`，如果大家以后仔细阅读`LinkedList.java`的源码，我们会发现`LinkedList`实际上就是利用**双向链表**实现的，在源码中我们可以找到如下代码：

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
    transient int size = 0;

    /**
     * Pointer to first node.
     * Invariant: (first == null && last == null) ||
     *            (first.prev == null && first.item != null)
     */
    transient Node<E> first;

    /**
     * Pointer to last node.
     * Invariant: (first == null && last == null) ||
     *            (last.next == null && last.item != null)
     */
    transient Node<E> last;

    /**
     * Constructs an empty list.
     */
    public LinkedList() {
    }

    ......
}
```

大家特别需要关注这里的两个变量`first`和`last`。分别表示双向链表的头部和尾部两个节点。

本节课大家只需要了解下**双向链表**这种链表的变种，我们后面的章节会涉及到它具体的应用场景。

### <6> 栈

#### 6.1 浏览器如何实现前进后退

在学习本节课之前，我先给大家提个问题：

> 浏览器是如何实现前进后退的？

我们来看一个例子，我们打开**网页云音乐主页**，点击跳转**推荐歌单页**，在点击跳转到**单曲详情页**。

![img](https://style.youkeda.com/img/course/a2/7/1-1.svg)

如果我们用`A, B, C`来表示这个三个页面，跳转的逻辑是`A -> B -> C`。 这时候我们可以通过后退按钮，从`C`页面回退到`B`页面，再次回退可以到`A`页面。 如果这时候我们点击进入**歌手页面**`D`，那么再也无法通过**前进和后退按钮**进入`B, C`中了。

现在我们考虑，如何实现上面描述的浏览器前进和后退的功能呢？这就是我们本章的主题 --- **栈（Stack）**。

![img](https://style.youkeda.com/img/course/a2/7/1-2.svg)

##### 如何理解栈

对于**栈**，还有一个更贴近生活的案例，我们每位同学家里都有很多盘子。我们每次洗好的盘子总是堆叠在一起，如图所示， `A, B, C`三个盘子。

![img](https://style.youkeda.com/img/course/a2/7/1-5.svg)

我们在洗碗的时候，先洗好的放在下面，后洗好的放在上面。

![img](https://style.youkeda.com/img/course/a2/7/1-3.svg)

反过来每次使用盘子的时候，总是先拿上面的盘子，后拿下面的盘子。

![img](https://style.youkeda.com/img/course/a2/7/1-4.svg)

如果用专业术语表示，则为**后进者先出，先进者后出**，这就是**栈**的特性。

#### 6.2 栈的实现

在上一节中，我们了解栈的特征，栈的使用场景非常广泛，所以在编程各类语言中都有栈的实现，例如在 Java 中，**栈**的数据结构类是`Stack`。

从栈的特性我们知道，它的本质是用于存储**一批相同类型的数据**，因此它的底层实现无非两种选择 **数组** 和 **链表**。 是不是又回到了我们擅长的领域了？

![img](https://style.youkeda.com/img/course/a2/7/2-1.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

##### 核心方法

本节课我们将教会大家如何用**数组**自己实现一个栈 --- `YKDStack`。 首先我们需要理解栈中三个核心方法：`push`，`pop`，`peek`。

![img](https://style.youkeda.com/img/course/a2/7/2-2.svg)

> **push**: 往栈顶添加元素 **pop**: 从栈顶移除元素 **peek**: 获取栈顶元素，并不做任何添加删除操作。

大家可以看到，栈的所有操作都是基于**栈顶**进行的，这是它的特色。

如果用`Java`中的`数组`怎么来实现呢？

##### 栈的初始化

我们优先考虑栈的初始化，为了先简单实现栈的功能，我们**此处只考虑存储字符串**，并且**暂不考虑栈的扩容问题**。

```java
package com.youkeda;

public class YKDStack {
    String[] data;
    int size;

    // #1. 初始化栈，默认大小为20
    public YKDStack(){
        this.initData(20);
    }

    // #2. 初始化栈，并传入栈空间大小
    public YKDStack(int size){
        this.initData(size);
    }

    // 初始化数组
    private void initData(int size){
        this.size = size;
        this.data = new String[this.size];
    }
}
```

代码比较简单，需要特别注意`#1`, `#2`此处，我们支持创建一个默认空间为`20`的栈，同时也支持自定义空间的栈。

##### 栈的 push 方法

紧接着我们实现`push`的方法，在实现之前，我们需要添加一个`top`变量记录栈顶在数组中的位置。

```
当栈为空的时候，top 为 -1。
当只有 1 个元素时，top 为 0。
当有 10 个元素时，top 为 9。
```

`push`的核心逻辑有 3 点

> 1. 优先判断是否数组越界
> 2. 更改变量`top`的值
> 3. 往数组中添加一个元素

代码如下:

```java
// 添加元素
public boolean push(String value) {
    // 数组越界了
    if (this.top >= this.size - 1) {
        return false;
    }

    // top 栈顶 +1
    this.top++;
    // 设置栈顶元素
    this.data[this.top] = value;
    return true;
}
```

总的来说，栈的代码实现都没有难度，剩下两个函数交给大家实现喔。

#### 6.3 栈常见的算法题目

通过前两章的学习，我们已经看透**栈**了。我相信大家对栈的实现原理和特性已经了如指掌。

本节课我们将学习栈的**实际场景**？并且理解在具体场景下是**如何使用**的？

我们首先回顾下之前的括号匹配的题目

> 在运行`java`代码的时候，运行工具会先帮我们进行语法校验，在语法校验中很重要的一步是 --- **判断括号是否匹配**。

什么意思？

> 简单来说，**有左括号就应该有右括号，有开即有合**。

当时我们用一个整数来存储括号匹配情况，这个整数初始化为 0，遇到左括号则+1，遇到右括号则-1，最后程序运行结束后，查看整数是否为 0。

![img](https://style.youkeda.com/img/course/a2/7/3-1.svg)

但是这种算法本身是**有漏洞**的，有一种错误情况它是无法识别的，比如`{((}))`（当时为了简化，让大家忽略这种语义化问题）。

上面这种问题出现的核心问题在于:

> 我们仅仅用数字来存储括号匹配情况，**并没有考虑括号的顺序问题**。

例如 `{((` 这种前置场景下，紧接着括号应该 `)` 而不是 `}` 。

这种**嵌套型**的关系，用栈可以很好的解决，下面我们来看看用栈实现括号匹配的思路。

##### 栈完善括号匹配情况

我们首先来看看核心思路

> 当遇到左括号`(`、`{`、`[`，则压入栈中 当遇到右括号`)`、`}`、`]`，将**此右括号和栈顶括号进行匹配**。如果配套，则将栈顶元素弹出，否则括号不匹配。

**什么叫做配套**？

> `()`、`{}`、`[]` 属于配套的括号，其他组合就属于不配套。

我们来看两个例子

**第一个例子**

查看字符串`()({()})`括号匹配情况，示意图如下：

![img](https://style.youkeda.com/img/course/a2/7/3-2.svg)

具体步骤如下

```
1. 扫描到`(`，左括号压入栈中
2. 扫描到`)`，右括号与栈顶`(`匹配，执行`pop`操作
3. 扫描到`(`，左括号压入栈中
4. 扫描到`{`，左括号压入栈中
5. 扫描到`(`，左括号压入栈中
6. 扫描到`)`，右括号与栈顶`(`匹配，执行`pop`操作
7. 扫描到`}`，右括号与栈顶`{`匹配，执行`pop`操作
8. 扫描到`)`，右括号与栈顶`(`匹配，执行`pop`操作
```

我们继续来验证一下`{((}))`这种错误的匹配案例。

**第二个例子**

查看字符串`{((}))`括号匹配情况，示意图如下：

![img](https://style.youkeda.com/img/course/a2/7/3-2.svg)

```
1. 扫描到`{`，左括号压入栈中
2. 扫描到`(`，左括号压入栈中
3. 扫描到`(`，左括号压入栈中
4. 扫描到`}`，右括号与栈顶`(`匹配，匹配失败，停止操作
```

注意上面的术语

> **压入栈中**：指的是`Stack`中的`push`操作 **弹出**：指的是`Stack`中的`pop`操作 **获取栈顶元素**：指的是`Stack`中的`peek`操作

#### 6.4 栈 - 简单寻路算法（一）

大家从小到大，陆陆续续肯定玩过非常多的游戏。在游戏中有一个非常重要方便的功能 --- **自动寻路**。

![img](https://style.youkeda.com/img/course/a2/7/4-0.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

当时是不是感觉很**高科技**？

但我告诉大家，学习完本章节，自己也能实现**简单的自动寻路**算法。

##### 自动寻路

在实际游戏场景中，地图是非常复杂的，但是无论什么地图，自动寻路都可以简化为 3 要素：**可移动区域**，**不可移动区域（障碍物）**，**起点和终点**。

紧接着如果我把地图划分为多个方格，每个方格表示移动的最小单位，我们便能将整个地图投影成如下二维视觉：

![img](https://style.youkeda.com/img/course/a2/7/4-1.svg)

> 深灰色的区块为障碍物 白色区块表示可行动的区域 图中分别标注了起点和终点

假设，现在每一步都只能**从一个方格移动到其相邻的方格**，并且只能**上下左右**移动，那么如何找寻现一条从起点移动到终点路径呢？

最终用代码跑出的数据为：

![img](https://style.youkeda.com/img/course/a2/7/4-4.svg)

从图中的`*`，可以看出一条起点到终点的路径，注意此处我们仅仅探讨自动寻路，并没有探讨**最短**路径，在之后的高阶课程我们再讨论如何选择**最短路径**。

##### 自动寻路思路

我们试想一下，遇到这个问题，应该如何进行思考？主要分为如下 2 个问题？

**1. 如何存储整个地图信息，包括障碍物，可移动区域？** **2. 如何存储寻找自动寻路路径？**

##### 地图信息

第一个信息比较简单，对于这样的二维地图，我们可以用二维数组进行存储，同时因为每个方格都有不同的状态，为了方便显示，我们可以利用字符存储每个方格信息。

![img](https://style.youkeda.com/img/course/a2/7/4-2.svg)

最终结果如上图所示，并且用`#`表示**障碍物**，一个空格表示**可移动区域**。

代码如下：

```java
char[][] map = {
      {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
      {'#', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'},
      {'#', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'},
      {'#', ' ', ' ', ' ', ' ', '#', '#', ' ', ' ', '#'},
      {'#', ' ', '#', '#', '#', ' ', ' ', ' ', ' ', '#'},
      {'#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', '#'},
      {'#', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', '#'},
      {'#', ' ', '#', '#', '#', ' ', '#', '#', ' ', '#'},
      {'#', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
      {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'}
    };
```

在这种情况下，如果我们想获取第 3 行，第 4 列的方格信息, 代码如下：

```java
int row = 2;
int column = 3;

// 第 3 行，第 4 列信息
char content = map[row][column]
```

我们可以将整个游戏用`Game`来表示，那么`Game`这个类肯定有一个`map`的属性。

紧接着，那应该如何表示起始和结束点位置呢？

> 从上面的代码我们知道每个方格有两个属性：`row`和`column`，用来表示每个方格的位置，因此我们可以新建`Point`类用于存储位置信息。

整合上面的思路， 整个`Game`的代码如下：

```java
public class Game {

    private char[][] map;

    public Game(char[][] map) {
        this.map = map;
    }

    // 寻找路径
    public ArrayList<Point> findPath(Point start, Point end) {
        ArrayList<Point> path = new ArrayList<>();
        return path;
    }
}
```

`Point`的代码如下：

```java
public class Point {

    private int row = 0;

    private int column = 0;

    .....
}
```

注意其中的`findPath`方法，返回的是一条从起点到终点的路径。

在这个地图的基础上，我们再来考虑如何寻找路径。

#### 6.5 栈 - 简单寻路算法（二）

##### 寻找路径

上节课我们学习了如何用代码表示地图信息，这节课继续解决最复杂的问题 --- **寻找路径**。

对于这种复杂场景，我们需要将其从思想上**简化**。当前这个问题，我们该如何简化呢？

我们可以假设这是一个真正的迷宫场景，现在我们自己站在某一个方格上（并且不是上帝视角的情况下），我们应该怎么尝试找到出口呢?

![img](https://style.youkeda.com/img/course/a2/7/migong.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

从题目基本信息得知，当我们站在某一个方格上都有 **4 个方向**可以进行探索：**上下左右**。我们可以考虑一个思路：

> 1. 当站在某个方格上时候，初始我们都选中一个方向，比如**右**进行探索。
> 2. 如果右侧元素不是障碍物，则我们移动到**右侧方格**上，继续进行**1**步骤。
> 3. 如果右侧元素为**障碍物或者已经遍历过的方格**，则按**下、左、上**方向进行探索。
> 4. 如果 4 个方向都不能进一步探索，那没办法了，我们只能**回退**上一个方格，从新选择方向。

有些同学可能会有问题，为什么我们选择**右->下->左->上**方向进行探索呢，为什么不是其他方向？

> 因为我们知道**目标终点在起点的右下角**，所有我们用这个方向，可以避免很多额外的步骤。

紧接着，第一个问题：**用什么数字化语言去描述方向呢，我们总不能用字符串描述方向吧？**

> 在这种场景下，我们可以用**数学向量**去描述方向，如下图所示：

![img](https://style.youkeda.com/img/course/a2/7/4-3.svg)

如果我们将向量的第一位当做`row`上的增量, 第二位当做`column`上的增量，那么右下左上分别表示为：

> 右侧：row 不变，column 加 1，所以向量表示为：`{0, 1}` 下侧：row 加 1，column 不变，所以向量表示为：`{1, 0}` 左侧：row 不变，column 减 1，所以向量表示为：`{0, -1}` 上侧：row 减 1，column 不变，所以向量表示为：`{-1, 0}`

因此我们在`Game`中添加如下代码，按顺序存储 **右下左上** 四个方向，代码如下

```java
// 存储4个方向
private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
```

第二个问题：**怎么存储探索的路径呢？还要非常方便我们回退？**

> 大家试想一下这个场景和栈的模式非常像，最开始的起点在栈底，每探索一个方格，则往栈里`push`一个元素，如果遇到一条死路，则`pop`回退到上一个元素并且换个方向继续探索。

第三个问题：**怎么标记方格是否访问过？方格是否是死路？**

> 为了区分`#`和空格，我们可以用`*`表示方格已经被访问过，用`@`表示方格为死路。

因此我们新建一个`Tile`对象，表示在栈中的信息，包括方格位置和遍历的方向，代码如下：

```java
public class Tile {
  // 方格位置
  private Point point;
  // 方格当前遍历的方向
  private int direction = 0;
}
```

继续在`Game`中添加变量`steps`，利用栈存储探索路径中的方格，代码如下：

```java
public class Game {

  private char[][] map;
  // 存储探索的路径节点
  private YKDStack<Tile> steps = new YKDStack<>();
  // 存储4个方向
  private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

  public Game(char[][] map) {
    this.map = map;
  }
  ......
}
```

现在完整代码，可以查看右侧工程。

接下来我们来看看整个实战过程。

##### 实战过程

**第 1 步**

我们站在起点，将起点位置`{1, 1}`加入到`steps`栈中，并将该元素的方向设置为-1，也就是表示**还未探索过**。

![img](https://style.youkeda.com/img/course/a2/7/4-5.svg)

**第 2 步**

1. 获取栈顶元素，也就是`{1, 1}`方格，将方格的方向加 1 当做探索方向，也就是右侧(`-1 + 1 = 0`, 在**右下左上**中，索引为 0 的是右侧)。
2. 探索方格右侧方格`{1, 2}`，并将其加入到`steps`栈中，方向设置为-1。

![img](https://style.youkeda.com/img/course/a2/7/4-6.svg)

**第 3 步**

1. 获取栈顶元素，也就是`{1, 2}`方格，将方格的方向加 1 当做探索方向，同样也是右侧。
2. 因为右侧遇到`#`，无法作为路径，则继续将方向加 1，改为下侧（`0 + 1 = 1`, 在**右下左上**中，索引为 1 的是下侧）。
3. 探索方格下侧方格`{2, 2}`，并将其加入到`steps`栈中，方向设置为-1。

![img](https://style.youkeda.com/img/course/a2/7/4-7.svg)

**以此类推，可以达到如下情况**

![img](https://style.youkeda.com/img/course/a2/7/4-8.svg)

1. 这时候我们发现`{1, 4}`这个方格，上下左右都不能移动了，这是一条死路，因此我们将该方格设置为`@`，并将此方格从栈顶`pop`。
2. 继续观察此时的栈顶元素`{1, 5}`，同样也是死路，我们将其也设置为`@`，并执行`pop`操作。

直到如下场景：

![img](https://style.youkeda.com/img/course/a2/7/4-9.svg)

1. 获取栈顶元素`{3, 2}`，发现之前的方向是右侧`0`，首先加 1 探索下侧方向，无法通行。
2. 将方向继续加 1，探索左侧方向，因此将`{3, 1}`加入栈顶。

下面的步骤就不演示，以此内推，最终可以找到结束的节点，如下图所示：

![img](https://style.youkeda.com/img/course/a2/7/4-4.svg)

##### 路径回溯

这个时候，栈中存储的刚好是从起点到终点的方格路径，我们只需要依次`pop`栈顶元素，然后**倒叙**即可获取路径完整信息。

具体实现，我们看看下一章的代码！

#### 6.6 栈 - 简单寻路算法（三）

##### 代码实现

我们接下来用代码实现上一章的分析过程，主要完善`findPath`方法。

```java
// 寻找路径
public ArrayList<Point> findPath(Point start, Point end) {
    ArrayList<Point> path = new ArrayList<>();
    return path;
}
```

**第一步：将起点添加到栈中**

```java
// 寻找路径
public ArrayList<Point> findPath(Point start, Point end) {
    ArrayList<Point> path = new ArrayList<>();

    // 每次寻路之前将栈清空
    this.steps = new YKDStack<>();

    // 将起点添加到栈中，并将其标记为已访问
    this.steps.push(new Tile(start, -1));
    this.map[start.getRow()][start.getColumn()] = '*';
}
```

这一步比较简单，大家需要注意的是每次寻找路径之前，需要将**栈清空**。

**第二步：循环获取栈顶元素，修改方向准备进行探索**

```java
// 判断是否为同一个方格
private boolean isSame(Point point1, Point point2) {
    return point1.getRow() == point2.getRow() && point1.getColumn() == point2.getColumn();
}

// 寻找路径
public ArrayList<Point> findPath(Point start, Point end) {
    ArrayList<Point> path = new ArrayList<>();

    // 每次寻路之前将栈清空
    this.steps = new YKDStack<>();

    // 将起点添加到栈中，并将其标记为已访问
    this.steps.push(new Tile(start, -1));
    this.map[start.getRow()][start.getColumn()] = '*';

    // 循环到栈中元素为空结束，则表示从起点开始未能找到结束点
    while (this.steps.peek() != null) {

        // 获取栈顶元素
        Tile tile = this.steps.peek();
        Point tilePoint = tile.getPoint();

        // 判断是不是结束节点
        if (this.isSame(tilePoint, end)) {
          break;
        }

        // 修改栈顶元素的方向，准备进行探索
        tile.setDirection(tile.getDirection() + 1);
    }
    return path;
}
```

如上面代码，当栈为空的时候表示没有任何一条路径可以从起点到终点。 我们抽离了`isSame`方法判断两个方格是否相同。

**第三步：根据方向添加新探索节点到栈中，或者设置为死路并 pop 栈顶元素**

```java
// 判断是否为同一个方格
private boolean isSame(Point point1, Point point2) {
    return point1.getRow() == point2.getRow() && point1.getColumn() == point2.getColumn();
}

// 判断探索是否可以进行，如果是空格才可以进行
private boolean canStep(Point point) {
    return this.map[point.getRow()][point.getColumn()] == ' ';
}

// 寻找路径
public ArrayList<Point> findPath(Point start, Point end) {
    ArrayList<Point> path = new ArrayList<>();

    // 每次寻路之前将栈清空
    this.steps = new YKDStack<>();

    // 将起点添加到栈中，并将其标记为已访问
    this.steps.push(new Tile(start, -1));
    this.map[start.getRow()][start.getColumn()] = '*';

    // 循环到栈中元素为空结束，则表示从起点开始未能找到结束点
    while (this.steps.peek() != null) {

        // 获取栈顶元素
        Tile tile = this.steps.peek();
        Point tilePoint = tile.getPoint();

        // 判断是不是结束节点
        if (this.isSame(tilePoint, end)) {
          break;
        }

        // 修改栈顶元素的方向，准备进行探索
        tile.setDirection(tile.getDirection() + 1);

        // 当方向为 4 的时候，表示所有方向都已经遍历过了，所以标记为死路@，并弹出栈顶元素
        if (tile.getDirection() == 4) {
            this.map[tilePoint.getRow()][tilePoint.getColumn()] = '@';
            this.steps.pop();
        } else {
            // 否则探索目标方向的方格
            int[] direction = directions[tile.getDirection()];
            // 根据方向向量获取新方格的位置信息
            Point newPoint = new Point(tilePoint.getRow() + direction[0],
              tilePoint.getColumn() + direction[1]);

            // 如果可以通行，则将新探索的方格添加到栈中，并标记为已访问
            if (this.canStep(newPoint)) {
                Tile newTile = new Tile(newPoint, -1);
                this.map[newPoint.getRow()][newPoint.getColumn()] = '*';
                this.steps.push(newTile);
            }
            // 如果不可以通行，则不处理，再次获取栈顶元素，改变方向。
        }
    }

    return path;
}
```

这部分非常重要，大家需要仔细阅读这部分代码和注释，彻底理解方向探索的核心。

**第四步：回溯整个路径**

从上面代码可以看出，当`while`循环执行完成后，只有两种情况

> 第一种，栈为空，也就是**遍历完起点所能走到的所有方格**，里面都没有找到终点 第二种，找到终点，`break`跳出循环

我们需要特别关心第二种情况，大家试想一下这个时候栈中存储的方格是什么特征？

> 1. 栈中元素全是`*`元素，因为`@`将全部`pop`出栈。
> 2. `*`元素表示的是探索的路径，并且从起点开始，终点结束的。
> 3. 如果我们依次`pop`，这将是一条**终点到起点的路径**，我们需要倒排即可。

我们来看看最后的代码：

```java
// 寻找路径
public ArrayList<Point> findPath(Point start, Point end) {
    ArrayList<Point> path = new ArrayList<>();

    ......

    // 从栈中以此回退方格信息，也就是整个访问路径信息
    while (this.steps.peek() != null) {
        path.add(0, this.steps.pop().getPoint());
    }

    return path;
}
```

最终的结果为：

```java
1 - 1
1 - 2
2 - 2
3 - 2
3 - 1
4 - 1
5 - 1
5 - 2
5 - 3
6 - 3
6 - 4
6 - 5
7 - 5
8 - 5
8 - 6
8 - 7
8 - 8
```

这就是一条从起点到终点的路径，大家如果不相信可以视图对应每个方格到地图中，最后的路径将是如下样子：

![img](https://style.youkeda.com/img/course/a2/7/4-4.svg)

##### 总结

这道题是我们本课程到目前为止，最复杂的题目。但是跟着老师的一步步分析和实现，其实代码逻辑也不会特别复杂。

还是文中说过的一句老话，遇到复杂问题，莫慌，我们始终用简化问题的思想去分析问题，在这里的核心就是**假设现在我们自己站在某一个方格上，我们应该怎么尝试找到出口**。 做到这一点，剩下就迎刃而解了，这其实本质上也是一种**分而治之**的思想。



### <7> 队列

#### 7.1 如何实现一个排队系统?

在日常生活中，我们处处都看到排队。

比如是看电影，购物，还有一些一些公共出行，我们需要现场排队。

![img](https://style.youkeda.com/img/course/a2/8/1-2.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

在银行，医院这种场景还会加入排队系统，通过系统叫号的方式解决拥堵问题。在虚拟游戏世界中，为了服务器限流，也会加入一些排队策略。

![img](https://style.youkeda.com/img/course/a2/8/1-1.jpeg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

大家是否想过这样的排队列表得用什么样的数据结构来存储呢？

这就是本章要学习内容 --- **队列(queue)** 。

##### 队列

队列和栈一样，都是有**约束条件**，并且十分有趣的数据结构。不同约束条件，决定它们的不同的**使用场景**。

队列和排队非常类似，大家排成一排就像队列存储的元素。 以电影院举例，永远是**排在最前面的人最先离队进入影院，后来进入队列人排在最后**。

在计算机中，我们用**先进先出**来总结这个特征，或者缩写为`FIFO`(first in, first out)。 我们再来详细描述队列的约束条件

> 1. **只能在末尾插入元素**
> 2. **只能读取开头的元素**
> 3. **只能移除开头的元素**

##### 实践一下

假设一个电影院的排队场景，当前排队里面人员为 `Allen, Emma, James`，对应到队列中如下图：

![img](https://style.youkeda.com/img/course/a2/8/1-3.svg)

这时候新来一个人名称叫`Jeanne`，我们将`Jeanne`添加到队列末尾。

![img](https://style.youkeda.com/img/course/a2/8/1-4.svg)

队列第一位`Allen`准备进入电影院了，我们需要将其在队列里删除。

![img](https://style.youkeda.com/img/course/a2/8/1-5.svg)

最后队列中还剩 3 个人，分别为`Emma, James, Jeanne`。

![img](https://style.youkeda.com/img/course/a2/8/1-6.svg)

这就是遵循队列约定的最简单的场景。

#### 7.2 队列的数组实现

上一节，我们学习了队列的使用场景和约束，总的来说还是容易理解的。 本节课开始我们将学习如何用**数组**来实现一个队列。

首先，我们试想下数组实现队列的大致思路。

因为队列可以从**头部删除**和**尾部插入**元素，我们需要两个指针分别标记队列的**头部和尾部**，分别定义为`front`和`rear`。

> `front`指向的即将删除的头部元素 `rear`指向即将插入元素的位置

最开始的时候`front`和`rear`都指向`第一个空元素`，如下所示：

![img](https://style.youkeda.com/img/course/a2/8/1-7.svg)

当我们每添加一个元素时，让`rear`指针**向右移动一位**。 当我们每删除一个元素时，让`front`指针**向右移动一位**。

在添加`a, b, c, d, e`后，数组的存储如下图所示：

![img](https://style.youkeda.com/img/course/a2/8/1-8.svg)

我们继续进行添加和删除操作，在某一个时刻，数组可能出现如下情况：

![img](https://style.youkeda.com/img/course/a2/8/1-9.svg)

大家仔细看看这个数组存储分布，发现什么问题了么？

> 随着`front`的右移，导致数组的左侧空间全部**浪费**了。

那该如何解决这个空间浪费问题呢？

**第一个方案：数组调整**

> 当然最简单的办法是每一次删除以后，将右侧的元素依次左移。

大家注意，这是一个不靠谱的方案，这让我们每次删除操作的时间复杂度为`O(n)`。我们只听说过**时间换空间**，可没听说过**空间换时间**!

**第二个方案：循环数组**

> 在上面场景下，如果能把数组变成循环数组便可以解决了。 那什么是循环数组呢？循环数组指的是数组末尾元素下一个元素并不是越界，而是第一个元素。

用图表示如下：

![img](https://style.youkeda.com/img/course/a2/8/1-10.svg)

如果使用循环数据，可以完美的解决队列导致空间浪费问题。

##### 代码实现

在`Java`中，队列被称为`Queue`，数组实现的队列被称为`ArrayQueue`。本节课我们将自己实现一个`YKDArrayQueue`。

**第一步：对象** 首先我们加入基本对象和变量。

```java
public class YKDArrayQueue<T> {

    // 前后两个指针
    private int front;
    private int rear;

    // 底层存储数组
    private T[] queue;

    public YKDArrayQueue(int size) {
        this.front = 0;
        this.rear = 0;

        // #1. 特别注意此处的数组泛型的写法
        this.queue = (T[]) new Object[size];
    }
}
```

如上代码，`YKDArrayQueue`提供一个创建队列**指定大小**的构造函数。 需要注意上面`#1`，这就是一种创建泛型数组的方式，大家也不用纠结，就是一种语法，记住就行。

**第二步：队尾添加元素**

```java
// 队列尾部添加元素
public void add(T o){
    this.queue[this.rear] = o;
    // #2. 因此是循环队列，所以处理数组长度取余
    int newRear = (rear + 1) % this.queue.length;
    // #3. 指针相遇表示队列已满，暂不考虑扩容情况
    if(newRear == this.front){
        // #4. 如果加入元素以后指针碰撞，则抛出越界提示
        throw new IndexOutOfBoundsException("队列已满");
    }
    this.rear = newRear;
}
```

特别注意一下亮点：

1. `#2`部分，因为我们是循环列表，所以**用取余的方式获取指针位置**。
2. `#3`部分，我们使用头尾相碰作为队列已满的条件。
3. `#4`部分，此处我们利用 `Java` 异常机制，抛出队列已满异常

为了方便大家查看队列数据，我们加入一个`toString`方法将队列数据连接成字符串返回。

```java
public String toString() {
    StringBuffer sb = new StringBuffer();
    int i = this.front;
    while (i != this.rear) {
        sb.append(this.queue[i]);
        sb.append(" ");
        i++;
    }
    return sb.toString();
}
```

**第 3 步：如何获取队列的长度**

在上面我们已经往队列中加入元素了，那加入元素后，应该怎么获取队列的长度呢？ 同学们可能会回答，我们知道尾部索引，也知道头部索引，那么长度的计算公式如下：

```java
int size = this.rear - this.front;
```

大家再仔细想想，在**循环数组**的情况下，这种计算公式对么？ 肯定是不对的，因为循环数组，有可能会出现`rear < front`的。那应该怎么解决呢？如果小于的情况，我们可以加上数组的长度再进行相减。 完善一下代码，如下：

```java
// 获取队列的长度
public int size() {
  if (this.rear < this.front) {
      return this.rear + this.queue.length - this.front;
  }
  return this.rear - this.front;
}
```

#### 7.3 队列的链表实现

通过学习了**栈、队列**数组版本的实现方案，我们会发现对于这种类似的数据结构，用数组实现是一件非常繁琐的事情，主要因为两个原因：

1. 数组天生对**频繁的操作**很不友好，每次插入删除操作都需要调整数组。
2. 数组**连续空间存储**特性，导致用数组实现的数据结构都存在**越界**或者**扩容**问题。

而链表是**栈、队列**底层存储最好的选择，本节我们来学习下如何用链表实现队列。

##### 链表实现

我们来看看链表队列，需要哪些变量呢？

![img](https://style.youkeda.com/img/course/a2/8/3-1.svg)

如图所示

1. 为了方便在头部删除节点，我们需要一个`front`指针指向链表的第一个节点
2. 为了方便在尾部插入节点，我们需要一个`rear`指针指向链表的最后一个节点
3. 链表只能遍历统计节点个数，会有额外的时间开销，所以我们增加`size`存储节点个数

那接下来`add`, `remove`, `get`， `size`方法就比较容易了。

> add: 类似于在列表尾部如果加入第一个节点（在第 6 章我们已经讲过） remove: 类似于链表如何删除第一个节点（在第 6 章我们已经讲过） get: 遍历链表返回对应索引的值（在实现`YKDLinkedList`的时候完成过） size: 直接返回变量`size`即可

剩下的交给大家自己实现喔。

#### 7.4 队列常见的算法 --- 滑块窗口

本节课我们将学习如何将队列应用到实际的算法场景中。 在算法中，有一种经典算法叫做 --- **滑块窗口**，运用的其实便是队列的思想。

##### 滑块

我们先来看看什么叫滑块，在日常使用网站中经常会看到滑块的交互，比如：滑动解锁，滑动验证等等。

![img](https://style.youkeda.com/img/course/a2/8/4-1.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

那滑块和队列有什么关系呢？如果我们将**滑块当做队列，那么滑块的滑动区间也就表示队列所处理的所有数据**。 如下图所示：

![img](https://style.youkeda.com/img/course/a2/8/4-2.svg)

> 此时的队列中有 3 个元素，分别是`2, 4, 1`。 之前的元素`3`，已经从队列头部出列了。 之后还有`5, 7`等元素，即将进入队列。

当我们将滑块往右侧滑动的时候，可以理解为**队列一边在尾部添加元素，一边在头部删除元素**。

##### 获取长度最小的连续子数组

在`LeetCode`中，有一道非常经典的题目：

> 给定一个含有 `n` 个正整数的数组`nums`和一个正整数 `s` ，找出该数组中满足其和 `>= s` 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 `0`。
>
> 输入: s = 7, nums = {2, 3, 1, 1, 4, 3} 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。

##### 暴力法

这个题目应该怎么求解呢？首先我们来看看**暴力求解法**。

> 我们可以遍历所有的连续组合情况，然后依次判断其`和`是否满足`>=7`，并获取最小的数组个数。

思路比较简单，我们直接来看代码

```java
  // 查找最短子数组的长度
  public static int findMin(int[] nums, int s) {
    // 先定义最短长度为 nums.length + 1，因为肯定不会超过这个值
    int minLength = nums.length + 1;
    for (int i = 0; i < nums.length; i++) {
      int sum = 0;
      for (int j = i; j < nums.length ; j++) {
        sum += nums[j];
        // 获取调整 minLength
        if (sum >= s) {
          minLength = Math.min(minLength, j - i + 1);
          break;
        }
      }
    }
    return minLength;
  }
```

代码比较简单，核心思路是**遍历所有连续子数组的情况**。

结果为`2`，和上面答案一样。这种解法的时间复杂度很容易计算出来，为`O(N^2)`。

> 在面试算法的时候，就算我们不知道最优解是什么，但是至少我们要给出暴力解决问题的办法，这点很重要。一个解决方案都不提供是面试官最讨厌的。

##### 滑块窗口法

从前 7 章经验可以看出`O(N^2)`肯定不是最优解！那有什么时间复杂度更低的解决方案呢？这就要用到今天的重点**滑块窗口法**。

在使用滑块窗口法之前，我们先来看看上面的双重循环有哪些需要优化的地方？

**暴力法缺点**

我们以`i = 2`开始举例，遍历`i = 2`开始的最小连续数组，如下图所示：

![img](https://style.youkeda.com/img/course/a2/8/4-3.svg)

从图中可以看出直到遍历到`1, 1, 4, 3`才找到满足`>=7`的子数组，之后我们便默认这个数组是当前的最优解，开始执行`i = 3`的遍历。 但在这个时候`1, 1, 4, 3`是最优解么？肯定不是？那应该如何优化呢？我们可以如下图所示进一步寻找：

![img](https://style.youkeda.com/img/course/a2/8/4-4.svg)

我们推动滑块左边指针，推动到某一处，刚好**滑块区域数组和**`>=7`即可，这才是当前情况下长度最短的子数组。

**滑块窗口思想**：

这就是**滑块窗口**的核心思想：

> 利用左右**两个指针**形成滑块效果，先固定左侧指针，推动右侧指针寻求到当前的**解**，然后再推动左侧指针寻找解中的**最优解**。 滑块窗口的思想在连续子数组方面应用非常广泛。

我们试想下，时间复杂度是多少呢？无论左指针，还是右指针都只会将数组遍历一遍，所以时间复杂度为`O(N)`，很赞！！

##### 滑块窗口算法实现

明白了滑块解法的原理，我们来看看算法如何实现

**第 1 步：先思考下程序需要哪些变量？**

```Java
// 查找最短子数组的长度
public static int findMin(int[] nums, int s) {
    // 左右两个指针
    int front = 0;
    int rear = 0;

    // 当前最小长度，为数组长度 + 1
    int minLength = nums.length + 1;

    // 滑块内元素的和，用于判断解和最优解
    int sum = 0;
}
```

特别注意`sum`这个变量，用于存储当前滑块的内部数据的和。

**第 2 步：思考下程序运行的终止条件是什么？**

> `front` 和 `rear`都运行到数组结束为止。

我们继续添加代码如下

```java
// 查找最短子数组的长度
public static int findMin(int[] nums, int s) {
    // 左右两个指针
    int front = 0;
    int rear = 0;

    // 当前最小长度，为数组长度 + 1
    int minLength = nums.length + 1;

    // 滑块内元素的和，用于判断解和最优解
    int sum = 0;

    while (front < nums.length && rear < nums.length) {
    }
}
```

**第 3 步：我们优先推动右指针，找到解为止**

```java
// 查找最短子数组的长度
public static int findMin(int[] nums, int s) {
    ...

    while (front < nums.length && rear < nums.length) {
        // 推进右指针，寻找解
        while (rear < nums.length) {
            // 一直累加 sum, 直到刚好 >= s时停止
            sum += nums[rear];
            if (sum >= s) {
                break;
            }
            rear++;
        }
    }
}
```

注意**累加 sum，直到刚好 >= s 时跳出循环**。

**第 4 步：推动左指针找寻当前解中最优解**。

```java
// 查找最短子数组的长度
public static int findMin(int[] nums, int s) {
    ...

    while (front < nums.length && rear < nums.length) {
        // 推进右指针，寻找解
        while (rear < nums.length) {
            // 一直累加 sum, 直到刚好 >= s时停止
            sum += nums[rear];
            if (sum >= s) {
                break;
            }
            rear++;
        }
        // 尝试推进左指针，寻找当前最优解
        while (front < nums.length) {
            // 一直减少左侧元素， 直到刚好 < s时停止
            sum -= nums[front];
            if (sum < s) {
                // 此时找到当前最优解 rear - front + 1
                minLength = Math.min(minLength, rear - front + 1);
                // 两个指针同时向右推动，查找下一个解
                rear++;
                front++;
                break;
            }
            front++;
        }
    }
}
```

左指针的推进逻辑比较复杂，大家需要多读读上面的代码，特别是**代码注释**。 **如果还是不理解，则跟着代码的思路在本子上画一画每一步执行结果，这是理解复杂算法最有效的手段**。

**第 5 步：异常情况的处理**

比如如果`nums`为空的情况，上面代码将返回`1`，而不是`0`。因此我们在循环之前加强一下判断

```java
// 查找最短子数组的长度
public static int findMin(int[] nums, int s) {
    ...

    // 处理异常情况
    if(nums.length == 0){
        return 0;
    }

    while (front < nums.length && rear < nums.length) {
      ...
    }
}
```

**异常情况的处理也是面试官喜欢考察的点，这体现一位同学心思是否缜密，其实说白了这表示你写出来的程序`bug`多不多**？

运行结果和暴力法一样，但是效率提升是非常大的。

#### 7.5 Word如何判断单词拼写错误?

在学习之前，我们先来看在生活中我们经常遇到的一个小例子：**Work 单词拼写提醒**。如下图所以：

![img](https://style.youkeda.com/img/course/a2/9/1-1.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

当我们在`Office Word`中书写英文单词时，如果有单词拼写错误，`Word`工具便会如上图一样**自动给错误单词加上下划线**。

大家试想一下，这个逻辑是如何实现的呢？

![img](https://style.youkeda.com/img/course/a2/9/1-2.svg)

> 到现在为止，利用我们之前学习过的知识，至少可以利用**数组存储所有的单词**，然后每次遍历所有的单词，查看单词是否准确。
>
> 这种线性查找的时间复杂度为`O(N)`，这时候我们可以利用二分查找或者其他优化算法，将时间复杂度降低到`O(logN)`。

但是告诉大家，这些都不是最优方案。 所有的英文单词数量在`20W`左右，并且单词的判断是在键盘输入的同时进行处理的，所以我们希望单词拼写提醒的性能达到极致。

那还有什么办法呢？ 这就要用到本章节学习的重点 --- **散列表**，也可以被称为**哈希表**。

##### 散列表

学习过`Java`的同学已经接触过**散列表**了，比如我们用到的`Map`，`HashMap`，都是散列表。 散列表是由一对对的数据组成，一对数据里，一个叫做**键（Key）**，一个叫做**值（Value）**。

如果用散列表来存储 20W 个单词，那么形式如下：

![img](https://style.youkeda.com/img/course/a2/9/1-3.svg)

我们将单词当做`Key`，将值设置为`1`。 在查找单词的时候，如果根据单词`Key`获取到的值不是`1`，则表示单词拼写错误。

告诉大家散列表查询的时间复杂度是`O(1)`

#### 7.6 同义词字典

上节课，我们大概了解了散列表的特性，本节课我们将学习散列表是如何存储的？为什么能达到查询复杂度为`O(1)`?

请大家揣着这个问题跟随本小节的学习。

##### 同义词小词典

在高中每当我们写英文作文的时候，老师都会教育我们用高级词汇！！高级词汇！！

比如这句话`新闻在互联网中传播的很快`，应该怎么用英文翻译呢？

![img](https://style.youkeda.com/img/course/a2/9/2-1.svg)![img](https://style.youkeda.com/img/course/a2/9/2-2.jpeg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

我们都是**一脸懵逼**，**还能有`goes viral`这种用法**，这时候，我们多么希望有一个同义词典，来存储同义的高级词汇，如下：

```java
1. 贫穷的：poor = needy
2. 富裕的：rich = wealthy
3. 优秀的：excellent = eminent
4. 积极的，好的：good = conducive
5. 消极的，不良的：bad = evil
6. 明显的：obvious = apparent
```

我们暂时只考虑两个单词的同义问题。

如果用`散列表`来存储同义词应该怎么编码呢？假设我们的散列表为`synonyms`，那么代码如下：

```java
Map<String, String> synonyms = new HashMap<>();
synonyms.put("bad", "evil");
synonyms.put("goog", "conducive");
...
```

我们本节课就来探索下，这个散列表底层是如何存储的？

##### 散列表存储

散列表可以看做是一个**超级数组**，为什么？

> 因为如果知道数组的索引，那么数组的查询效率是非常高的。

那么现在的核心问题是怎么将散列表的`Key`转换为数组的索引，这样的转换函数，我们称为**散列函数（哈希函数）**。

![img](https://style.youkeda.com/img/course/a2/9/2-3.svg)

此处我们用乘法函数来当做散列函数，也就是将`Key`字符串的每个字符转换成一个数字进行乘法。

```java
'a' -> 1
'b' -> 2
'c' -> 3
...
'z' -> 26
```

利用这个乘法函数，我们可以计算出`bad`的结果为:

```java
bad = 2 * 1 * 4 = 8
```

所以在数组的索引`7`位置写入`evil`，如图所示：

![img](https://style.youkeda.com/img/course/a2/9/2-5.svg)

我们在来看一个 Key：`good`，如果用同样的散列函数计算的结果为:

```java
good = 7 * 15 * 15 * 4 = 6300
```

因为 6300 超过数组的长度，所以我们通过取模的方式获取位置

```java
6300 % 16 = 12
```

所以在数组的索引`11`位置写入`conducive`，如图所示：

![img](https://style.youkeda.com/img/course/a2/9/2-6.svg)

##### 散列表查询

通过上面的学习，我们将散列表的存储，映射到一个数组。 那么之后我们想获取`XXX`单词的同义词，首先利用散列函数将`XXX`转换成一个索引值，再通过数组索引查询，找到同义词即可。

#### 7.7 hash冲突

上一节我们学习散列表是如何进行存储的，我相信大家肯定有疑问

> 这样的散列函数，并不能保证 Key 计算出来的值的唯一性。

举个例子：`bad` 和 `dab`的计算结果肯定都是一样的。

如果之前已经存储了`bad`，那么继续下往这个格子里面放东西，就会引起冲突。

![img](https://style.youkeda.com/img/course/a2/9/2-7.svg)

如上图所示，这时候遇到冲突应该怎么解决呢？方法特别多，我们介绍两个常用方法即可。

##### 开放寻址法

所谓的开放寻址法，用大白话描述就是**如果当前位置冲突，则依次往后面寻找，直到找到一个可用的空间位置**。

![img](https://style.youkeda.com/img/course/a2/9/2-8.svg)

如上图所示，我们利用哈希函数，计算出`dab = 8`，继而发现索引`7`处已经有元素了，因此依次往后面推进，写入索引`8`处。

在查询的时候，应该做哪些改变呢？

> 我们优先需要计算哈希值，如果对应的位置找不到希望的元素，则依次右移直到找到为止。

这个方案的时间复杂度，我们只需要了解一下最坏的情况，假设所有元素计算出来的哈希值都在同一个位置，存储的时候需要依次后移寻找空闲位置。 也就是每次查询几乎都要遍历整个数组，时间复杂度为`O(N)`。

##### 链地址法

学习完链表之后，我们可以用一个单向链表存储所有哈希值相同的元素，原理非常简单，我们看看下面这种图就明白了。

![img](https://style.youkeda.com/img/course/a2/9/2-9.svg)

同样，我们需要思考下链表的时间复杂度，假设我们有`N`个元素，数组的长度为`M`。每个链表的长度平均为`N/M`，所以时间复杂度为`O(N/M)`。

##### 总结

我们对比下上面两种方法的优缺点

|            | 优点                                            | 缺点                                                         |
| ---------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 开放寻址法 | 不需要额外的空间，适用于**数据量小**的场景      | 处理冲突复杂，初始需要确定数组长度**无法动态扩充**，元素的删除**需要判断后面的元素是否需要前移**（因为冲突后移的元素，需要前移替换删除元素） |
| 链地址法   | 可以**动态申请空间**， 链表**删除元素非常方便** | 链表指针本身需要**额外的存储空间**                           |

学习了散列表，我们来完成几道常见的算法题目。

#### 7.8 LRU缓存算法实现

我们每天都在使用各种各样的`APP`，例如：微信，QQ，支付宝，etc。大家有思考过这些互联网应用（网站或者 APP）的整体流程是什么样的么？

![img](https://style.youkeda.com/img/course/a2/9/4-1.svg)

如上图所示，一般分为 3 步执行。

> 用户端发起网络请求，通过服务器处理，再查询对应的数据库获取到需要的数据。

随着互联网的普及，内容信息越来越复杂，用户数和访问量越来越大，我们的应用需要支撑**更多的并发量**，同时我们的应用服务器和数据库服务器所做的**计算也越来越多**。 但是往往我们的应用服务器**资源是有限的**，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），数据库的读取已经成为整个应用的**瓶颈**。

在这种情况下，应该怎样进行优化呢？

对，我相信大家已经找到解决方案了，**引入缓存**。如下图所示：

![img](https://style.youkeda.com/img/course/a2/9/4-2.svg)

##### 缓存

问题来了，**缓存**的特点是什么呢？

那肯定是**快速读取**，所以一般缓存存储方案都是采用本章我们学习的**散列表**。

比如获取用户信息服务，当我们第一次通过数据库查询用户 A 信息之后，可以将 A 用户信息存储在内存缓存中，那么下次再次请求用户 A 信息，可以直接从缓存中获取。代码如下：

```java
Map<String, UserInfo> userInfos = new HashMap<>();
synonyms.put("1", UserInfo1);
synonyms.put("2", UserInfo2);
```

在这里`userInfos`的`Key`为 **用户 ID** (唯一识别号)，`Value`为用户信息的对象。 那么之后，我们就用可以很方便的通过 **用户 ID** 从`userInfos`中快速获取用户信息，并不需要查询数据库。

##### LRU 算法

随着用户数越来越多，缓存需要的空间也越来越大，但是缓存本身的存储空间是有限的，用完了就不能用了，应该怎么办呢？

> 我们需要制定缓存的**淘汰策略**。

**LRU 是最常用的缓存淘汰策略**，全称为**least recently used**，中文名称为**最近最少使用**。

什么意思呢？

> 当我们缓存存储满了后，我们每次淘汰最近最少使用的缓存。换句话说，每个缓存都有优先级，每次使用一次缓存就将优先级提高，很久没有使用的缓存优先级当然最低，最应该被淘汰。

我们来看一个具体案例，假设我们的`userInfos`缓存只能存储 3 个用户的数据。

```java
// userInfos只能存储3个用户数据
Map<String, UserInfo> userInfos = new HashMap<>();
synonyms.put("1", UserInfo1);
synonyms.put("2", UserInfo2);
synonyms.put("3", UserInfo3);

// 存储已经满了

// 获取ID为3的用户信息
synonyms.get("3");
// 获取ID为1的用户信息
synonyms.get("1");

// 即将添加用户6，但是缓存已经满了，应该淘汰谁呢？
synonyms.put("6", UserInfo6);
```

特别注意下代码中的最后一步，即将添加**用户 6**的数据，但是缓存已经撑满，那么应该淘汰那个用户信息呢？

> 利用`LRU`策略，我们很容易发现**用户 2**是最近最少使用的，所以淘汰用户 2。

明白了这个原理，剩下的交给大家，请大家实现一个`LRUCache`。

### <8> 树

#### 8.1 应用最广泛的数据结构：树

之前介绍的所有的数据结构都是**线性存储结构**，比如：数组、链表、栈、队列。 本章所介绍的树结构是一种非线性存储结构，存储的是具有“**一对多**”关系的数据元素的集合。

给大家提个醒：**树是非常强大的数据结构，应用非常广泛，也是面试官最喜欢的数据结构**。

##### 树

一提到树，我们第一反应是什么？

![img](https://style.youkeda.com/img/course/a2/10/1-1.jpg?x-oss-process=image/resize,w_800/watermark,image_d2F0ZXJtYXNrLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSx3XzEwMA==,t_60,g_se,x_10,y_10)

对，正如大家所想，数据结构中的树和上图**倒置**的一样。我们来看看树在数据结构中是什么样的？

![img](https://style.youkeda.com/img/course/a2/10/1-2.svg)

如上图所示，我们了解下树的基本特征

> 1. 树是由多个节点组成的非线性数据结构
> 2. 树最上面的节点被成为**根**
> 3. 树中每个节点都有多个**儿子节点**
> 4. 树中无儿子节点的节点，被称为**叶子节点**

##### 二叉树

那什么叫二叉树？二叉树顾名思义**每个节点最多只有两个叉口**。通俗一点来讲，每个节点有一个左儿子和一个右儿子。如下图

![img](https://style.youkeda.com/img/course/a2/10/1-3.svg)

图示很容易理解，在此基础上我们再介绍两个概念

**完全二叉树**

> 每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点

大家配合下面的图片，仔细理解下这个概念。

![img](https://style.youkeda.com/img/course/a2/10/1-4.svg)

**完美二叉树**

> 完美二叉树更进一步，所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。

##### 二叉树的实现

有了上面原理性的了解，我们知道二叉树用**链表**方式非常容易实现，如下代码所示：

```java
public class TreeNode<T> {
  // 存储内容
  private T content;
  // 存储左指针，指向左儿子
  private TreeNode<T> left;
  // 存储右指针，指向右儿子
  private TreeNode<T> right;
}
```

当然也能用数组存储二叉树结构，只是会非常的麻烦，并不推荐。有兴趣的同学，下来可以自己了解一下。

#### 8.2 二叉树常用知识点

我们已经了解了什么叫做二叉树。以后的课程内容基本都是基于**二叉树**进行了。

我们首先来了解下二叉树相关的基础知识点。 下面的讨论，更多是基于**完全二叉树**进行的，大家脑袋里一直要有一个完全二叉树的虚拟构想。

##### 二叉树每层节点数

我们首先讨论第一个知识点，**二叉树每层的节点数多少个？**

最少情况大家应该能猜到只有 1 个，最多的情况多少个呢？我们来看看下面这张图。

![img](https://style.youkeda.com/img/course/a2/10/2-1.svg)

从图中我们很容总结出如下公式：

```java
// 第 N 层最多节点个数，N 是从 0 开始的
2 ^ N
```

##### N 个节点的二叉树高度

上面我们是根据树的高度获取每一层的节点个数，我们来想一个相反的方向。 **如果给定所有的节点的个数为 N，请问树的高度是多少呢？**

最高的情况当然是每个节点只有一个左儿子或者只有一个右儿子节点，如图：

![img](https://style.youkeda.com/img/course/a2/10/2-3.svg)

这种情况下**树的高度为 N**。

我们继续考虑高度最矮的情况呢？那什么时候树的高度最小呢？

> 当然是除了最后一排都是饱满节点，并且最后一排叶子节点均在左侧，这种树也就是上一节中提到的完全二叉树。

种场景下，我们可以简单利用数学公式进行推导。 假设树的高度为`h`，树的所有的节点数为`N`，那么公式推导如下：

![img](https://style.youkeda.com/img/course/a2/10/2-2.svg)

> 这个基本公式推导过程，大家需要掌握，里面会用到**等比数列求和**公式，如果不熟悉的同学需要自己上网学习一下喔。

从上面的推导，得出的结论为：

```java
// 如果一直一棵树的节点数为 N，那么这棵树的高度为
log(N) //下标为2
```

##### 总结

从上面两个特征可以看出，树有两种极端情况。

**1. 每层节点数为 1**

> 这时候，整个树就变成了一个单向链表，之前已经学习过了。

**2. 每层节点数尽量多**

> 这时候，整个数就是一个**完全二叉树**，之后我们讨论和练习中提到的二叉树，都是**完全二叉树**喔。

#### 8.3 二叉树的遍历算法 - 广度优先遍历

本节课开始，二叉树的难度将有点小提升，大家有点心理准备。 我们在学习数组和链表的时候，我们总是会考虑他们的遍历方式。大家试想下二叉树应该怎么遍历呢？

在二叉树中，遍历方式非常多，一共分为两大类**广度优先遍历**和**深度优先遍历**，其中深度优先遍历又分为**先序**、**中序**、**后序**遍历。

![img](https://style.youkeda.com/img/course/a2/10/3-1.svg)

我们依次来学习一下。

##### 广度优先遍历

广度优先遍历，有些文章也描述为宽度优先遍历，都是同一个意思，只是翻译人不同而已。对于这种算法，我们最好还是从原英文开始理解，原始英文为`Breadth First Search`，简称为`BFS`。

无论是**广**还是**宽**，在树中都表示为**层次遍历**，也就是我们先遍历第 0 层，再遍历第 1 层，再遍历第 2 层。 如图所示：

![img](https://style.youkeda.com/img/course/a2/10/3-2.svg)

图示中**绿色表示遍历顺序**。 根据图示，我们再次理解一下这里的**广度优先**到底是什么意思？

> 比如这里的`1节点`，我们先将其所有的儿子节点遍历完成，才遍历其孙子节点。

大家注意一下这里的描述，将和后面的深度优先做对比。

##### 算法思路

那这种遍历算法，应该怎么实现呢？

> 大家只需要记住一点，特别重要：**只要是`BFS`遍历，都可以使用`队列`实现**。

我们来看看具体的思路：

**第 1 步：将根节点添加到队列中**

![img](https://style.youkeda.com/img/course/a2/10/3-6.svg)

**第 2 步：取出队列头元素，添加其儿子节点**

![img](https://style.youkeda.com/img/course/a2/10/3-7.svg)

我们取出队列头元素`1`，将其两个儿子节点`2`和`3`添加到队列中。

**第 3 步：继续取出队列头元素，添加其儿子节点**

![img](https://style.youkeda.com/img/course/a2/10/3-8.svg)

我们取出队列头元素`2`，将其两个儿子节点`4`和`5`添加到队列中。

**直到队列为空，则遍历完成**

##### 代码实现

在这里我们不用自定义`Queue`，我们可以使用`Java`内置的`LinkedBlockingQueue`。

代码如下：

```java
// 广度优先遍历
public static void traverse(TreeNode<Integer> root) throws InterruptedException {
    // #构建一个队列，存储树中的节点
    LinkedBlockingQueue<TreeNode<Integer>> queue = new LinkedBlockingQueue<>();
    // #1. 添加根节点
    queue.put(root);
    // #2. 循环获取队列头元素信息
    while (queue.peek() != null) {
        TreeNode<Integer> node = queue.remove();
        // #3. 遍历并且打印元素信息
        System.out.println(node.getContent());
        // #4. 分别将左、右儿子添加到队列中
        if (node.getLeft() != null) {
            queue.put(node.getLeft());
        }
        if (node.getRight() != null) {
            queue.put(node.getRight());
        }
    }
}
```

代码的整体思路和上面学习的算法思想一致，只要理解了思想，写代码难度还是不大的。重点解释一下这里的`throws InterruptedException`。

> `LinkedBlockingQueue`数据结构，如果是用`put`函数，可能会出现`InterruptedException`异常，我们使用的时候注意处理即可。

最终的遍历结果为：

```java
1
2
3
4
5
6
7
```

符合我们的期望，接下来我们学习下深度优先遍历。

##### 总结

再次总结一下，以后在很多算法都会出现`BFS`，只要看到`BFS`想都不用想，直接使用**队列**进行遍历。

#### 8.4 二叉树的遍历算法 - 深度优先遍历

这节课我们将开始学习**深度优先遍历**，学习完本小节，大家会感受到**递归**的强大之处。

我们先来解释下，什么叫做**先序、中序、后序**遍历？

> 教给大家一个小技巧，这里的**先、中、后**，都可以想成是**先根、中根、后根**。

还是不懂？没关系，我们来看一个例子，大家肯定能明白。

![img](https://style.youkeda.com/img/course/a2/10/3-9.svg)

如上图所示，这棵树一共有三个节点，那三种遍历方式结果是什么呢？

**先序遍历**

```java
1， 2， 3
```

> 遍历顺序为：根节点 -> 左节点 -> 右节点 **先遍历根节点，所有叫先根**

**中序遍历**

```java
2， 1， 3
```

> 遍历顺序为：左节点 -> 根节点 -> 右节点 **第 2 次遍历根节点，所以叫中根**

**后序遍历**

```java
2， 3， 1
```

> 遍历顺序为：左节点 -> 右节点 -> 根节点 **最后一次遍历根节点，所以叫后根**

**大家现在只需要掌握不同遍历方式的算法实现，我们后面会讲到具体的使用场景**。

##### 先序遍历

明白了先序遍历的意思，我们来看之前的一棵完整的树的先序遍历结果：

![img](https://style.youkeda.com/img/course/a2/10/3-3.svg)

我们来思考下遍历顺序：

1. 因为是**先根**，所有我们优先遍历`1`。
2. 开始遍历`1`的**左节点子树**（`2, 4, 5`）
3. `2, 4, 5`的先序遍历顺序为`2, 4, 5`，所以现在的遍历顺序为`1, 2, 4, 5`
4. 然后开始遍历`1`的**右节点子树**（`3, 6, 7`）
5. 最终整合的结果为`1, 2, 4, 5, 3, 6, 7`

##### 中序遍历

先序遍历比较容易理解，中序遍历稍微复杂一点点，同样我们来看遍历示意图：

![img](https://style.youkeda.com/img/course/a2/10/3-4.svg)

我们来思考下遍历顺序：

1. 因为是**中根**，所有我们优先遍历`1`的**左节点子树**(`2, 4, 5`)
2. **左节点子树**的中根遍历结果`4, 2, 5`
3. 这时候左节点遍历完成，应该遍历根节点了，所以顺序为`4, 2, 5, 1`
4. 然后我们遍历`1`的**右节点子树**(`3, 6, 7`)
5. 用同样的中根方式遍历的**右节点子树**的结果为`6, 3, 7`
6. 最终整合的结果为`4, 2, 5, 1, 6, 3, 7`

到这个时候我们可以看出规律了

> **先序、中序、后序遍历作用于整个树以及每个子树**

比如当考虑`1, 2, 3`三个节点的时候，我们将`2`和他的儿子`4, 5`看成一个整体子树，将`3`和他的儿子`6, 7`看成一个整体子树。 然后每个子树里面再进行**先序、中序、后序遍历**， 这就是**典型的递归思想**。

我们带着这个递归思想来想想后序遍历的结果。

##### 后序遍历

![img](https://style.youkeda.com/img/course/a2/10/3-5.svg)

我们来看看遍历顺序：

1. 因为是**后根**，所有我们优先遍历`1`的**左节点子树**(`2, 4, 5`)
2. **左节点子树**的后根遍历结果`4, 5, 2`
3. 这时候左节点遍历完成，应该遍历`1`的**右节点子树**(`3, 6, 7`)
4. 用同样的后根方式遍历的**右节点子树**的结果为`6, 7, 3`，现在的遍历顺序为`4, 5, 2, 6, 7, 3`
5. 最终添加根节点的结果为`4, 5, 2, 6, 7, 3, 1`

**此时如果还是不能理解这个遍历顺序的同学，请把上面 3 个遍历案例多想想，甚至在草稿纸上画一画，找一找感觉。**

##### 代码实现

此刻我们开始考虑如何用代码实现这样的遍历顺序。一看到**递归思想**，我们应该怎么办？还记得之前讲过的逻辑么？

> 我们需要思考两个点，**递归的基准条件（结束条件）** 和 **递归公式**

以先序遍历为例，递归的**结束条件**是什么呢？

> 如果这棵树为空，那么递归结束

**递归公式**是什么呢？

> 递归公式就是**遍历顺序同样作用于其左右儿子子树**。 先序遍历的公式：**先序遍历树 = 打印根元素 + 先序遍历左儿子树 + 先序遍历右儿子树**。

理清了递归的这两个条件，剩下代码就很简单了，我们来看看

```java
// 先序优先遍历
public static void preTraverse(TreeNode<Integer> root) {
    if (root == null) {
        return;
    }
    // 先根
    System.out.println(root.getContent());
    // 左子树
    preTraverse(root.getLeft());
    // 右子树
    preTraverse(root.getRight());
}
```

最终的结果为:

```java
1
2
4
5
3
6
7
```

和猜想的结果完全一致，这就是**先序遍历**的代码实现。

5.5 二叉搜索树 -- 查找

在学习本小节之前，让我们回顾下之前的课程中的两种数据结构。

**有序数组**

> 在之前的第 2 章内容中，我们讲过**有序数组可以利用二分法非常快速的查询元素是否存在**，时间复杂度为`O(logN)`。 但是它也有一个很明显的缺点，**有序数组的插入和删除，将引起所有后续元素的移动**，时间复杂度为`O(N)`，非常低效。

**散列表**

> 后来我们在第 9 章又学习了散列表，散列表的查询速度非常快，达到`O(1)`。但是它并不能保证存储的顺序。

那么问题来了？ 如果想在**既保持顺序的前提下，让查询、插入、删除的效率都达到极致**呢？ 这就是本节学习的重点 --- **二叉搜索树**

> 二叉搜索树，也被称为**二叉查找树**，英文名称为`Binary Search Tree`，简称为`BST`。

> 在我们课程中所提到的**简称**，大家都需要稍微记忆一下，这体现一个人的**算法专业程度**，以后面试老师经常会直接问你是否听说过`XXX(简称)`。

##### 二叉搜索树

那什么叫做二叉搜索树呢？

> 1. 首先它是一个二叉树；
> 2. 其次若它的左子树不空，则**左子树上所有结点的值均小于它的根结点的值**；
> 3. 若它的右子树不空，则**右子树上所有结点的值均大于它的根结点的值**；
> 4. 它的左、右子树也分别为**二叉搜索树**

看到第 4 点特征，是不是很熟悉？

![img](https://style.youkeda.com/img/course/a2/10/5-1.gif)

这又是**递归**，**递归**又来了。。。 对，从**树**开始，我们将频繁的使用**递归**来解决问题。

我们来看一个二叉搜索树的真实案例：

![img](https://style.youkeda.com/img/course/a2/10/5-2.svg)

从图中，我们可以看出

1. 根元素`4`的左侧所有节点都小于 4，`4`的右侧所有节点都大于 4
2. 左侧子树，右侧子树分别都满足二叉搜索树的条件

因此这就是一个二叉搜索树。

#### 8.5 二叉搜索树 --- 查找

如果存在这样一棵树，那我们应该怎么查找元素呢？

举个小例子，我们想在这堆数据里，查找是否存在一个值为`3`的元素。

**第 1 步：比较根元素**

我们比较根元素`4`和目标元素`3`，因为`3`比`4`小，所有在左侧子树里面继续查找。

![img](https://style.youkeda.com/img/course/a2/10/5-3.svg)

**第 2 步：比较左侧根元素**

我们继续比较左侧子树的根元素`2`, 因为目标元素`3`比`2`大，所以在`2`的右侧子树里继续查找。

![img](https://style.youkeda.com/img/course/a2/10/5-4.svg)

**第 3 步：比较`2`的右侧子树**

这时候我们刚好看到元素`3`，所以找寻成功。

整个查找逻辑本身并不复杂，甚至比二分法更容易理解。

##### 时间复杂度

我们来考虑下二叉搜索树的时间复杂度是多少呢？

> 因为最多比较**树的高度次**便可以查到结果，树高度为`log(N + 1)`，所以时间复杂度为`log(N)`。

本节课开始，大家需要根据思路自己完成编程代码喔，老师只讲原理，不讲实现了。

#### 8.6 二叉搜索树 -- 插入

在上一节课中，我们所有的讨论都是基于已经存在的一棵二叉搜索树。那怎么去构建一棵二叉搜索树呢？

本节课我们将讨论，**如何生成一个二叉搜索树**？

##### 插入节点

生成二叉树的核心逻辑只有一个，我们需要弄清楚**如何在一个二叉搜索树里面插入新的节点？**

> 插入节点和上一节中查找逻辑非常相似，从根开始依次比较，找到恰当的位置执行插入操作。

如下图所示，在这种情况下如何插入`8`这个节点。

**第一步**

![img](https://style.youkeda.com/img/course/a2/10/6-1.svg)

我们将`8`与根节点`4`比较，比`4`大，查找右侧子树。

**第二步**

![img](https://style.youkeda.com/img/course/a2/10/6-2.svg)

我们将`8`与节点`6`比较，比`6`大，继续查找`6`的右侧子树。

**第三步**

![img](https://style.youkeda.com/img/course/a2/10/6-3.svg)

我们将`8`与节点`7`比较，比`7`大，继续查找`7`的右侧子树。

**第四步**

![img](https://style.youkeda.com/img/course/a2/10/6-4.svg)

因为`7`没有右子树了，我们将`8`挂载成`7`的右儿子。

##### 重复情况

在插入的时候大家需要注意，二叉搜索树是**没有重复节点**的！也就是二叉搜索树中所有节点的值都不相同，如果遇到插入的数字已经存在树中，则直接返回。

#### 8.7 二叉搜索树 -- 删除

上一节课，我们讨论了如何构建一个二叉搜索树。本节课我们来讨论下，如何在一棵二叉搜索树中删除某个节点。 注意注意，在二叉搜索树中删除节点，比前面的查找和删除都要**更加复杂**。

首先我们提供一棵上一节课生成的树，如下图所示：

![img](https://style.youkeda.com/img/course/a2/10/7-1.svg)

所有的删除节点的操作，将**影响到节点父亲和儿子**，所以我们将节点大致分为 3 类：

1. **无儿子节点的节点**，也就是叶子节点
2. **只有一个儿子的节点**（无论是左儿子节点还是右儿子节点）
3. **有两个儿子的节点**

##### 下面我们将基于这 3 中情况讨论二叉搜索树的删除方案。

![img](https://style.youkeda.com/img/course/a2/10/7-2.svg)

###### 1. 叶子节点的删除

对于叶子节点的删除是最简单的，毫无牵挂，直接删除。 对于代码而言，即**将父亲的此儿子赋值为`null`**。

![img](https://style.youkeda.com/img/course/a2/10/7-3.svg)

###### 2. 单儿子节点的删除

对于只有一个儿子的情况，在删除之前我们需要**将节点父亲和节点儿子产生关联**。如图所示：

![img](https://style.youkeda.com/img/course/a2/10/7-4.svg)

分为两步执行：

1. 将父亲儿子指针指向被删除节点的儿子。
2. 删除此节点

###### 3. 双儿子节点的删除

对于双儿子节点的删除是最复杂的，我们需要思考下: **应该用哪个节点替换该节点的位置，并保证新的树也是个二叉搜索树**。

因为二叉搜索树的特征，我们知道必须找寻和此节点最接近的节点。 因此，我们可以选择**左子树中最大的节点**，或者**右子树中最小的节点**。

从上面的推理，我们可以通过三步完成删除操作。

**第一步：寻找右侧子树最小的节点**

![img](https://style.youkeda.com/img/course/a2/10/7-5.svg)

如图所示，我们知道右侧子树最小的节点，即是右儿子的左儿子，左儿子，左儿子，etc。

**第二步：交换两个数内容**

![img](https://style.youkeda.com/img/course/a2/10/7-6.svg)

**第三步：删除找到的节点**

![img](https://style.youkeda.com/img/course/a2/10/7-7.svg)

大家需要仔细理解下上面的逻辑，了解二叉搜索树的插入和删除，是对二叉搜索树特征的进一步深入理解，对之后的应用有非常大的帮助。

#### 8.8 二叉搜索树 -- 优化

回到上一章**二叉搜索树的删除**，还记得最后一个案例么？当我们删除根节点 4 以后的树是什么样的？

![img](https://style.youkeda.com/img/course/a2/10/8-1.svg)

注意树的**右侧部分**，这就已经不是一棵树了，我们甚至可以将其理解为一个**链表**。 我们再试想一种极限情况，当新增和删除 N 次以后，会不会出现如下情况：

![img](https://style.youkeda.com/img/course/a2/10/8-2.svg)

如果最终是这种情况，那么树的优势荡然无存了。。

当然，这种情况在程序员界是不被允许的，那我们怎么解决呢？

> 本节课，我们将讨论解决方案，但是仅限于理论讨论，大家有个概念即可。 在后面的高阶课程，我们在考虑深度研究。

##### AVL 平衡二叉树

那什么是**平衡二叉树**呢？简单一句话

> **任何一个节点的左右两个子树的高度之差不能超过 1**

俗话来说，尽量让这棵树接近于平衡。这样配合二叉搜索树，能让搜索、插入、删除的时间复杂度保持在`log(N)`附近。

那问题来了，怎么保证一棵树是平衡二叉树呢？

> 在每次插入或删除节点后，我们可以通过**左旋**或**右旋**，形成平衡二叉树。

大家有兴趣的可以自己去网上搜索了解一下，在这里就不展开讲了。

##### RB-Tree 红黑树

通过上面我们知道，平衡二叉树在每次插入和删除节点后，需要通过一些旋转操作让树保持平衡。

这些旋转操作本身是有一定的开销，而红黑树的出现是为了优化这部分旋转的开销。大家可以简单理解

> 红黑树是对平衡二叉树的进一步优化

有兴趣的同学，同样也可以了解一下。

