---
Layout: post
desc: java数据结构基础
title:  java数据结构基础
tag:  study
---

## JAVA数据结构

### <1>复杂度



#### 1.1 大O记法



##### 计算机如何判断程序性能？

我们都知道，编程基本上是在和数据打交道，大多数程序基本在处理获取数据、查询数据、操作数据、返回数据相关的逻辑。



因此出现了数据结构和算法，这两者出现本质是为了解决如何能够更快，更省进行数据处理。



这里的更快，也就是程序运行时间更短，对应的指标我们称之为时间复杂度。



这里的更省，也就是程序运行所消耗的内存更少，对应的指标我们称之为空间复杂度。



##### 为什么需要复杂度

`《1》程序运行时间更短《2》消耗的内存更少`分别表明了开始运行和结束运行两个时间点差额和内存使用情况。

![1](/Users/dongyanzu/Desktop/1.svg)

通过这种计算方法可以判断性能，为什么还需要进行复杂度分析呢？主要有三个原因。

1. 测试结果大大依赖硬件条件

> 不同机器运行时间差别很大。

2. 测试结果需要事后才能计算

> 往往我们是在程序运行之后才能形成统计结果，但我们大多希望在伪代码阶段，便能预测程序的执行性能。

3. 测试结果受原始数据特性影响大

> 我们以排序为例，如果给出的数据已经是排好序的，那需要的时间几乎等于0，而如果给出的数据是完全打乱的，那需要的时间肯定非常长。

##### 总结

我们需要一个不用具体的测试数据和测试环境，这样就可以粗略地估计算法执行效率的方法。这个方法我们称作为复杂度，我们称作为大O记法。



#### 1.2 时间复杂度

-----暂时省略





#### 1.3 空间复杂度

##### 如何计算空间复杂度？



空间复杂度和时间复杂度一样，同样遵循大 O 记法。

时间复杂度是以步为基础单位，空间复杂度是以一个基础数据类型值当作基础数据。



O(1)

```java
int a = 0;
int j = 0;
```

O(n)

```java
int a[] = new int[n]
```

代码都比较简单，就不多做解释啦。

##### 优先考虑时间复杂度

在实际编程过程中，我们大多数情况**只会考虑时间复杂度**！！为什么呢？

因为我们默认计算机内存是足够大的，足够给我们使用的。 大家是否听说过**摩尔定律**。

> 当价格不变时，集成电路上可容纳的元器件的数目，约每隔 18-24 个月便会增加一倍，性能也将提升一倍。

换而言之，**每个 18-24 个月，同样大小的芯片里可存储的数据量将翻一倍**。 因此我们完全可以忽略内存空间不够的情况。

**除非**，注意除非大家以后参与嵌入式开发，参与单片机相关的编程开发，才需要注意空间问题。 **之后的讨论，都只会基于时间复杂度问题展开**。



#### 1.4 查找

##### 线性查找

遍历数组，取出数组中每个元素，与目标元素进行对比。暴力查找，方法很简单，但是很笨。

```java
//伪代码部分段
//目标数组
int[] arr = new int[] {2,3,4,5,8,4,9,0};

//目标元素
int target = 8;

//目标元素所在的下标
int index = -1;

for(int i = 0 ; i< arr.length; i++) {
	if(arr[i] == target) {
		index = i;
		break;
	}
}

System.out.println("index: " + index);

```

##### 性能优化-而二分法查找

我们按照线性查找，很显然我们知道查找方法的时间复杂度是:O(N);



做一个性能优化，对于**有序数组** 我们可以使用二分法查找。由于数组是有序的，我们可以先比对中间索引值，再来缩小查找的范围。

```java
public static int find(int[] array, int aim) {
    // 初始化left = 最左侧, right = 最右侧
    int left = 0;
    int right = array.length - 1;

    // 当left > right则表示遍历完成
    while (left <= right) {
        // 获取中间的值
        int middle = (left + right) / 2;
        int middleValue = array[middle];
        if (middleValue == aim) {
            // 已经找到目标
            return middle;
        } else if (middleValue < aim) {
            // 目标在middle的右侧，重置left
            left = middle + 1;
        } else {
            // 目标在middle的左侧，重置right
            right = middle - 1;
        }
    }
    return -1;
}
```

对于二分法查找而言，时间复杂度为 O(log(N)) 。



#### 1.5 二次问题

前一节我们体会到了`O(n)->O(log(N))`优化。

> 假设给定一个数字数组，数组里面每个数字介于 0 -10 之间，请找出里面重复的数字。

比如：

```java
数字数组为：[0, 8, 2, 3, 5, 6, 2, 2, 10, 8]

重复数字为：[8, 2]
```

##### 暴力破解

每次获取一个元素，依次判断这个元素和之后的元素是否有重复。

```java
public static ArrayList<Integer> repeat(int[] array) {
    ArrayList<Integer> result = new ArrayList<>();
    for(int i = 0; i < array.length; i++){
        // 以此判断i位置元素和后面j位置元素是否相等
        for(int j = i + 1; j < array.length; j++){
            if(array[i] == array[j]){
                // 如果之前result没有，则进行添加
                if(!result.contains(array[i])){
                    result.add(array[i]);
                }
            }
        }
    }
    return result;
}
```

该方法的时间复杂度，由于有两个`for`循环嵌套，所以是`O(N^2)`



##### 标记法（更优）

由于我们需要查找的是，0-10数字数组里面重复的数字。



我们可以通过申请一个数组，数组名称为`exists`,表示数字是否存在。数组的长度为11，并且数组里面的值默认都为 0 ，表示 0 -10 这 11 个数默认都不存在。



扫描数组中的数字，如果出现则对`exists`数组中的位置标记为1，此后从数组中扫描出来的数字中，如果有重复，则将记数改为2，此后在出现大于2的重复数字不需要再添加进去，所以需要判断标记位为1，才能添加进入`result`数组中。



```java
public static ArrayList<Integer> repeat(int[] array) {
    ArrayList<Integer> result = new ArrayList<>();
    int[] exists = new int[11];
    for (int i = 0; i < array.length; i++) {
        int value = array[i];
        // 只有当前位置已经为1，标示重复，并且输出，>1情况则不输出了
        if (exists[value] == 1) {
            result.add(value);
        }
        // 用exists标示记录
        exists[value]++;
    }
    return result;
}
```

该案例，很好解释了，通常我们会使用空间换取时间。



### <2> 数组

##### 数组存储

*数组的索引都是从0开始的。*

> 数组（Array） 是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。

线性数据结构：表示数组中数据都是按照前后这种线性顺序排列的。相同的数据类型：数组中的每个值的数据类型都相同。



##### 数组读取

每个数组都有对应的内存地址，我们将其称作为数组开始地址 ---start_address



数组在定义的时候，以及确定每个数组元素的数据类型了，也就是我们知道每个元素需要的内存空间大小，我们称为 --- item_size。



求第N个元素地址公式如下：

```java
// 第 N 个元素地址
start_adress + item_sieze * (N-1);
```

1. 时间复杂度

>数组的索引访问的时间复杂度是O(1)

2. 为什么数组索引从 0 开始？

> 内存地址的计算规则决定开始地址为start_adress + item_sieze * 0，在计算机中为了方便位置的计算，所以数组索引从 0 开始。

##### 面向对象的数组（包括数组元素的添加，删除，插入，替换）

```java
public class MyArr {
	// 用于存储数据的数组
  private int[] elements; //举例int类型数组
  //记录当前顺序表中的元素个数
  private int length;
  public MyArr(int capacity) {
    this.elements = new int[capacity];
    this.length = 0;
  }
  //获取数组长度的方法
  public int size() {
    return elements.length;
  }
  //往数组的末尾添加一个元素
  public void add(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length+1];
    //把原数组中的元素复制到新数组中
    for (int i =0 ; i <elements.length;i++) {
      newArr[i] = elements[i];
    }
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr ;
  }

  // 打印所有元素到控制台
  public void show() {
    System.out.println(Arrays.toString(elements));
  }
  // 删除元素
  public void delete(int index) {
   	check();
    //创建一个新的数组，长度为原数组的长度为-1
    int[] newArr = new int[elements.length-1];
    //复制原有的数据到新数组
    for(int i = 0 ; i < newArr.length ; i++) {
      //想要删除的元素前面的元素
      if(i < index ) {
        newArr[i] = elements[i];
      }
      //想要删除的元素后面的元素
      else{
        newArr[i] = elements[i+1];
      }
    }
    //新数组替换旧数组
    elements = newArr;
  }
  //取出指定位置的元素
  public int get(int index) {
    check(index);
    return elements[index];
  }
  //插入一个元素到指定位置
  public void insert(int index , int element) {
    check(index);
    //创建一个新的数组
    int[] newArr = new int[elements.length+1];
    //将原数组中的元素放入新数组中
    for(int i=0;i<elements.length;i++) {
      //目标之前的元素
      if(i < index) {
        newArr[i] = elements[i];
      }
      //目标之后的元素
      else{
        newArr[i+1] = elements[i];
      }
    }
    //插入新数组
    newArr[index] = element;
    //新旧数组替换
   	elements = newArr;
  }
  //替换指定位置的元素
  public void set(int index , int element) {
    //判断下标是否越界
    check(index);
    return elements[index] = element;
  }
  //判断线性表是否为空
  public boolean isEmpty() {
    return N==0;
  }
  //封装一个检查下标是否越界的方法
  public void check(int i) {
    if(index < 0 || index > elements.length-1) {
      throw new RuntimeException("下标越界");
    }
  }
}

public class TestMyArr {
  public static void main(String[] args) {
    MyArr myArr = new MyArr();
    //可以调用一系列 myArr 方法。
  }
}
```

*线性表的增删都需要对内存进行申请，增删操作会比较慢。*



### <3>链表

#### 3.1链表

##### 1  单链表

​	线性表的链式存储结构（简称链表）是指用一组人意的存储单元来依次存放线性表的结点，这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上。

单链表结点结构需要（data 数据域 和 next 指针域）。链表正是通过每个结点的链域将线性表的n个结点按其逻辑次序链接在一起的。由于 上述 链表中的每一个结点只含有一个链域，故将这种链表称为单链表。

``` java
//一个结点
public class Node {
  
  //结点内容
  public Object data //数据域   
  //下一个结点 
  public Node next； //指针域
  //空构造函数
  public Node() {
		this(null,null);
  }
  public Node(int data) {
    this.data = data;
  }
  //两个参数的构造函数
  public Node(int data , Node next) {
    this.data = data;
    this.next = next;
  }
}
	
	//单链表增删改查实现
	public class LinkList{
  	//单链表头指针
  	private Node head;
    //记录链表的长度
    private int length;
  	//单链表构造函数
  	public LinkList() {
    	//初始化头结点
    	this.head = new Node();
      //初始化长度
      this.length=0;
  	}
  	//将一个以及存在的带头结点的单链表置成空表
  	public void clear() {
    	head.next = null;
    	this.N = 0;
  	}
  	//判断带头结点的单链表是否为空
  	public boolean isEmpty() {
    	return head.next == null;
  	}
  	//求链表的长度
  	public int length(){
    	return length;
  	}
    //求带头结点的单链表中的第i个结点
  	public Object get(int i ){
    	//通过循环从头结点开始往后面罩，依次找i此，就可以找到
    	Node p = head.next;
    	while(int index = 0 ; index < i ; i++) {
      	p = p.next;
    	}
    	return p.data;
  	}
  	//按值查找
  	public int indexOf(Object x) {
			//从头结点开始便利，取出data与x比较，如果相同，则找到
    	Node p = head.next;
    	for(int i = 0;n.next!=null;i++) {
        n = n.next;
        if(n.data.equals(x)) {
          return i;
        }
      }
      	return -1;
  	} 
  	//插入元素
  	public void insert(Object x) {
      //找到最后一个结点
      Node s = head;
      while(n.next!=null) {
        n = n.next;
      }
	 		//创建一个新的结点，保存元素x
      Node newNode = new Node(data,null);
      //让最后一个结点指向新结点
    	n.next = newNode;
      length++;
 	 	}
    //向指定位置i插入元素，添加元素t
    public void inset(int i , Object x) {
      //找到i位置前一个结点
      Node pre = head;
      for (int index=0;index=i-1;i++) {
        pre = pre.next;
      }
      //找到i位置的结点
      Node curNode = pre.next;
      //创建新结点，并且新结点需要指向原来i位置的结点
      Node newNode = new Node(x , curNode);
      //原来i位置的结点指向新结点
      pre.next = newNode;
      //元素的个数+1
      length++;
    }
  	//删除带头结点的单链表中的第i个结点
 		public void remove(int i ){
    	//p得等于head,而不是head.next
    	Node p = head;
      //找到i位置的前一个结点
      Node pre = head;
      for (int index=0;index=i-1;i++) {
        pre = pre.next;
      }
      //找到i位置的结点
      Node curNode = pre.next;
      //找到i位置的下一个结点
      Node nextNode = curNode.next;
    	//前一个结点指向下一个结点
    	pre.next = nextNode;
      //元素个数-1
      length--;
      /**
      *如果需要返回删除的元素，则：
      *return curNode.data;
      */
    	}
    public void listOutput() {
      Node p = head.next;
      while( p != null ) {
        System.out.println(p.data);
        p = p.next;
      }
    }
	}

public class TestNode {
  
  public static void main(String[] args) {
    /**
    *生成链表
    */
    //创建结点
    Node n1 = new Node(1, null);
    Node n2 = new Node(2, null);
    Node n3 = new Node(3, null);
    //此时创建了三个只有数据域的结点
    n1.next = n2;
    n2.next = n3;
  }
}
```

##### 2 双链表



#### 4.1 栈

从数据的逻辑结构角度看，栈是线性结构的，也是线性表（一种操作受限的线性表《FILO》）。栈是限制在表的一端进行插入和删除运算的线性表。

通常称允许进行插入、删除的一端为栈顶，另一端为栈底。当表中没有元素则称为空栈。

```java
public class MyStack {

  //栈的底层我们使用数组来存储数据
  int[] elements;
  
  public MyStack() {
    elements = new int[0];
  }
  
  //压入元素
  public void push(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length + 1];
    //把原数组中的元素复制到新数组中
    for(int i = 0; i<elements.length; i++) {
      newArr[i] = elements[i];
    }
    //把添加到元素放入新数组中
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr;
  }
  //取出栈顶元素
  public int pop() {
    //取出数组的最后一个元素
    int element = elements[elements.length-1];
    //创建一个新的数组
    int[] newArr = new int[elements.length-1];
    //原数组中除了最后一个元素的其他元素都放入新的数组中
    for(int i = 0; i<elements.length-1;i++) {
      newArr[i] = elements[i];
    }
    //替换数组
    elements = newArr;
    //返回栈顶元素
    return elements;
  }
  //查看栈顶元素
  public int peek() {
    return elements[elements.length-1];
  }
  //判断栈是否为空
  public boolean isEmpty() {
    return elements.length == 0;
  }
}
```



#### 5.1 队列

队列也是一种操作受限的线性表。队列是限制在表的一端进行插入，而在表的另一端进行删除的线性表，通常称允许插入的一段称为队尾，允许进行删除的一端为队头。当表中没有元素时称为空队列。  

```java
public class MyQueue {
  
  int[] elements;
  
  public MyQueue() {
    elements  = new int[0];
  }
  //入队
  public void add(int element) {
    //创建一个新的数组
    int[] newArr = new int[elements.length + 1];
    //把原数组中的元素复制到新数组中
    for(int i = 0; i<elements.length; i++) {
      newArr[i] = elements[i];
    }
    //把添加到元素放入新数组中
    newArr[elements.length] = element;
    // 使用新数组替换旧数组
    elements = newArr;
  }
  //出队
  public int poll() {
    //把数组中的第0个元素取出来
    int element = elements[0];
    //创建一个新的数组
    int[] newArr = new int[elements.length-1];
    //复制原数组中的元素到新数组中
    for(int i = 0; i<newArr.length;i++) {
      newArr[i] = elements[i+1];
    }
    //替换数组
    elements = newArr;
    return element;
  }
  public boolean isEmpty() {
    return elements.length == 0;
  }
}
```



#### 6.1 树和二叉树



#### 3.5 图



### <4> 查找与排序



