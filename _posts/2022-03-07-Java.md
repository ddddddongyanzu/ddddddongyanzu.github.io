---
Layout: post

title: Java_Study

description: myblog

tag: study

---

## JAVA实战

### 1.1 编程语言

​	*java作为一门伟大的面向对象程序设计语言，诞生于1995年5月（由Sun Microsystem推出），目前属于oracle公司。*

Java是一种高级语言，你可能听过其他高级语言还有Python、C、C++等。

一般计算机世界里把“低级语言”叫做机器语言或者汇编语言，实际上计算机只能运行低级语言，所以高级语言编写的程序必须先被翻译成低级语言才能运行。

​	Java语言的执行

Java和其他高级语言一样，需要先翻译成低级语言才能被计算机执行，目前世界上编程语言主要有两种方式

- 解释（interpreting）
- 编译（compiling）

完成解释任务的程序叫解释器，解释器会按行（一行一行的读取）对程序进行翻译，然后执行命令。

完成编译任务的程序叫做编译器，它会在高级语言执行之前一次性对该程序进行完整的编译，所以程序的运行时在编译之后。我们一般把这种高级语言称为源代码（source code，我们经常说的coding就是写源代码），编译器生成的程序称为可执行程序（executable）

Java比较强大，它既可以被编译，也可以被解释，不同的是Java编译过程并补生成机器语言，而是生成字节码。字节码和机器语言一样，但是它具备高级语言的可移植性，因此在一台机器上编译Java，在另外一台机器上也可以被解释运行，这就是Java语言能够在诞生的时候就瞬间超过了其他编程语言的核心原因，一次编写到处运行。

​	***java可以被编译，也可以被执行。Java编译过程并不生成机器语言，而是生成字节码。字节码和机器语言一样，但其具备高级语言的可移植性。***

### 1.2 Java程序的构成

> 除了生成字节码之外，Java 还创建了 JVM （Java virtual machine ，Java 虚拟机），通过 JVM 支持了字节码的解释运行。

​	***源代码在经过编译器编译后，除了生成字节码还会创建 JVM（Java virtual machine[Java虚拟机]）通过JVM支持java的解释和运行。***

![Screen Shot 2022-08-27 at 6.17.28 PM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-27%20at%206.17.28%20PM.png?raw=true)

> 所以 Java 语言的进阶可以分为两层：Java 语言、JVM。了解这个对之后程序的运行和代码中出现的问题能够更容易理解。

> 如上所说，Java 的运行是要把源代码编译成字节码，通过 JVM 来运行。

#### Java 源代码

​	Java源代码（后缀为.java的文本文件）比如：

`HelloWorld.java`

```java
public class HelloWorld {
	public static void main (String[] args) {
    System.out.println("Hello World");
  }

```

![Screen Shot 2022-08-27 at 6.17.40 PM.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/Screen%20Shot%202022-08-27%20at%206.17.40%20PM.png?raw=true)

> 注意：Java 文件名必须是英文字母（有数字也可以，尽量不用数字），并且不能有空格。一般来说 Java 文件名首字母是大写的，比如说：`User.java、School.java、Book.java`	`(遵循大驼峰命名法)`

 `Hello World` 可以通过 `println` 语句来输出到控制台里

> 注意 Java 对于字符串的输出都是用 `"`(英文双引号)

```java
public class <1> HelloWorld<2> {<3>

	public static void main(String[] args)<4> {
		System.out.println("Hello World");<5>
	}
}
```

1. 这是Java文件的固定格式，声明当前代码为一个Java类
2. Java源代码的类名称，它比Java文件名少了.java后缀
3. {} 这个是Java代码的规范，代码内容都应该被大括号包围住，类有大括号，方法也有大括号。
4. main方法是Java中最重要的，因为Java程序执行从这里开始
5. System.out.println 这个是一个输出内容到控制台的方法，Hello World 可以换成任意的字符串



> System.out.println("") 这句代码执行的是打印一行，println 其实是 print new line 单词的缩写 
>
> System.out.print("")这句代码执行的是打印“”，与println不同的是，该方法不会有newline（换行），在控制台后面接着打印。

不管是简单的还是复杂的 Java 代码都是类似这样的格式，所以在开始学习的时候知道格式就好。

> 补充说明一下，Java 代码基本上是一行一行的执行的，所以每一代码行结束的地方都有 `;` 作为结束字符，之后我们都是遵循这样的 Java 代码规范，因为你不遵守编译会失败的！

##### main 函数

上面的例子中，我们使用到的 main 函数是个非常特殊的方法，它是 Java 程序的入口

我们在以后所有的代码里，都是从 main 函数启动我们的 Java 程序的，没有 main 函数 ，Java 程序就无法执行哦

##### println 语句

`System.out.println` 这个是我们掌握的第一行代码，在以后我们也会经常会运用到，它的作用就是输出一个内容到控制台里并且自动换一行

与之相对应的是`System.out.print`，这个也是输出内容到控制台，不同的是不换行。

### 1.3 创建 Java类文件

> Java一切皆对象

Java 类规范:

> Java 文件名都是由首字母大写的英文单词组成

Java源码是由多个后缀名为.java的文本文件组成。创建 Java 类文件有四个规范需要遵守

1. 文件名由 类名 + .java 组成 比如 HelloWorld.java，其中Hello World 遵循大驼峰命名法

2. 类名中不能有中文和特殊字符，只能包含字母和数字

3. Java类内容遵循固定格式:

   public class 类名称 {

   }

4. Java类是存放在Java包中的，默认情况下Java 工程中的代码是存放在`src/main/java`目录中。



驼峰命名法(代码规范)：

 一般Java类的命名用大驼峰: HelloWorld.Java

方法和变量一般用小驼峰:	String userName;    void String myMethod(){}

### 1.4 Java 包管理器

​	上节我们了解到，创建一个正确的Java类由两个注意点：

1. 驼峰命名

2. 在正确的目录下创建`src/main/java`

   `src/main/java`这个文件夹，这是一个非常特殊的文件夹，因为 Java 工程会自动把这个文件夹下的代码认定为源代码，放在其他目录就不能识别了

   如果在一个目录下创建太多java文件，就会显得杂乱无章，如下图：

   ![java-muti.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/java-muti.png?raw=true)

   > 要打开某个文件，要找很久，目录也很长

   Java 系统其实和电脑的文件系统类似的，也需要分门别类的进行文件管理，在电脑中是通过文件夹来管理文件，在 Java 中是通过包管理器来管理的文件的

   > 包管理器是 Java 的文件管理系统，同样支持多个目录

   ##### 关于包（package）

   正如上面所述的问题，Java 体系也非常庞大，为了让更多的代码互不侵犯，所以采用一个叫 “包管理” 的机制来管理代码，简单来说就是把不同的 Java 代码放在不同的文件夹里，这个文件夹就是 “包（package）”。

   包和文件夹路径有个很大不同就是

   ```java
   // 文件夹路径是这样的
   d:/code/src/main/java/com/baidu/mode/Invoice.java
   
   // 包路径是这样的
   com.youkeda.mode.Invoice
   ```

   如上，大家可以对比看看，有两个区别

   - 包路径采用'.'分隔
   - 包路径不是绝对的文件路径，它只是相对 Java 工程目录的路径

   ##### 包名的规范

   现在我们说一下包名的规则，一般来说包名的开始是一个公司或者一个组织的域名的反写，如果是个人也可以遵守类似的规则，举个例子，ba百度的域名是 `baidu.com`,那么包名的起始就是`com.baidu`,我们就需要创建`com/baidu`这样的两级目录。Java 的规范建议是用包管理代码

   还有一个规则，除了域名之外一般还会添加一个程序的名称，比如说现在开发一个店铺系统，那么包路径就是`com.baidu.shop`

   ##### 自定义包

   自定义包其实就是创建文件夹，包路径就是文件夹相对路径，比如说 `com.baidu.app` 这是一个包路径（注意包路径和子包路径直接使用`.`来做分隔），对应的文件路径就是 `src/main/java/com/baidu/app`,如果工程没有这个文件夹，就需要自己创建一下和创建文件一样，只是要大家多创建几个子文件夹哦。

   如果我们在某个包下创建 Java 文件，那么 Java 类的内容就需要多个一个声明包路径的语法

   比如`com.baidu.app.Hello.java` 这样的 Java 类，我们可以分析一下，它的包名是

   ```java
   com.baidu.app
   ```

   类名称是`Hello`,创建好的类代码是这样的

   ```java
   package com.baidu.app;
   
   
   public class Hello {
   
   }
   ```

   正如你所见，我们多了一个 `package 包路径;`这样的语法，这个就是包的声明，注意这个语法，包路径是该 Java 所在的包目录。**一个文件只有一个 package 语句**，并且一般是在文件第一行

### 1.5 Java 代码注释

Java 遵循两种代码注释：

##### 块注释

```java
/**
* 我是块注释
*/
```

如上例，`*` 包围的地方可以填你想描述的内容，如果内容太多可以多行，但是每一行都要有 `*` ，如下面

```java
/**
* 这是我的第一个代码
*/
```

稍微仔细观察它的格式哦，以 `/**`开头，每一行内容都用`*`来前缀，结束用`*/`

###### 块注释的例子

一般，我们会在 Java 类的声明上面、方法上面使用块注释。我们看一下例子

```java
/**
 *  这个代码是用于输出 Hello World 的
 */
public class HelloWorld {

  /**
  * 这个是 main 方法
  */
  public static void main(String[] args) {
    
  }
}
```

###### 块注释的格式

对于块注释，开头的 */* 与 ** 之间、结尾的 * 与 */* 之间，都不能有空格，块注释 **必须** 以 /** 开头，**必须** 以 */ 结尾。

下列代码是错误的：

```java
/ **
 *  这个代码是用于输出 Hello World 的
 * /
```

下列代码是正确的：

```java
/**
 *  这个代码是用于输出 Hello World 的
 */
```

块注释的格式 很重要哦，不要写错。

##### 行注释：

行注释很简单，一般用于一行文字描述，语法就是 `// 注释`，比如说

```java
// 这行代码是要输出 我的世界
System.out.println("我的世界");
```

### 2.1 项目介绍

- 导入包
- Java变量
- 对象实例化
- 构造函数
- 方法调用
- Lambda表达式
- 继承
- 注解

完成这个TODO产品，需要借助 SpringBoot、Vaddin这两个框架。

> SpringBoot 是目前最主流的Java应用框架，基本上所有的应用都基于它来搭建的
>
> Vaadin是一个支持用Java语言开发Web页面的框架，目前在国外不少企业使用这个框架搭建后台应用

先让程序跑起来（核心代码）：

```Java
package org.vaadin.marcus.spring;

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.checkbox.Checkbox;
import com.vaadin.flow.component.html.H1;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.router.Route;

@Route("/")
public class Todo extends VerticalLayout {
public Todo() {

    String title = "YKD Todo";
    H1 h1 = new H1(title);
       // 创建一个文本输入框对象
    TextField todoField = new TextField();
    // 创建一个保存按钮对象
    Button addButton = new Button("Add");
    HorizontalLayout inputBtn = new HorizontalLayout(todoField, addButton);

    // 创建一个垂直方向的布局对象
    VerticalLayout todosList = new VerticalLayout();
    // 保存按钮点击后触发回调事件
    addButton.addClickListener(click -> {
        // 获取输入框的内容
        String todoVal = todoField.getValue();
        // 创建一个多选框
        Checkbox checkbox = new Checkbox(todoVal);
        // 添加到 todosList 这个布局里，作为列表里的一项
        todosList.add(checkbox);
    });

    // 在当前页面中添加组件
    add(h1, todosList, inputBtn);
	}
}
```

### 2.2 对象变量

​	前面有创建过`Company`、`Invoice`等对象类，这都属于自定义类。

##### Java基础对对象

- java.lang.String
- Java..lang.Integer
- Java.lang.Double
- Java.lang.Boolean

这四个对象是Java内部对基础数据类型，从单词命名就可以猜到是处理

- 字符串 “Hello World”
- 数字 123
- 浮点数字 10.12
- 布尔 true

在Java中，如果想操作对象，就得先搞定创建变量。

比如

```java
String userName = new String("joe");
```

但现在一般直接用

```java
String userName = "joe";
```

userName(变量名虽然可以任意设置，但是不能与Java中关键词一样，且要遵循小驼峰命名规范。)

##### 关键词

Java保留来一些名称，这些名称是不允许我们来声明的，这就是关键字。一般来说在编辑器里面关键字会高亮显示，提示编译错误的。例如：

- public
- class
- void
- int
- Boolean

### 2.3方法调用

Vaadin 是一个优秀的Web组建框架，其强大在可以用后端语言编写前端页面，可以用其替代掉Java Swing 的技术体系。

Vaadin 提供了丰富的组件，主要分为以下几类：

- 表单输入类

包括单选框、复选框、下拉框、日期输入框、邮箱输入框、数字输入框、密码输入框、文本框以及文件上传框等。

- 可视化与交互组件

包括：按钮、图标、链接、菜单、对话框、表格、树形表格、进度条以及标签页等

- 布局类

包括：应用布局、表单布局、登陆框等

- 高级组件（需要收费）

包括：图标、高级表格、富文本编辑器以及类Excel的编辑组件



##### 输入框组件

![text-field.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/text-field.png?raw=true)

Vaadin对于TextField做了大量的封装，从而方便用户使用。

Todo里面的输入框，就是由TextField提供的，在Vaddin中。TextField组件完整的类路径是

```java
com.vaadin.flow.component.textfield.TextField
```

如果想实例化 TextField

```java
TextField field = new TextField();
```

##### 布局组件（OrderedLayout）

在任何和 UI 相关的系统都会存在布局的概念，布局可以理解为一种容器，在容器内可以存储多个子组件，Vaadin 中提供了好多种布局方案，但是最常用的是 Ordered Layout，这个布局的效果如下图

![ordered-layout.jpg](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/ordered-layout.jpg?raw=true)

Ordered Layout 布局支持两种方向的自动布局，一种是是垂直方向，一种是水平方向，或者叫竖方向、横方向

这个布局的作用就是，如果有多个元素放在这个布局里，那么会自动根据布局方向来顺序显示

垂直方向布局类是

```java
com.vaadin.flow.component.orderedlayout.VerticalLayout
```

水平方向布局类是

```java
com.vaadin.flow.component.orderedlayout.HorizontalLayout
```

###### 敲重点

这个路径比较长，不需要死记硬背，有个印象：V开头的对象是垂直，H开头的是水平就可以啦。因为在实际编码过程中会有代码提示的，只要能选对就OK

##### 类继承

Todo 应用中的`org.vaadin.marcus.spring.Todo`类就是一个垂直布局类，只是这里运用到了 Java 中非常常见的知识点：**继承**

继承很好理解，就是儿子和父亲的关系，子类通过继承父类，就会拥有父类的一些内容，比如下面会讲到的方法，他的特点就是类的声明处多一个 extends 关键词，如下的代码

```java
package org.vaadin.marcus.spring;

import com.vaadin.flow.component.orderedlayout.VerticalLayout;

// Todo 继承于 VerticalLayout 
public class Todo extends VerticalLayout {

}
```

> 注意：父类一样需要导入包哦，在一个类对象中用到的其他类，都需要完成包的引入才能使用，除了相同包或者`java.lang`包可以省略（String 类就可以省略导入包）

###### 敲重点

通过继承，Todo 类也具备了 VerticalLayout 这个垂直布局容器的特性，就是它可以添加多个按照垂直方向对齐的子组件。下面会有视频演示讲解一点的，后面还会在详细介绍继承类特性的，在这里有个概念即可，如果现在不理解的话后面还会学习到的

##### 布局如何添加子元素呢？

> 这里我们又新引入一个知识，那就是方法调用。方法是 Java 对象类中重要的部分，它一般用于表示某种行为，所以调用方法就是执行某种行为

在 OrderedLayout 中有一个添加子元素的行为，这个行为被定义为 add 方法，add 方法可以添加任意个子组件，比如

```java
 TextField field = new TextField();
 add(field);
```

上面的代码的含义就是调用容器的add方法，添加了一个 field 子组件



### 2.4 变量对象的方法调用

由上图中可以看出，TextFiled还有很多效果，日常很多报名表均会用到Text Field，如下图

![text1.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/text1.png?raw=true)

上面的实现方法分别为:

- setLabel(String label)   `//label的内容不会显示在Label框中，但是填入值后会递交数据`
- setPlaceholder(String placeholder) `//label的内容不会显示在Label框中，但是填入值后会消失`
- setValue(String value)  `设置一个值（可修改）`

### 2.5 构造函数

补充Java对象构造函数的知识点， 创建变量的时候，使用的技术就是构造函数（该实战案例中Public Todo() {} 为构造函数)

```java
@Route("/")
public class Todo extends VerticalLayout {

  public Todo() {

      TextField userNameField = new TextField();

      String userName ="UserName";
      userNameField.setLabel(userName);

      add(userNameField);
  }
}
```

上面代码的 `public Todo() {}` 这个内容就是一个特殊**方法**，他的名称和类名称一样都是 Todo，这种方法就是**构造函数**，当我们 new 一个对象的时候，就是在调用这个构造函数。

### 3.1 Button按钮

在很多页面中都能看见按钮（button），像注册按钮，登录按钮，提交按钮，点赞按钮等等，基本上只要有信息录入的表单信息就会有button。

```java
com.vaadin.flow.component.button.Button
```

> 使用的时候，别忘记 import 包路径哦

如果要在页面中添加一个 button 是不是可以这样

```java
// 创建一个保存按钮对象
Button addButton = new Button();

// 在当前布局里添加按钮实例
add(addButton)
```

### 3.2 Lambda表达式

Button这个元素，需要该按钮点击以下会有响应。

比如登陆按钮用于完成登陆，注册按钮用于完成注册。在程序中会把这种能力称为时间。Java在过去使用匿名函数来支持事件能力，随着Java8的升级后，现在更推荐使用`Lambda` 来支持事件行为

> Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。

其实在所有的编程语言里，函数都是最重要的组成部分，函数和方法很多时候是一样的含义。只要有个概念就好，因为这个直接理解起来会很抽象。

```java
Button loginButton = new Button("Login");
// 给 loginButton 添加一个点击事件
loginButton.addClickListener(click->{
    System.out.println("login");
});
```

### 3.3逻辑语句

常见的if格式为

if(布尔表达式) {

​	// 布尔表达式将true将执行的语句 

}

比如在登录行为中对用户名、密码进行比对代码

```java
loginButton.addClickListener(click -> {

    String userNameText = userNameField.getValue();

    if ("admin".equals(userNameText)){
        System.out.println("用户名正确");
    }

});
```

字符串的`equals`方法用于比较前后字符串是否内容相等。

除了 if else 之外，还有if ... else if ...else 语句，但需要注意的是：

- if语句之多一个else语句，else语句在所有else if 语句之后

- if语句可以有若干个else if语句，他们必须在else 语句之前

- 从前往后、一旦其中一个语句检测为true ，其他的else if 以及 else 语句都将跳过执行

  

- ```java
  if(布尔表达式 1){
     //如果布尔表达式 1的值为true执行代码
  }else if(布尔表达式 2){
     //如果布尔表达式 2的值为true执行代码
  }else if(布尔表达式 3){
     //如果布尔表达式 3的值为true执行代码
  }else {
     //如果以上布尔表达式都不为true执行代码
  }
  ```

在vaadin框架中，还有个专门的提示组件`Notification`它的完整路径为

`com.vaadin.flow.component.notification.Notification`

Notification 组件有几个重要的方法

- setText(String text)

> 设置提示的内容

- setDuration(int duration)

> 设置提示框持续的时间

- open()

> 显示提示框

### 3.4 自定义方法

```java
notification.setDuration(3000);
```

这行代码抽取出来，这个行为在以后写代码中会经常遇到，一般叫做重构，从而优化代码

~~~java
```java
Notification notification = new Notification();

loginButton.addClickListener(click -> {

    String userNameText = userNameField.getValue();
    String pwdText = passwordField.getValue();

    if ("admin".equals(userNameText) && "admin".equals(pwdText)) {
        notification.setText("login success");
        notification.setDuration(3000);
        notification.open();
    } else {
        notification.setText("login error");
        notification.setDuration(3000);
        notification.open();
    }

});
```
~~~

如果一直这样添加代码下去，这个代码估计要很多行了，维护起来会爆炸（因为找代码就要很久）

在编程中，惯用的技巧就是把一类行为的代码重构成一个代码块，然后去执行这个代码块就ok了。这种代码块呢，就是方法。其实前面所用的 Lambda 本质上也是一种方法，构造函数也是。

方法的语法格式是

```java
// public（公共的） 
public  返回类型 方法名称(方法参数){
  代码块
}
```

> 如果没有返回类型，可以是无返回类型: void

### 3.5 注解

在Vaddin框架中， 使用了注解技术来支持多页

```java
import com.vaadin.flow.router.Route;

@Route("/")
public class Todo extends VerticalLayout {

}
```

@Route("/") 就是一个注解

> 注解编程是Spring Boot 进行编程的一个重要方式。

### 4.1 面向对象概要

***Java语言最核心的点就是面向对象。***

前面已经接触过各种各样的对象，例如

- TextField

> 处理输入框的对象

- Button

> 处理按钮行为的对象

- Route

> 处理页面地址的对象

- VerticalLayout

> 处理页面布局的对象

- String

> 存储字符串的类对象

- Boolean / boolean

> 存储布尔的类对象

- Integer / int

> 存储数字类型的类对象

包括自己创建的各种自定义类等等都是对象。

要想将注册完的用户进行存储下来，用于支持登陆，需要：

1. **对象的封装**（将用户数据封装成为Java能识别的User对象）
2. **日期对象**（比如gmtCreatedTime和gmtModifiedTime 一般存储为计算机的日期类型，这样既能减少内存的存储空间，又能做日期计算.）
3. **封装对象的数据操作** （对User对象数据的读写）
4. **集合和循环** （存储多个注册用户）
5. **常量** （完成对象的存储）

### 4.2 封装User对象

既然需要完成用户注册的数据存储，那第一步要做的就是通过封装，将真实的一个用户信息抽象成一个Java的User对象

> 一般这种封装事物的类对象，会存放在xxx.model这个子包里。

将事物抽象成类对象后，下一步要解决的就是封装事物的属性。比如说用户信息基本包含两个属性

- 用户名
- 密码

利用 getter 和 setter 方法将属性封装到对象中，企业中把这种封装的对象叫做POJO类。



### 4.3 LocalDateTime

一般进行用户注册，同时需要存储注册时间(LocalDateTime gmtCreated)，比如：

```java
2021-01-01 18:30:00
```

> 在 Java 当中，有两种时间日期类型，一种是 Java8以前用的 Date，一种是Java8以后主推的 LocalDateTime.

为什么需要一个时间日期类型呢，因为时间类型除了记录时间之外，还支持时间、日期计算，这个是非常常用的功能，比如说想要查询5天前的数据，查询去年的数据，这些时间日期类型都能轻松的满足。

> 还有一点时间日期类型存储到计算机里占用的内存会比字符串更小

Java8以后的时间类型有几个

- java.time.LocalDate 表示日期

  比如 2021-01-01，像出生年月日这种的就可以使用

- java.time.LocalTime 表示时间

  比如 12:30:00，像几点的会议就可以使用

- java.time.LocalDateTime 表示日期和时间

  比如 2021-01-01 12:30:00，像报名时间、注册时间之类的就可以使用

LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印，也就是说如果直接使用字符串输出格式是遵循 ISO 格式的。

注意ISO 8601规定的日期和时间分隔符是T。标准格式如下：

```java
日期：yyyy-MM-dd
时间：HH:mm:ss
带毫秒的时间：HH:mm:ss.SSS
日期和时间：yyyy-MM-dd'T'HH:mm:ss
带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS
```

ISO 8601 格式和我们中国国内使用的格式不一样，所以呢，一般需要借助`java.time.format.DateTimeFormatter`来输出指定格式的字符串

同样也可以使用 LocalDateTime.parse 来把字符串转换成时间类型

> 时间类型的这个具体的格式呢，初次使用的时候可能会记不住，所以有个概念就可以了，因为是靠练习来记住的。

### 4.4 接口介绍

要想支持多个用户的注册，需要借助Java的集合来存储

> 也可以使用数组来存储，算法相关的会使用到数组，绝大多数情况下，都是使用集合类来存储的。

与集合有关的还有两个知识点

- 接口
- 集合接口

接口是Java语言体系里非常高级和重要的一个能力，现代的Java程序里基本离不开接口，Java的源代码也是大量基于接口来开发的

> 接口是Java编程语言中的一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而继承接口的抽象方法。

接口通俗理解来看就像一堆方法的集合，只不过这个方法只是做了接口的约定。一个接口可以有很多种实现，方法的重载。Java当中集合也有专门的接口定义的，Collection这个接口就可以表明支持存储多个元素

Collection接口有三种子类型，List、Set 和 Queue（他们都继承于 Collection），再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。



集合框架是一个用来代表和操作集合的统一架构。所有的集合框架都包含如下内容：

![java-coll.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/java-coll.png?raw=true)

- 接口: 代表集合的抽象数据类型 如Collection、List、Set、Map等。通过多个接口，为了以不同的方式操作集合对象。

- 实现(类) ： 是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。

- 算法：实现集合接口的对象里的方法执行的一些有用的计算。



除了集合，该框架也定义了几个Map接口和类。Map里存储的是键/值对。尽管Map不是集合，但是它完全整合在集合中.

### 4.5 ArrayList

ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它没有固定大小的限制，我们可以添加或删除元素。

ArrayList 继承了 AbstractList，并实现了`java.util.List`接口

![ArrayList.png](https://github.com/ddddddongyanzu/ddddddongyanzu.github.io/blob/master/images/posts/ArrayList.png?raw=true)

`java.util.List`接口有几个常用的方法：

```java
public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上。
public E get(int index):返回集合中指定位置的元素。
public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素。
public int size():取得集合里元素的个数，list.size( );
public void clear():删除所有元素,list.clear();
```

在Java当中接口是不能直接被实例化的，所以如果想要创建一个接口类型的变量，得需要new 实现类。

`java.util.List`接口的实现类一般会用 `java.util.ArrayList`

```java
// 创建一个字符串集合，用于存储多个字符串
List<String> strings = new ArrayList<>();

// 创建一个用户集合，用于存储多个用户信息
List<User> users = new ArrayList<>();
```

接口的运用还是比较复杂的，在企业中接口运用会非常平凡，但本项目主要要掌握的是使用接口。

当我们对接口使用熟练后，就会开始自定义接口。

### 4.6 循环

在已经学习完List后， 已经具备了操作集合的能力

但是在目前掌握的集合能力，还少了一个非常重要和高频的场景-循环。

常见的有：

- for i
- for
- while
- do while

### 4.7 常量

在处理注册用户的数据时，常常使用常量来进行存储集合数据。

- 常量本质上也是一种类变量，只是多了一个static关键字，常量也可以叫做静态常量。
- 常量可以通过: ClassName.VariableName的方式访问
- 常量在第一次访问时被创建，在程序结束时销毁
- 无论一个类创建了多个个对象，类只拥有类遍历的一份拷贝。

##### 生命周期:

**常量在第一次访问时被创建，在程序结束时销毁**

##### 访问方式：

用static修饰的成员变量和方法，从属于类（普通变量和方法从属于对象）

> 静态方法不能调用非静态成员，编译会报错

##### static 方法

static方法也称为静态方法，由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this的，因此不依附于任何对象，既然没有对象，就谈不上this了，并且由于此特性，在静态方法中不能访问类的非静态成员变量和非静态方法，因为非静态成员变量和非静态方法都必须依附于具体的对象才能调用。

> 虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量的。

##### static 变量

static变量也称为静态变量，静态变量和非静态变量的区别：

- 静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化
- 非静态变量是对象拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

#### static块

静态初始化块的作用就是：提升程序性能。

### 5.1 文件系统摘要

在之前的程序中有一个问题，那就是在Java程序重启后，之前注册的数据都会丢失掉。

> 常量数据是储存在Java的内存里，所以当程序重启后内存的数据会丢失的。

所以，如果不想数据丢失，就需要考虑数据持久化，一般持久化有两种手段

- 存储在文件系统里面
- 存储在数据库里（如mysql，mongodb）

为了存储所有的注册数据，就需要借助Java的文件系统把User集合数据存储，需要掌握以下知识点：

- 异常
- 文件
- commons-io 库
- 读写文件
- JSON

在掌握这些知识前，优先要掌握的是语法和代码的作用。

### 5.2 异常

在一个程序中，最需要重视的就是Bug。为了更好地防备Bug，这就需要借助Java的异常处理，异常时程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。



比如代码少了一个分号，运行结果提示是错误 `java.lang.Error`如果能用System.out.println(11/0)，这种用0作为除数，会抛出`java.lang.ArithmeticException`的异常

异常发生的原因有很多，但通常包括以下几个大类：



- 用户输入了非法数据
- 要打开的文件不存在
- 网络通信时连接中断，或者JVM内存溢出

这些异常有的事因为用户错误引起的，有的事程序错误引起的，还是其他一些事因为物理错误引起的。



##### 运行时异常 



运行时异常是可以被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。



##### 错误



错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当程序的内存溢出了（需要的内存大于机器内存），一个错误就发生了，它们在编译也检查不到。



**捕获异常**



使用try和catch关键字可以捕获异常。try/catch的语法如下：

```java
try
{
   // 程序代码
}catch(ExceptionName e1){
   //Catch 块
}
```

Catch语句包含要捕获异常类型的声明，当保护代码块中发生一个异常时，try后面的catch块就会被检查。如果发生的异常包含在catch块，这和传递一个参数到方法时一样的。

### 5.3 文件读

在Java生态里使用最多的第三方工具集时：

Apache Commons



Apache Commons 包含了很多开源工具，用于解决平时编程经常会遇到的各种问题，减少重复劳动。java的文件API处理有点复杂。Apache commons-io 库就是为了简化 Java IO操作的，可以很轻松的读写文件，在企业中也很少直接运用JAva原生API操作文件读写，所以 commons-io 库是必须要掌握的能力



配置 Apache commons-io

找到工程中的 `pom.xml`文件，在`<dependencies>`节点里添加如下的内容



```xml
<dependency>
  <groupId>commons-io</groupId>
  <artifactId>commons-io</artifactId>
  <version>2.10.0</version>
</dependency>
```

在读取目录 data 下的xxxx.txt文件，会有一个FileUtils的readLines方法，这个方法在按行读取文件的场景里使用得特别多，在全部读取时，就使用 readFileToString方法。



###  5.4 JSON数据

对于文件按行读取再解析也还是挺复杂的，实际上企业中有个更成熟和优雅的方案，即是基于JSON来进行文件解析。



JSON ：JavaScript Object Notation 是目前最常用的执行对象序列的方式。



虽然 json最初是为了在Java Script 语言中使用的，但实际上 json本身与语言没有任何关系，各种编程语言都可以使用，json也能作为一种跨语言的文本数据（即不支持其它多媒体）交换格式，无障碍的把数据传递到其它语言的程序

> JSON 基本格式：

必须是 **对象**： {} ， 或者是 **数组** []



- 数据用 `名称:值` 键值对表示

- - 名称（键）必须是字符串

- - 键、值之间用冒号 `:`分隔。

- 多条数据之间，用逗号`,`分隔
- 上面的 : , 均为半角符号



JSON值的类型：



- 数字（整数或浮点数）
- 字符串
- 逻辑值 boolean
- 数组
- 对象
- null



目前企业中广泛使用spring boot 框架来搭建应用， SpringBoot内部集成了jackson这个json框架，大多数时候，为们还是用Jackson来处理json



```java
@JsonDeserialize(using = LocalDateTimeDeserializer.class)
@JsonSerialize(using = LocalDateTimeSerializer.class)
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime gmtCreated;
```

### 5.5 写文件

FileUtils.writeFileToString(file , data , charsetName) 同样会抛出异常， 需要try catch环绕。



```java
private static File usersFile = new File("./data/users.json");

if (usersFile.exists()) {
            try {
               String content = FileUtils.readFileToString(usersFile, "utf-8");

                List<User> userList = mapper.readValue(content, new TypeReference<List<User>>() {
                });

                users.addAll(userList);

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
```

#### 6.1 用户登陆

完成了注册之后，现在实现登陆逻辑



完成登陆需要解决几个点：

- 登陆表单页的开发
- 用户名密码的判断
- 登陆状态的持久处理



##### 注册和登录部分代码：

```java
package org.vaadin.marcus.spring;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.router.Route;
import org.apache.commons.io.FileUtils;
import org.vaadin.marcus.spring.model.User;

import java.io.File;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * @author dyz
 * @date 2021/6/7
 */
@Route("/reg.html")
public class Reg extends VerticalLayout {

    public static List<User> users = new ArrayList<>();

    private static ObjectMapper mapper = new ObjectMapper();
    private static File usersFile = new File("./data/users.json");

    static {

        if (usersFile.exists()) {
            try {
               String content = FileUtils.readFileToString(usersFile, "utf-8");

                List<User> userList = mapper.readValue(content, new TypeReference<List<User>>() {
                });

                users.addAll(userList);

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    public Reg() {

        TextField userNameField = new TextField();
        initUserNameField(userNameField);

        TextField passwordField = new TextField();
        initPasswordField(passwordField);

        TextField confirmPasswordField = new TextField();
        initConfirmPasswordField(confirmPasswordField);

        Button regButton = new Button("Reg");

        regButton.addClickListener(click -> {
            onReg(userNameField, passwordField, confirmPasswordField);
        });

        add(userNameField);
        add(passwordField);
        add(confirmPasswordField);
        add(regButton);

    }

    public void initUserNameField(TextField userNameField) {
        String userName = "UserName";
        userNameField.setLabel(userName);
        userNameField.setPlaceholder("please input username");
    }

    public void initPasswordField(TextField passwordField) {
        String password = "Password";
        passwordField.setLabel(password);
        passwordField.setPlaceholder("please input password");
    }

    public void initConfirmPasswordField(TextField passwordField) {
        String password = "Confirm Password";
        passwordField.setLabel(password);
        passwordField.setPlaceholder("please input confirm password");
    }

    public void onReg(TextField userNameField, TextField passwordField, TextField confirmPasswordField) {
        String userNameText = userNameField.getValue();
        String pwdText = passwordField.getValue();
        String confirmPwdText = confirmPasswordField.getValue();

        Notification notification = new Notification();
        notification.setDuration(3000);

        if (userNameText == null || "".equals(userNameText)) {
            notification.setText("need input username");
            notification.open();
            // 程序执行到这就结束啦，后面的代码不再执行咯
            return;
        }

        if (pwdText != null && !"".equals(pwdText) && pwdText.equals(confirmPwdText)) {

            for (User user : users) {

                if (userNameText.equals(user.getUserName())){
                    notification.setText("username already reg");
                    notification.open();
                    return;
                }

            }

            User user = new User();
            user.setUserName(userNameText);
            user.setPassword(pwdText);

            LocalDateTime gmtCreated = LocalDateTime.now();
            user.setGmtCreated(gmtCreated);

            users.add(user);

            String userName = user.getUserName();

            notification.setText("reg success " + userName);

            try {
                String content = mapper.writeValueAsString(users);
                FileUtils.writeStringToFile(usersFile, content, "utf-8");
            } catch (Exception e) {
                e.printStackTrace();
            }

        } else {
            notification.setText("confirm pwd error");
        }
        notification.open();

    }

}

```

